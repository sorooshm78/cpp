## Introduction
هدف این فصل و سه فصل بعدی، این است که به شما ایده‌ای درباره‌ی C++ بدهد، بدون اینکه وارد جزئیات زیادی شود. این فصل به طور غیررسمی به ارائه‌ی نمادگذاری C++، مدل حافظه و محاسبات در C++ و مکانیزم‌های پایه‌ای برای سازمان‌دهی کد به یک برنامه می‌پردازد. اینها امکانات زبان هستند که از سبک‌هایی که اغلب در C دیده می‌شود و گاهی به آن‌ها برنامه‌نویسی رویه‌ای گفته می‌شود، پشتیبانی می‌کنند. فصل 3 با ارائه مکانیزم‌های انتزاعی C++ ادامه می‌یابد. فصل 4 و فصل 5 نیز مثال‌هایی از امکانات کتابخانه استاندارد ارائه می‌دهند.

---

در **Procedural programming** (برنامه‌نویسی رویه‌ای) یک سبک یا پارادایم برنامه‌نویسی است که در آن برنامه‌ها به عنوان مجموعه‌ای از توابع یا رویه‌ها تعریف می‌شوند. این رویکرد به جای تمرکز بر اشیا و داده‌ها، بر روی ترتیب اجرای دستورات و توابع تأکید دارد. در این سبک، برنامه‌نویس عملیات مورد نیاز برای حل یک مسئله را به بخش‌های کوچک‌تر (رویه‌ها یا توابع) تقسیم می‌کند که هر کدام کار خاصی را انجام می‌دهند.

ویژگی‌های اصلی برنامه‌نویسی رویه‌ای عبارتند از:

1. **توابع (Procedures/Functions)**: کد به صورت توابع یا زیرروال‌ها سازمان‌دهی می‌شود که هر کدام وظیفه خاصی را انجام می‌دهند. این توابع می‌توانند بارها و بارها در قسمت‌های مختلف برنامه فراخوانی شوند.
  
2. **ساختار کنترل**: برای کنترل جریان برنامه از ساختارهای کنترلی مانند حلقه‌ها (loops) و شرط‌ها (if/else) استفاده می‌شود.
  
3. **متغیرها و داده‌های سراسری**: متغیرها می‌توانند به صورت سراسری (global) یا محلی (local) تعریف شوند و در سراسر برنامه یا فقط در یک تابع خاص قابل دسترسی باشند.

4. **الگوریتم‌محور**: برنامه‌نویسی رویه‌ای بیشتر بر طراحی الگوریتم‌ها برای انجام کارها و ترتیب اجرای دستورات تمرکز دارد.

زبان‌هایی مثل C و پاسکال نمونه‌های بارزی از زبان‌های برنامه‌نویسی رویه‌ای هستند. در C++، با وجود اینکه این زبان از شی‌گرایی پشتیبانی می‌کند، هنوز هم می‌توان از این سبک برنامه‌نویسی استفاده کرد، همان‌طور که در زبان C انجام می‌شود.

---

این مرور سریع از C++ ما را از یک ارائه کاملاً «پایین به بالا» از امکانات زبان و کتابخانه نجات می‌دهد، با این امکان که حتی در فصل‌های اولیه هم از مجموعه‌ای غنی از امکانات استفاده کنیم. به عنوان مثال، حلقه‌ها تا فصل ۱۰ به‌طور مفصل بحث نمی‌شوند، اما خیلی زودتر از آن به شکل‌های آشکاری مورد استفاده قرار خواهند گرفت. به همین ترتیب، توضیحات جزئی درباره کلاس‌ها، الگوها (templates)، استفاده از حافظه پویا (free-store)، و کتابخانه استاندارد در طول فصل‌های زیادی پخش شده است، اما از انواع کتابخانه استاندارد مانند **vector**، **string**، **complex**، **map**، **unique_ptr**، و **ostream** در هر جا که لازم باشد، برای بهبود مثال‌های کد استفاده خواهد شد.

به‌عنوان یک قیاس، این مرور سریع را می‌توانید به یک تور دیدنی کوتاه از یک شهر، مانند کپنهاگ یا نیویورک، تشبیه کنید. در عرض چند ساعت، یک نگاه سریع به جاذبه‌های اصلی دارید، چند داستان پس‌زمینه شنیده‌اید و معمولاً چند پیشنهاد برای دیدن چیزهای دیگر دریافت می‌کنید. پس از چنین توری، شما شهر را به‌طور کامل نمی‌شناسید و همه آنچه دیده‌اید و شنیده‌اید را درک نمی‌کنید. برای شناخت واقعی یک شهر، باید سال‌ها در آن زندگی کنید. اما با کمی شانس، یک نمای کلی از شهر، ایده‌ای از ویژگی‌های خاص آن و چیزهایی که ممکن است برایتان جالب باشد به دست آورده‌اید. پس از این تور، اکتشاف واقعی می‌تواند آغاز شود.

این مرور، C++ را به‌عنوان یک کل یکپارچه ارائه می‌دهد، نه به‌عنوان یک «کیک چندلایه». به همین دلیل، ویژگی‌های زبان به‌عنوان ویژگی‌هایی که در C وجود داشته، بخشی از C++98 هستند یا در C++11 جدید هستند، مشخص نمی‌شوند. این اطلاعات تاریخی را می‌توانید در بخش ۱.۴ و فصل ۴۴ پیدا کنید.

## The Basics
زبان C++ یک زبان **کامپایل‌شونده** است. برای اجرای یک برنامه، کد منبع آن باید توسط کامپایلر پردازش شود که منجر به تولید فایل‌های شیء (object files) می‌شود. این فایل‌ها سپس توسط یک لینک‌کننده (linker) با هم ترکیب شده و یک برنامه اجرایی (executable) تولید می‌کنند. معمولاً یک برنامه C++ شامل بسیاری از فایل‌های کد منبع (که معمولاً به سادگی فایل‌های منبع نامیده می‌شوند) است.

![](./image/2/2.1.png)

یک برنامه اجرایی برای یک ترکیب خاص از سخت‌افزار/سیستم ساخته می‌شود؛ بنابراین، به‌طور مستقیم قابل انتقال از یک سیستم به سیستم دیگر، مثلاً از مک به ویندوز، نیست. هنگامی که درباره **قابلیت حمل (portability)** برنامه‌های C++ صحبت می‌کنیم، معمولاً منظور ما قابلیت حمل کد منبع است؛ یعنی کد منبع می‌تواند به‌طور موفقیت‌آمیز روی سیستم‌های مختلف کامپایل و اجرا شود.

استاندارد ISO C++ دو نوع موجودیت را تعریف می‌کند:
- **ویژگی‌های اصلی زبان**: مانند انواع داخلی (مثل `char` و `int`) و حلقه‌ها (مثل دستورات `for` و `while`).
- **اجزای کتابخانه استاندارد**: مانند **container**‌ها (مانند `vector` و `map`) و عملیات ورودی/خروجی (مثل `<<` و `getline()`).

اجزای کتابخانه استاندارد، کدهای عادی C++ هستند که توسط هر پیاده‌سازی C++ ارائه می‌شوند. به عبارت دیگر، کتابخانه استاندارد C++ می‌تواند در خود C++ پیاده‌سازی شود (و این کار انجام می‌شود، به جز استفاده‌های بسیار جزئی از کد ماشین برای چیزهایی مانند تعویض زمینه‌ی (context switching) رشته‌ها). این بدان معناست که C++ به اندازه کافی **بیان‌پذیر** و **کارآمد** برای انجام سخت‌ترین وظایف برنامه‌نویسی سیستم است.

زبان C++ یک زبان **با نوع ایستا** (statically typed) است. یعنی نوع هر موجودیت (مانند شیء، مقدار، نام و عبارت) باید در زمان استفاده از آن توسط کامپایلر مشخص باشد. نوع یک شیء تعیین می‌کند که چه مجموعه‌ای از عملیات روی آن قابل اجرا است.

---

در یک زبان **کامپایل‌شونده** مثل C++، فرآیند اجرای یک برنامه شامل چند مرحله است که در نهایت منجر به تولید یک فایل اجرایی می‌شود که می‌تواند روی سیستم اجرا شود. این فرآیند به شکل زیر انجام می‌شود:

1. **نوشتن کد منبع (Source Code)**:
   ابتدا برنامه‌نویس کد برنامه را به زبان C++ می‌نویسد. این کد به صورت فایل‌های متنی ذخیره می‌شود که به آن‌ها **فایل‌های منبع** یا **source files** گفته می‌شود. معمولاً فایل‌های C++ دارای پسوند `.cpp` یا `.h` هستند. 

2. **کامپایلر (Compiler)**:
   کامپایلر وظیفه دارد که کد منبع را به زبان ماشین ترجمه کند. زبان ماشین کدی است که مستقیماً توسط پردازنده سیستم قابل درک و اجرا است. هر کامپایلر برای معماری‌های سخت‌افزاری خاص و سیستم‌عامل‌های خاص طراحی می‌شود.

   فرآیند کامپایل به دو مرحله اصلی تقسیم می‌شود:
   - **تجزیه و تحلیل (Parsing)**: کامپایلر ابتدا کد منبع را تجزیه می‌کند و بررسی می‌کند که آیا قواعد نحوی (syntax) زبان C++ رعایت شده است یا خیر. همچنین، کامپایلر بررسی می‌کند که آیا انواع داده‌ها و ساختارهای تعریف شده در برنامه صحیح هستند یا خیر (چک کردن نوع، نوع ایستا).
   - **تولید کد (Code Generation)**: پس از تجزیه موفق، کامپایلر کد زبان ماشین را تولید می‌کند و آن را به عنوان فایل‌های **شیء** یا **object files** ذخیره می‌کند. فایل‌های شیء حاوی کدهای باینری هستند که فقط بخشی از برنامه را تشکیل می‌دهند و برای اجرا کامل نیاز به لینک شدن دارند.

3. **لینک‌کننده (Linker)**:
   در مرحله لینک کردن، **لینک‌کننده** فایل‌های شیء (object files) را با هم ترکیب می‌کند تا یک برنامه کامل و اجرایی ایجاد شود. لینک‌کننده وظیفه دارد که تمام توابع و متغیرهای تعریف‌شده در فایل‌های مختلف را به یکدیگر مرتبط کند. به‌عنوان مثال، ممکن است شما در یک فایل منبع یک تابع تعریف کرده باشید و در فایل دیگری آن را فراخوانی کنید. لینک‌کننده اطمینان می‌دهد که این ارتباطات به درستی برقرار می‌شوند.

   علاوه بر این، لینک‌کننده کتابخانه‌های خارجی (مثل کتابخانه استاندارد C++) را نیز به برنامه متصل می‌کند تا بتوان از امکانات آن‌ها استفاده کرد. پس از اتمام لینک کردن، نتیجه یک فایل **اجرایی (executable)** است که می‌تواند توسط سیستم‌عامل و سخت‌افزار مربوطه اجرا شود.

4. **فایل اجرایی (Executable)**:
   این فایل نهایی، همان برنامه‌ای است که روی یک سیستم خاص قابل اجراست. این برنامه برای ترکیب خاصی از سخت‌افزار و سیستم‌عامل ساخته شده و به‌طور مستقیم نمی‌تواند روی سیستم‌های متفاوتی اجرا شود. به عنوان مثال، یک فایل اجرایی که روی سیستم عامل ویندوز تولید شده، روی مک به‌صورت مستقیم اجرا نمی‌شود.

### قابلیت حمل (Portability)
وقتی از قابلیت حمل در C++ صحبت می‌کنیم، منظور **قابلیت حمل کد منبع** است، نه فایل اجرایی. به این معنا که کد منبعی که شما نوشته‌اید، باید بتواند روی سیستم‌های مختلف (مثل ویندوز، مک، لینوکس) کامپایل و اجرا شود. اما فایل اجرایی تولیدشده توسط کامپایلر معمولاً فقط روی همان سیستم و سخت‌افزاری که برای آن کامپایل شده است، قابل اجراست. بنابراین، برای اجرای برنامه روی سیستم‌های مختلف، باید کد منبع مجدداً روی آن سیستم کامپایل شود. 

در نتیجه:
- **کامپایلر** کد منبع را به کد ماشین ترجمه می‌کند.
- **لینک‌کننده** فایل‌های شیء و کتابخانه‌ها را ترکیب می‌کند تا یک فایل اجرایی ایجاد شود.
- فایل اجرایی تنها برای سیستم خاصی که برای آن کامپایل شده قابل اجراست، اما کد منبع می‌تواند روی سیستم‌های مختلف کامپایل و اجرا شود.


---




---

برای اینکه فرآیند کامپایل، لینک و ایجاد برنامه اجرایی در C++ را بهتر درک کنیم، بیایید آن را با دقت بیشتری همراه با مثال توضیح دهیم.

### 1. نوشتن کد منبع (Source Code)

فرض کنید شما می‌خواهید یک برنامه ساده بنویسید که دو عدد را جمع بزند. برای این کار ابتدا باید کد منبع برنامه را بنویسید. این کد به زبان C++ نوشته می‌شود و در یک فایل متنی با پسوند `.cpp` ذخیره می‌شود. به‌عنوان مثال:

**File: `main.cpp`**
```cpp
#include <iostream>  // این خط کتابخانه iostream را برای استفاده از ورودی و خروجی وارد می‌کند

int add(int a, int b) {
    return a + b;   // تابعی که دو عدد را می‌گیرد و آن‌ها را جمع می‌زند
}

int main() {
    int x = 5;    // عدد اول
    int y = 10;   // عدد دوم
    std::cout << "Sum: " << add(x, y) << std::endl;  // چاپ نتیجه جمع دو عدد
    return 0;
}
```

### 2. کامپایلر (Compiler)

پس از نوشتن کد، باید آن را کامپایل کنید. **کامپایلر** وظیفه دارد که کد C++ را به **کد ماشین** (که پردازنده سیستم می‌تواند آن را بفهمد) تبدیل کند.

#### مراحل کامپایل:
- **تجزیه و تحلیل نحوی (Parsing)**: کامپایلر ابتدا کد را بررسی می‌کند که آیا همه چیز مطابق با قوانین نحو (syntax) C++ است یا خیر. مثلاً بررسی می‌کند که `int` به درستی برای نوع داده استفاده شده و اینکه تابع `add` به درستی تعریف شده است.
- **تجزیه و تحلیل نوع (Type Checking)**: سپس کامپایلر مطمئن می‌شود که انواع داده‌ها (مثل `int`) به درستی استفاده شده‌اند. اگر مثلاً به جای عدد صحیح، یک رشته به تابع `add` ارسال شود، کامپایلر خطا خواهد داد.
- **تولید کد (Code Generation)**: در این مرحله، کامپایلر کد ماشین را تولید می‌کند. این کد مستقیماً توسط پردازنده قابل اجرا است.

نتیجه کامپایل، تولید فایل‌های شیء (object files) است. فایل‌های شیء فایل‌هایی هستند که شامل کد باینری قابل اجرا هستند، اما به صورت کامل لینک نشده‌اند. برای مثال، خروجی کامپایلر برای فایل `main.cpp` می‌تواند `main.o` باشد.

### 3. لینک‌کننده (Linker)

پس از اینکه فایل‌های شیء توسط کامپایلر تولید شدند، این فایل‌ها هنوز آماده اجرا نیستند. اینجاست که **لینک‌کننده (linker)** وارد عمل می‌شود.

#### وظایف لینک‌کننده:
- **لینک کردن توابع و متغیرها**: در فایل‌های منبع مختلف، ممکن است توابع و متغیرهایی تعریف شده باشند که در فایل‌های دیگر مورد استفاده قرار می‌گیرند. لینک‌کننده وظیفه دارد که این موارد را به هم مرتبط کند. به‌عنوان مثال، در کد بالا، تابع `add` در جایی جدا تعریف شده و در تابع `main` استفاده شده است. لینک‌کننده باید این دو را به هم وصل کند.
- **اتصال به کتابخانه‌ها (Libraries)**: علاوه بر فایل‌های شیء برنامه شما، لینک‌کننده همچنین کتابخانه‌های خارجی مثل کتابخانه استاندارد C++ (که شامل توابعی مثل `std::cout` و `std::endl` است) را به برنامه متصل می‌کند. برای مثال، `iostream` کتابخانه‌ای است که به شما اجازه می‌دهد از ورودی و خروجی استفاده کنید، و این کتابخانه باید توسط لینک‌کننده به برنامه شما متصل شود.

نتیجه لینک کردن یک فایل اجرایی (Executable) است که می‌تواند مستقیماً توسط سیستم‌عامل اجرا شود. در این مثال، فایل اجرایی ممکن است `main.exe` در ویندوز یا `a.out` در لینوکس نامیده شود.

### 4. فایل اجرایی (Executable)

فایل اجرایی نهایی شامل تمام کدهای باینری است که پردازنده سیستم می‌تواند آن را مستقیماً اجرا کند. شما می‌توانید این فایل اجرایی را در خط فرمان یا با دوبار کلیک کردن روی آن اجرا کنید. مثلاً در لینوکس:

```
./a.out
```

خروجی:
```
Sum: 15
```

### مثال جامع‌تر: برنامه چند فایل

حالا فرض کنید برنامه شما بزرگ‌تر باشد و از چندین فایل منبع استفاده کند. برای مثال:

**File: `math.cpp`**
```cpp
int add(int a, int b) {
    return a + b;
}
```

**File: `main.cpp`**
```cpp
#include <iostream>
int add(int, int);  // اعلام تابع add

int main() {
    int x = 5;
    int y = 10;
    std::cout << "Sum: " << add(x, y) << std::endl;
    return 0;
}
```

در اینجا، تابع `add` در فایل `math.cpp` تعریف شده و در `main.cpp` استفاده می‌شود. هر دو فایل باید کامپایل شوند، سپس لینک‌کننده آن‌ها را به هم متصل می‌کند.

#### کامپایل جداگانه:
```
g++ -c main.cpp -o main.o
g++ -c math.cpp -o math.o
```

#### لینک کردن:
```
g++ main.o math.o -o myprogram
```

خروجی:
```
./myprogram
Sum: 15
```

### توضیح مراحل:
1. **کامپایلر** هر فایل را جداگانه کامپایل می‌کند و فایل‌های شیء (مثل `main.o` و `math.o`) تولید می‌کند.
2. **لینک‌کننده** فایل‌های شیء را ترکیب کرده و یک فایل اجرایی نهایی به نام `myprogram` ایجاد می‌کند.

### نکته درباره **قابلیت حمل (Portability)**:
فایل اجرایی (`myprogram`) که روی سیستم‌عامل خاصی مثل لینوکس ساخته شده، نمی‌تواند به‌طور مستقیم روی سیستم‌عاملی دیگر مثل ویندوز اجرا شود. برای اجرای برنامه روی ویندوز، باید کد منبع (`main.cpp` و `math.cpp`) را روی آن سیستم کامپایل و لینک کنید.

اما **کد منبع** معمولاً قابل حمل است؛ یعنی اگر از ویژگی‌های مستقل از سیستم‌عامل استفاده کرده باشید، می‌توانید همین کد منبع را روی سیستم‌های مختلف (مثل ویندوز، مک، یا لینوکس) کامپایل کنید و برنامه اجرایی مخصوص آن سیستم تولید شود.

---

## Hello, World!
کوچکترین برنامه C++ به صورت زیر است:

```cpp
int main() { } // the minimal C++ program
```

این یک تابع به نام `main` تعریف می‌کند که هیچ آرگومانی نمی‌گیرد و هیچ کاری انجام نمی‌دهد. آکولادها `{ }` در C++ برای گروه‌بندی استفاده می‌شوند. در اینجا، آن‌ها شروع و پایان بدنه تابع را نشان می‌دهند. دو اسلش `//` یک کامنت را آغاز می‌کند که تا پایان خط ادامه دارد. کامنت برای خواننده انسان است؛ کامپایلر کامنت‌ها را نادیده می‌گیرد.

هر برنامه C++ باید دقیقاً یک تابع سراسری به نام `main()` داشته باشد. برنامه با اجرای این تابع شروع می‌شود. مقدار `int` که توسط تابع `main()` برگردانده می‌شود (در صورت وجود) مقدار بازگشتی برنامه به «سیستم» است. اگر هیچ مقداری برگردانده نشود، سیستم مقداری که نشان‌دهنده موفقیت‌آمیز بودن اجرای برنامه است را دریافت می‌کند. یک مقدار غیر صفر از `main()` نشان‌دهنده شکست است. هر سیستم‌عامل یا محیط اجرایی لزوماً از مقدار بازگشتی استفاده نمی‌کند: محیط‌های مبتنی بر لینوکس/یونیکس اغلب این کار را می‌کنند، اما محیط‌های مبتنی بر ویندوز به‌ندرت این کار را انجام می‌دهند.

معمولاً یک برنامه مقداری خروجی تولید می‌کند. در اینجا یک برنامه ساده که عبارت "Hello, World!" را می‌نویسد:

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, World!\n";  
}
```

این برنامه از کتابخانه استاندارد `iostream` استفاده می‌کند تا عبارت "Hello, World!" را به خروجی (معمولاً کنسول) بنویسد.

خط `#include <iostream>` به کامپایلر دستور می‌دهد تا اعلان‌های مربوط به امکانات ورودی/خروجی استاندارد (stream I/O) که در فایل هدر **iostream** تعریف شده‌اند را وارد کند. بدون این اعلان‌ها، عبارت زیر معنایی نداشت:

```cpp
std::cout << "Hello, World!\n";
```

اپراتور `<<` (به معنی "put to") آرگومان دوم خود را به آرگومان اول منتقل می‌کند. در اینجا، رشته‌ی "Hello, World!\n" به جریان خروجی استاندارد **std::cout** منتقل می‌شود. یک **رشته‌ی متنی (string literal)** دنباله‌ای از کاراکترهاست که با علامت‌های نقل‌قول دوگانه محصور شده است. درون یک رشته‌ی متنی، کاراکتر بک‌اسلش `\` به همراه کاراکتر دیگری یک **کاراکتر خاص** را نشان می‌دهد. در این مثال، `\n` به معنی کاراکتر **newline** (خط جدید) است، بنابراین کاراکترهایی که نوشته می‌شوند، عبارت **Hello, World!** به‌همراه یک خط جدید هستند.

عبارت `std::` مشخص می‌کند که نام **cout** در فضای نام (namespace) استاندارد (std) قرار دارد. به طور معمول، وقتی درباره ویژگی‌های استاندارد صحبت می‌کنم، از `std::` استفاده نمی‌کنم. در بخش `§2.4.2` توضیح داده شده که چگونه می‌توان نام‌ها را از یک فضای نام قابل مشاهده کرد بدون نیاز به استفاده از `std::` در هر بار.

تقریباً همه‌ی کدهای اجرایی در توابع قرار می‌گیرند و مستقیماً یا غیرمستقیم از تابع **main()** فراخوانی می‌شوند. برای مثال:

```cpp
#include <iostream>
using namespace std; // نام‌های موجود در فضای نام std بدون نیاز به std:: قابل استفاده می‌شوند

double square(double x) // محاسبه‌ی مربع یک عدد اعشاری با دقت دوگانه (double)
{
    return x * x;
}

void print_square(double x) // تابعی برای چاپ نتیجه‌ی محاسبه‌ی مربع
{
    cout << "the square of " << x << " is " << square(x) << "\n";
}

int main()
{
    print_square(1.234); // خروجی: the square of 1.234 is 1.52276
}
```

در این مثال، **void** به‌عنوان **نوع بازگشتی (return type)** به این معنی است که تابع هیچ مقداری را بازنمی‌گرداند. برای مثال، تابع `print_square` هیچ مقداری برنمی‌گرداند، اما خروجی مورد نظر را به کنسول چاپ می‌کند.