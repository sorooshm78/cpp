## Introduction
هدف این فصل و سه فصل بعدی، این است که به شما ایده‌ای درباره‌ی C++ بدهد، بدون اینکه وارد جزئیات زیادی شود. این فصل به طور غیررسمی به ارائه‌ی نمادگذاری C++، مدل حافظه و محاسبات در C++ و مکانیزم‌های پایه‌ای برای سازمان‌دهی کد به یک برنامه می‌پردازد. اینها امکانات زبان هستند که از سبک‌هایی که اغلب در C دیده می‌شود و گاهی به آن‌ها برنامه‌نویسی رویه‌ای گفته می‌شود، پشتیبانی می‌کنند. فصل 3 با ارائه مکانیزم‌های انتزاعی C++ ادامه می‌یابد. فصل 4 و فصل 5 نیز مثال‌هایی از امکانات کتابخانه استاندارد ارائه می‌دهند.

---

در **Procedural programming** (برنامه‌نویسی رویه‌ای) یک سبک یا پارادایم برنامه‌نویسی است که در آن برنامه‌ها به عنوان مجموعه‌ای از توابع یا رویه‌ها تعریف می‌شوند. این رویکرد به جای تمرکز بر اشیا و داده‌ها، بر روی ترتیب اجرای دستورات و توابع تأکید دارد. در این سبک، برنامه‌نویس عملیات مورد نیاز برای حل یک مسئله را به بخش‌های کوچک‌تر (رویه‌ها یا توابع) تقسیم می‌کند که هر کدام کار خاصی را انجام می‌دهند.

ویژگی‌های اصلی برنامه‌نویسی رویه‌ای عبارتند از:

1. **توابع (Procedures/Functions)**: کد به صورت توابع یا زیرروال‌ها سازمان‌دهی می‌شود که هر کدام وظیفه خاصی را انجام می‌دهند. این توابع می‌توانند بارها و بارها در قسمت‌های مختلف برنامه فراخوانی شوند.
  
2. **ساختار کنترل**: برای کنترل جریان برنامه از ساختارهای کنترلی مانند حلقه‌ها (loops) و شرط‌ها (if/else) استفاده می‌شود.
  
3. **متغیرها و داده‌های سراسری**: متغیرها می‌توانند به صورت سراسری (global) یا محلی (local) تعریف شوند و در سراسر برنامه یا فقط در یک تابع خاص قابل دسترسی باشند.

4. **الگوریتم‌محور**: برنامه‌نویسی رویه‌ای بیشتر بر طراحی الگوریتم‌ها برای انجام کارها و ترتیب اجرای دستورات تمرکز دارد.

زبان‌هایی مثل C و پاسکال نمونه‌های بارزی از زبان‌های برنامه‌نویسی رویه‌ای هستند. در C++، با وجود اینکه این زبان از شی‌گرایی پشتیبانی می‌کند، هنوز هم می‌توان از این سبک برنامه‌نویسی استفاده کرد، همان‌طور که در زبان C انجام می‌شود.

---

این مرور سریع از C++ ما را از یک ارائه کاملاً «پایین به بالا» از امکانات زبان و کتابخانه نجات می‌دهد، با این امکان که حتی در فصل‌های اولیه هم از مجموعه‌ای غنی از امکانات استفاده کنیم. به عنوان مثال، حلقه‌ها تا فصل ۱۰ به‌طور مفصل بحث نمی‌شوند، اما خیلی زودتر از آن به شکل‌های آشکاری مورد استفاده قرار خواهند گرفت. به همین ترتیب، توضیحات جزئی درباره کلاس‌ها، الگوها (templates)، استفاده از حافظه پویا (free-store)، و کتابخانه استاندارد در طول فصل‌های زیادی پخش شده است، اما از انواع کتابخانه استاندارد مانند **vector**، **string**، **complex**، **map**، **unique_ptr**، و **ostream** در هر جا که لازم باشد، برای بهبود مثال‌های کد استفاده خواهد شد.

به‌عنوان یک قیاس، این مرور سریع را می‌توانید به یک تور دیدنی کوتاه از یک شهر، مانند کپنهاگ یا نیویورک، تشبیه کنید. در عرض چند ساعت، یک نگاه سریع به جاذبه‌های اصلی دارید، چند داستان پس‌زمینه شنیده‌اید و معمولاً چند پیشنهاد برای دیدن چیزهای دیگر دریافت می‌کنید. پس از چنین توری، شما شهر را به‌طور کامل نمی‌شناسید و همه آنچه دیده‌اید و شنیده‌اید را درک نمی‌کنید. برای شناخت واقعی یک شهر، باید سال‌ها در آن زندگی کنید. اما با کمی شانس، یک نمای کلی از شهر، ایده‌ای از ویژگی‌های خاص آن و چیزهایی که ممکن است برایتان جالب باشد به دست آورده‌اید. پس از این تور، اکتشاف واقعی می‌تواند آغاز شود.

این مرور، C++ را به‌عنوان یک کل یکپارچه ارائه می‌دهد، نه به‌عنوان یک «کیک چندلایه». به همین دلیل، ویژگی‌های زبان به‌عنوان ویژگی‌هایی که در C وجود داشته، بخشی از C++98 هستند یا در C++11 جدید هستند، مشخص نمی‌شوند. این اطلاعات تاریخی را می‌توانید در بخش ۱.۴ و فصل ۴۴ پیدا کنید.

## The Basics
زبان C++ یک زبان **کامپایل‌شونده** است. برای اجرای یک برنامه، کد منبع آن باید توسط کامپایلر پردازش شود که منجر به تولید فایل‌های شیء (object files) می‌شود. این فایل‌ها سپس توسط یک لینک‌کننده (linker) با هم ترکیب شده و یک برنامه اجرایی (executable) تولید می‌کنند. معمولاً یک برنامه C++ شامل بسیاری از فایل‌های کد منبع (که معمولاً به سادگی فایل‌های منبع نامیده می‌شوند) است.

![](./image/2/2.1.png)

یک برنامه اجرایی برای یک ترکیب خاص از سخت‌افزار/سیستم ساخته می‌شود؛ بنابراین، به‌طور مستقیم قابل انتقال از یک سیستم به سیستم دیگر، مثلاً از مک به ویندوز، نیست. هنگامی که درباره **قابلیت حمل (portability)** برنامه‌های C++ صحبت می‌کنیم، معمولاً منظور ما قابلیت حمل کد منبع است؛ یعنی کد منبع می‌تواند به‌طور موفقیت‌آمیز روی سیستم‌های مختلف کامپایل و اجرا شود.

استاندارد ISO C++ دو نوع موجودیت را تعریف می‌کند:
- **ویژگی‌های اصلی زبان**: مانند انواع داخلی (مثل `char` و `int`) و حلقه‌ها (مثل دستورات `for` و `while`).
- **اجزای کتابخانه استاندارد**: مانند **container**‌ها (مانند `vector` و `map`) و عملیات ورودی/خروجی (مثل `<<` و `getline()`).

اجزای کتابخانه استاندارد، کدهای عادی C++ هستند که توسط هر پیاده‌سازی C++ ارائه می‌شوند. به عبارت دیگر، کتابخانه استاندارد C++ می‌تواند در خود C++ پیاده‌سازی شود (و این کار انجام می‌شود، به جز استفاده‌های بسیار جزئی از کد ماشین برای چیزهایی مانند تعویض زمینه‌ی (context switching) رشته‌ها). این بدان معناست که C++ به اندازه کافی **بیان‌پذیر** و **کارآمد** برای انجام سخت‌ترین وظایف برنامه‌نویسی سیستم است.

زبان C++ یک زبان **با نوع ایستا** (statically typed) است. یعنی نوع هر موجودیت (مانند شیء، مقدار، نام و عبارت) باید در زمان استفاده از آن توسط کامپایلر مشخص باشد. نوع یک شیء تعیین می‌کند که چه مجموعه‌ای از عملیات روی آن قابل اجرا است.

---

در یک زبان **کامپایل‌شونده** مثل C++، فرآیند اجرای یک برنامه شامل چند مرحله است که در نهایت منجر به تولید یک فایل اجرایی می‌شود که می‌تواند روی سیستم اجرا شود. این فرآیند به شکل زیر انجام می‌شود:

1. **نوشتن کد منبع (Source Code)**:
   ابتدا برنامه‌نویس کد برنامه را به زبان C++ می‌نویسد. این کد به صورت فایل‌های متنی ذخیره می‌شود که به آن‌ها **فایل‌های منبع** یا **source files** گفته می‌شود. معمولاً فایل‌های C++ دارای پسوند `.cpp` یا `.h` هستند. 

2. **کامپایلر (Compiler)**:
   کامپایلر وظیفه دارد که کد منبع را به زبان ماشین ترجمه کند. زبان ماشین کدی است که مستقیماً توسط پردازنده سیستم قابل درک و اجرا است. هر کامپایلر برای معماری‌های سخت‌افزاری خاص و سیستم‌عامل‌های خاص طراحی می‌شود.

   فرآیند کامپایل به دو مرحله اصلی تقسیم می‌شود:
   - **تجزیه و تحلیل (Parsing)**: کامپایلر ابتدا کد منبع را تجزیه می‌کند و بررسی می‌کند که آیا قواعد نحوی (syntax) زبان C++ رعایت شده است یا خیر. همچنین، کامپایلر بررسی می‌کند که آیا انواع داده‌ها و ساختارهای تعریف شده در برنامه صحیح هستند یا خیر (چک کردن نوع، نوع ایستا).
   - **تولید کد (Code Generation)**: پس از تجزیه موفق، کامپایلر کد زبان ماشین را تولید می‌کند و آن را به عنوان فایل‌های **شیء** یا **object files** ذخیره می‌کند. فایل‌های شیء حاوی کدهای باینری هستند که فقط بخشی از برنامه را تشکیل می‌دهند و برای اجرا کامل نیاز به لینک شدن دارند.

3. **لینک‌کننده (Linker)**:
   در مرحله لینک کردن، **لینک‌کننده** فایل‌های شیء (object files) را با هم ترکیب می‌کند تا یک برنامه کامل و اجرایی ایجاد شود. لینک‌کننده وظیفه دارد که تمام توابع و متغیرهای تعریف‌شده در فایل‌های مختلف را به یکدیگر مرتبط کند. به‌عنوان مثال، ممکن است شما در یک فایل منبع یک تابع تعریف کرده باشید و در فایل دیگری آن را فراخوانی کنید. لینک‌کننده اطمینان می‌دهد که این ارتباطات به درستی برقرار می‌شوند.

   علاوه بر این، لینک‌کننده کتابخانه‌های خارجی (مثل کتابخانه استاندارد C++) را نیز به برنامه متصل می‌کند تا بتوان از امکانات آن‌ها استفاده کرد. پس از اتمام لینک کردن، نتیجه یک فایل **اجرایی (executable)** است که می‌تواند توسط سیستم‌عامل و سخت‌افزار مربوطه اجرا شود.

4. **فایل اجرایی (Executable)**:
   این فایل نهایی، همان برنامه‌ای است که روی یک سیستم خاص قابل اجراست. این برنامه برای ترکیب خاصی از سخت‌افزار و سیستم‌عامل ساخته شده و به‌طور مستقیم نمی‌تواند روی سیستم‌های متفاوتی اجرا شود. به عنوان مثال، یک فایل اجرایی که روی سیستم عامل ویندوز تولید شده، روی مک به‌صورت مستقیم اجرا نمی‌شود.

### قابلیت حمل (Portability)
وقتی از قابلیت حمل در C++ صحبت می‌کنیم، منظور **قابلیت حمل کد منبع** است، نه فایل اجرایی. به این معنا که کد منبعی که شما نوشته‌اید، باید بتواند روی سیستم‌های مختلف (مثل ویندوز، مک، لینوکس) کامپایل و اجرا شود. اما فایل اجرایی تولیدشده توسط کامپایلر معمولاً فقط روی همان سیستم و سخت‌افزاری که برای آن کامپایل شده است، قابل اجراست. بنابراین، برای اجرای برنامه روی سیستم‌های مختلف، باید کد منبع مجدداً روی آن سیستم کامپایل شود. 

در نتیجه:
- **کامپایلر** کد منبع را به کد ماشین ترجمه می‌کند.
- **لینک‌کننده** فایل‌های شیء و کتابخانه‌ها را ترکیب می‌کند تا یک فایل اجرایی ایجاد شود.
- فایل اجرایی تنها برای سیستم خاصی که برای آن کامپایل شده قابل اجراست، اما کد منبع می‌تواند روی سیستم‌های مختلف کامپایل و اجرا شود.


---




---

برای اینکه فرآیند کامپایل، لینک و ایجاد برنامه اجرایی در C++ را بهتر درک کنیم، بیایید آن را با دقت بیشتری همراه با مثال توضیح دهیم.

### 1. نوشتن کد منبع (Source Code)

فرض کنید شما می‌خواهید یک برنامه ساده بنویسید که دو عدد را جمع بزند. برای این کار ابتدا باید کد منبع برنامه را بنویسید. این کد به زبان C++ نوشته می‌شود و در یک فایل متنی با پسوند `.cpp` ذخیره می‌شود. به‌عنوان مثال:

**File: `main.cpp`**
```cpp
#include <iostream>  // این خط کتابخانه iostream را برای استفاده از ورودی و خروجی وارد می‌کند

int add(int a, int b) {
    return a + b;   // تابعی که دو عدد را می‌گیرد و آن‌ها را جمع می‌زند
}

int main() {
    int x = 5;    // عدد اول
    int y = 10;   // عدد دوم
    std::cout << "Sum: " << add(x, y) << std::endl;  // چاپ نتیجه جمع دو عدد
    return 0;
}
```

### 2. کامپایلر (Compiler)

پس از نوشتن کد، باید آن را کامپایل کنید. **کامپایلر** وظیفه دارد که کد C++ را به **کد ماشین** (که پردازنده سیستم می‌تواند آن را بفهمد) تبدیل کند.

#### مراحل کامپایل:
- **تجزیه و تحلیل نحوی (Parsing)**: کامپایلر ابتدا کد را بررسی می‌کند که آیا همه چیز مطابق با قوانین نحو (syntax) C++ است یا خیر. مثلاً بررسی می‌کند که `int` به درستی برای نوع داده استفاده شده و اینکه تابع `add` به درستی تعریف شده است.
- **تجزیه و تحلیل نوع (Type Checking)**: سپس کامپایلر مطمئن می‌شود که انواع داده‌ها (مثل `int`) به درستی استفاده شده‌اند. اگر مثلاً به جای عدد صحیح، یک رشته به تابع `add` ارسال شود، کامپایلر خطا خواهد داد.
- **تولید کد (Code Generation)**: در این مرحله، کامپایلر کد ماشین را تولید می‌کند. این کد مستقیماً توسط پردازنده قابل اجرا است.

نتیجه کامپایل، تولید فایل‌های شیء (object files) است. فایل‌های شیء فایل‌هایی هستند که شامل کد باینری قابل اجرا هستند، اما به صورت کامل لینک نشده‌اند. برای مثال، خروجی کامپایلر برای فایل `main.cpp` می‌تواند `main.o` باشد.

### 3. لینک‌کننده (Linker)

پس از اینکه فایل‌های شیء توسط کامپایلر تولید شدند، این فایل‌ها هنوز آماده اجرا نیستند. اینجاست که **لینک‌کننده (linker)** وارد عمل می‌شود.

#### وظایف لینک‌کننده:
- **لینک کردن توابع و متغیرها**: در فایل‌های منبع مختلف، ممکن است توابع و متغیرهایی تعریف شده باشند که در فایل‌های دیگر مورد استفاده قرار می‌گیرند. لینک‌کننده وظیفه دارد که این موارد را به هم مرتبط کند. به‌عنوان مثال، در کد بالا، تابع `add` در جایی جدا تعریف شده و در تابع `main` استفاده شده است. لینک‌کننده باید این دو را به هم وصل کند.
- **اتصال به کتابخانه‌ها (Libraries)**: علاوه بر فایل‌های شیء برنامه شما، لینک‌کننده همچنین کتابخانه‌های خارجی مثل کتابخانه استاندارد C++ (که شامل توابعی مثل `std::cout` و `std::endl` است) را به برنامه متصل می‌کند. برای مثال، `iostream` کتابخانه‌ای است که به شما اجازه می‌دهد از ورودی و خروجی استفاده کنید، و این کتابخانه باید توسط لینک‌کننده به برنامه شما متصل شود.

نتیجه لینک کردن یک فایل اجرایی (Executable) است که می‌تواند مستقیماً توسط سیستم‌عامل اجرا شود. در این مثال، فایل اجرایی ممکن است `main.exe` در ویندوز یا `a.out` در لینوکس نامیده شود.

### 4. فایل اجرایی (Executable)

فایل اجرایی نهایی شامل تمام کدهای باینری است که پردازنده سیستم می‌تواند آن را مستقیماً اجرا کند. شما می‌توانید این فایل اجرایی را در خط فرمان یا با دوبار کلیک کردن روی آن اجرا کنید. مثلاً در لینوکس:

```
./a.out
```

خروجی:
```
Sum: 15
```

### مثال جامع‌تر: برنامه چند فایل

حالا فرض کنید برنامه شما بزرگ‌تر باشد و از چندین فایل منبع استفاده کند. برای مثال:

**File: `math.cpp`**
```cpp
int add(int a, int b) {
    return a + b;
}
```

**File: `main.cpp`**
```cpp
#include <iostream>
int add(int, int);  // اعلام تابع add

int main() {
    int x = 5;
    int y = 10;
    std::cout << "Sum: " << add(x, y) << std::endl;
    return 0;
}
```

در اینجا، تابع `add` در فایل `math.cpp` تعریف شده و در `main.cpp` استفاده می‌شود. هر دو فایل باید کامپایل شوند، سپس لینک‌کننده آن‌ها را به هم متصل می‌کند.

#### کامپایل جداگانه:
```
g++ -c main.cpp -o main.o
g++ -c math.cpp -o math.o
```

#### لینک کردن:
```
g++ main.o math.o -o myprogram
```

خروجی:
```
./myprogram
Sum: 15
```

### توضیح مراحل:
1. **کامپایلر** هر فایل را جداگانه کامپایل می‌کند و فایل‌های شیء (مثل `main.o` و `math.o`) تولید می‌کند.
2. **لینک‌کننده** فایل‌های شیء را ترکیب کرده و یک فایل اجرایی نهایی به نام `myprogram` ایجاد می‌کند.

### نکته درباره **قابلیت حمل (Portability)**:
فایل اجرایی (`myprogram`) که روی سیستم‌عامل خاصی مثل لینوکس ساخته شده، نمی‌تواند به‌طور مستقیم روی سیستم‌عاملی دیگر مثل ویندوز اجرا شود. برای اجرای برنامه روی ویندوز، باید کد منبع (`main.cpp` و `math.cpp`) را روی آن سیستم کامپایل و لینک کنید.

اما **کد منبع** معمولاً قابل حمل است؛ یعنی اگر از ویژگی‌های مستقل از سیستم‌عامل استفاده کرده باشید، می‌توانید همین کد منبع را روی سیستم‌های مختلف (مثل ویندوز، مک، یا لینوکس) کامپایل کنید و برنامه اجرایی مخصوص آن سیستم تولید شود.

---

## Hello, World!
کوچکترین برنامه C++ به صورت زیر است:

```cpp
int main() { } // the minimal C++ program
```

این یک تابع به نام `main` تعریف می‌کند که هیچ آرگومانی نمی‌گیرد و هیچ کاری انجام نمی‌دهد. آکولادها `{ }` در C++ برای گروه‌بندی استفاده می‌شوند. در اینجا، آن‌ها شروع و پایان بدنه تابع را نشان می‌دهند. دو اسلش `//` یک کامنت را آغاز می‌کند که تا پایان خط ادامه دارد. کامنت برای خواننده انسان است؛ کامپایلر کامنت‌ها را نادیده می‌گیرد.

هر برنامه C++ باید دقیقاً یک تابع سراسری به نام `main()` داشته باشد. برنامه با اجرای این تابع شروع می‌شود. مقدار `int` که توسط تابع `main()` برگردانده می‌شود (در صورت وجود) مقدار بازگشتی برنامه به «سیستم» است. اگر هیچ مقداری برگردانده نشود، سیستم مقداری که نشان‌دهنده موفقیت‌آمیز بودن اجرای برنامه است را دریافت می‌کند. یک مقدار غیر صفر از `main()` نشان‌دهنده شکست است. هر سیستم‌عامل یا محیط اجرایی لزوماً از مقدار بازگشتی استفاده نمی‌کند: محیط‌های مبتنی بر لینوکس/یونیکس اغلب این کار را می‌کنند، اما محیط‌های مبتنی بر ویندوز به‌ندرت این کار را انجام می‌دهند.

معمولاً یک برنامه مقداری خروجی تولید می‌کند. در اینجا یک برنامه ساده که عبارت "Hello, World!" را می‌نویسد:

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, World!\n";  
}
```

این برنامه از کتابخانه استاندارد `iostream` استفاده می‌کند تا عبارت "Hello, World!" را به خروجی (معمولاً کنسول) بنویسد.

خط `#include <iostream>` به کامپایلر دستور می‌دهد تا اعلان‌های مربوط به امکانات ورودی/خروجی استاندارد (stream I/O) که در فایل هدر **iostream** تعریف شده‌اند را وارد کند. بدون این اعلان‌ها، عبارت زیر معنایی نداشت:

```cpp
std::cout << "Hello, World!\n";
```

اپراتور `<<` (به معنی "put to") آرگومان دوم خود را به آرگومان اول منتقل می‌کند. در اینجا، رشته‌ی "Hello, World!\n" به جریان خروجی استاندارد **std::cout** منتقل می‌شود. یک **رشته‌ی متنی (string literal)** دنباله‌ای از کاراکترهاست که با علامت‌های نقل‌قول دوگانه محصور شده است. درون یک رشته‌ی متنی، کاراکتر بک‌اسلش `\` به همراه کاراکتر دیگری یک **کاراکتر خاص** را نشان می‌دهد. در این مثال، `\n` به معنی کاراکتر **newline** (خط جدید) است، بنابراین کاراکترهایی که نوشته می‌شوند، عبارت **Hello, World!** به‌همراه یک خط جدید هستند.

عبارت `std::` مشخص می‌کند که نام **cout** در فضای نام (namespace) استاندارد (std) قرار دارد. به طور معمول، وقتی درباره ویژگی‌های استاندارد صحبت می‌کنم، از `std::` استفاده نمی‌کنم. در بخش `§2.4.2` توضیح داده شده که چگونه می‌توان نام‌ها را از یک فضای نام قابل مشاهده کرد بدون نیاز به استفاده از `std::` در هر بار.

تقریباً همه‌ی کدهای اجرایی در توابع قرار می‌گیرند و مستقیماً یا غیرمستقیم از تابع **main()** فراخوانی می‌شوند. برای مثال:

```cpp
#include <iostream>
using namespace std; // نام‌های موجود در فضای نام std بدون نیاز به std:: قابل استفاده می‌شوند

double square(double x) // محاسبه‌ی مربع یک عدد اعشاری با دقت دوگانه (double)
{
    return x * x;
}

void print_square(double x) // تابعی برای چاپ نتیجه‌ی محاسبه‌ی مربع
{
    cout << "the square of " << x << " is " << square(x) << "\n";
}

int main()
{
    print_square(1.234); // خروجی: the square of 1.234 is 1.52276
}
```

در این مثال، **void** به‌عنوان **نوع بازگشتی (return type)** به این معنی است که تابع هیچ مقداری را بازنمی‌گرداند. برای مثال، تابع `print_square` هیچ مقداری برنمی‌گرداند، اما خروجی مورد نظر را به کنسول چاپ می‌کند.

## Types, Variables, and Arithmetic
در زبان C++، هر نام و هر عبارت دارای یک **نوع (type)** است که تعیین می‌کند چه عملیات‌هایی می‌توان روی آن انجام داد. به عنوان مثال، اعلان زیر را در نظر بگیرید:

```cpp
int inch;
```

این خط مشخص می‌کند که متغیر `inch` از نوع `int` است؛ یعنی `inch` یک متغیر صحیح (integer) است.

### تعریف‌ها:
- **اعلان (Declaration)**: عبارتی که یک نام جدید را وارد برنامه می‌کند و نوع آن را مشخص می‌کند.
- **نوع (Type)**: مجموعه‌ای از مقادیر ممکن و مجموعه‌ای از عملیات‌های ممکن که روی یک شیء قابل انجام است.
- **شیء (Object)**: مقداری از حافظه که دارای یک مقدار از یک نوع خاص است.
- **مقدار (Value)**: مجموعه‌ای از بیت‌ها که بر اساس نوع مشخصی تفسیر می‌شوند.
- **متغیر (Variable)**: شیء‌ای است که دارای یک نام است.

C++ انواع پایه‌ای متعددی را ارائه می‌دهد. هر نوع پایه‌ای به طور مستقیم با امکانات سخت‌افزاری مطابقت دارد و اندازه ثابتی دارد که محدوده مقادیری که می‌توانند در آن ذخیره شوند را تعیین می‌کند.

### انواع پایه‌ای رایج:
- **`bool`**: نوع بولین، مقادیر ممکن آن `true` و `false` است.
- **`char`**: نوع کاراکتر، مقادیر ممکن شامل کاراکترهایی مانند `'a'`، `'z'` و `'9'` است.
- **`int`**: نوع عدد صحیح، مقادیر ممکن شامل اعدادی مانند `1`، `42` و `1066` است.
- **`double`**: نوع عدد اعشاری با دقت دوگانه، مقادیر ممکن شامل اعدادی مانند `3.14` و `299793.0` است.

### نوع‌ها و اندازه‌ها:

هر یک از این نوع‌ها اندازه‌ی مشخصی دارند که محدوده مقادیری که می‌توانند در آن‌ها ذخیره شوند را تعیین می‌کند. اندازه هر نوع توسط سخت‌افزار یا استاندارد زبان C++ تعریف شده و ممکن است در سیستم‌های مختلف متفاوت باشد. به عنوان مثال، یک متغیر `int` معمولاً ۴ بایت فضا اشغال می‌کند و قادر است مقادیر عدد صحیح بین حدود `-2,147,483,648` تا `2,147,483,647` را نگه دارد.

مثال‌های استفاده از این نوع‌ها:

```cpp
bool is_raining = true;     // متغیر بولین
char letter = 'A';          // متغیر کاراکتر
int age = 25;               // متغیر عدد صحیح
double pi = 3.14159;        // متغیر عدد اعشاری با دقت دوگانه
```

هر نوع دارای یک سری عملیات و مقادیر ممکن است که بر اساس آن نوع تعریف شده‌اند. به عنوان مثال، می‌توان عملیات‌های منطقی مانند AND و OR را روی نوع `bool` اعمال کرد، یا عملیات‌های جمع و ضرب را روی نوع‌های `int` و `double` انجام داد.

![](./image/2/2.2.png)

یک متغیر از نوع `char` به اندازه‌ی طبیعی برای نگهداری یک کاراکتر در یک ماشین خاص است (معمولاً یک بایت 8-بیتی)، و اندازه‌ی سایر نوع‌ها به صورت مضربی از اندازه‌ی `char` بیان می‌شود. اندازه‌ی یک نوع توسط پیاده‌سازی مشخص می‌شود (یعنی می‌تواند در ماشین‌های مختلف متفاوت باشد) و می‌توان آن را با استفاده از عملگر `sizeof` به دست آورد؛ به عنوان مثال، `sizeof(char)` برابر با ۱ است و `sizeof(int)` معمولاً ۴ است.

در C++، می‌توان از عملگرهای مختلفی برای انجام عملیات‌های ریاضی و مقایسه‌ای استفاده کرد:

### عملگرهای ریاضی:
- `x + y` // جمع
- `+x` // علامت مثبت (عملگر یک‌دانه‌ای برای مثبت کردن)
- `x - y` // تفریق
- `-x` // علامت منفی (عملگر یک‌دانه‌ای برای منفی کردن)
- `x * y` // ضرب
- `x / y` // تقسیم
- `x % y` // باقیمانده (برای اعداد صحیح، عملگر مدولوس)

### عملگرهای مقایسه‌ای:
- `x == y` // برابر
- `x != y` // نابرابر
- `x < y` // کوچکتر از
- `x > y` // بزرگتر از
- `x <= y` // کوچکتر یا مساوی
- `x >= y` // بزرگتر یا مساوی

در عملیات‌های محاسباتی و انتساب، C++ تمامی تبدیل‌های معنادار بین انواع پایه‌ای را انجام می‌دهد تا بتوان آن‌ها را به‌صورت ترکیبی استفاده کرد. برای مثال:

```cpp
void some_function() // تابعی که مقداری برنمی‌گرداند
{
    double d = 2.2; // مقداردهی اولیه به یک عدد اعشاری
    int i = 7; // مقداردهی اولیه به یک عدد صحیح
    d = d + i; // جمع و انتساب نتیجه به d
    i = d * i; // ضرب و انتساب نتیجه به i (مقدار اعشاری d*i به یک عدد صحیح تبدیل و مقادیر اضافی حذف می‌شود)
}
```

دقت کنید که `=` عملگر **انتساب** است، در حالی که `==` برای **برابری** استفاده می‌شود.

C++ چندین روش برای مقداردهی اولیه ارائه می‌دهد، مانند استفاده از `=` در مثال بالا، یا استفاده از **لیست‌های مقداردهی محصور در آکولاد** به‌صورت زیر:

```cpp
double d1 = 2.3; 
double d2 {2.3}; // استفاده از {} برای مقداردهی اولیه
complex<double> z = 1; // عدد مختلط با مقادیر اعشاری
complex<double> z2 {d1, d2}; // عدد مختلط با دو عدد اعشاری
complex<double> z3 = {1, 2}; // علامت = اختیاری است وقتی از {} استفاده می‌کنیم
vector<int> v {1, 2, 3, 4, 5, 6}; // برداری از اعداد صحیح
```

استفاده از فرم `=` سنتی است و به زبان C برمی‌گردد، اما اگر شک دارید، بهتر است از فرم کلی `{}` استفاده کنید. این روش شما را از تبدیل‌های نادرست که منجر به از دست دادن اطلاعات می‌شوند، محافظت می‌کند. برای مثال:

```cpp
int i1 = 7.2; // i1 تبدیل به 7 می‌شود (اطلاعات اعشاری حذف می‌شود)
int i2 {7.2}; // خطا: تبدیل اعشاری به عدد صحیح مجاز نیست
int i3 = {7.2}; // خطا: تبدیل اعشاری به عدد صحیح (علامت = اضافی است)
```

یک **ثابت** نمی‌تواند بدون مقداردهی اولیه باشد، و یک **متغیر** فقط در شرایط بسیار خاص باید بدون مقداردهی اولیه رها شود. تا زمانی که یک مقدار مناسب ندارید، نامی را معرفی نکنید. انواع تعریف‌شده توسط کاربر (مانند `string`، `vector`، `Matrix`، `Motor_controller` و `Orc_warrior`) می‌توانند به‌طور ضمنی مقداردهی اولیه شوند.

هنگام تعریف یک متغیر، نیازی نیست که نوع آن را به‌طور صریح بیان کنید، زمانی که می‌توان آن را از مقداردهی اولیه استنباط کرد. برای مثال:

```cpp
auto b = true;    // یک متغیر از نوع bool
auto ch = 'x';    // یک متغیر از نوع char
auto i = 123;     // یک متغیر از نوع int
auto d = 1.2;     // یک متغیر از نوع double
auto z = sqrt(y); // نوع z همان نوع خروجی تابع sqrt(y) است
```

هنگام استفاده از `auto`، از سینتکس `=` استفاده می‌کنیم چون هیچ تبدیل نوعی که باعث مشکلات شود، دخیل نیست.

از `auto` در جایی استفاده می‌کنیم که دلیل خاصی برای ذکر صریح نوع نداشته باشیم. برخی از این دلایل خاص عبارتند از:
- تعریف در یک محدوده بزرگ که می‌خواهیم نوع متغیر برای خوانندگان کد به‌وضوح مشخص باشد.
- می‌خواهیم در مورد دقت یا محدوده متغیر به‌طور صریح صحبت کنیم (مانند استفاده از `double` به جای `float`).

با استفاده از `auto`، از تکرار غیرضروری و نوشتن نام‌های طولانی نوع جلوگیری می‌کنیم. این موضوع در برنامه‌نویسی جنریک (generic programming) که نوع دقیق یک شیء ممکن است برای برنامه‌نویس به‌سختی مشخص باشد، اهمیت بیشتری دارد، به‌خصوص وقتی نام‌های نوع می‌توانند بسیار طولانی باشند.

### عملگرهای ترکیبی برای تغییر متغیر:
علاوه بر عملگرهای محاسباتی و منطقی معمول، C++ عملگرهای خاص‌تری برای تغییر مقادیر متغیرها ارائه می‌دهد:

- `x += y` // معادل `x = x + y`
- `++x` // افزایش مقدار: `x = x + 1`
- `x -= y` // معادل `x = x - y`
- `--x` // کاهش مقدار: `x = x - 1`
- `x *= y` // مقیاس‌بندی: `x = x * y`
- `x /= y` // مقیاس‌بندی: `x = x / y`
- `x %= y` // معادل `x = x % y`

این عملگرها مختصر، کاربردی و بسیار رایج هستند.

---

در C++، دو روش برای مقداردهی اولیه متغیرها وجود دارد که هر دو در مثال‌های زیر نشان داده شده‌اند:

```cpp
double d1 = 2.3; // مقداردهی اولیه به سبک سنتی با استفاده از علامت =
double d2 {2.3}; // مقداردهی اولیه به سبک لیست با استفاده از {}
```

### تفاوت‌های اصلی بین این دو روش:

1. **مقداردهی سنتی (`=`)**:
   - در این روش از علامت `=` برای مقداردهی اولیه استفاده می‌شود. این روش سنتی است و از زبان C به ارث رسیده است.
   - در اینجا مقدار به متغیر اختصاص داده می‌شود، و اگر نوع مقدار با نوع متغیر سازگار نباشد، ممکن است تبدیل ضمنی انجام شود. به‌عنوان مثال، اگر مقدار `2.3` را به یک متغیر صحیح (`int`) اختصاص دهید، بدون خطا فقط قسمت صحیح عدد در نظر گرفته می‌شود.

   مثال:
   ```cpp
   int i = 7.8;  // i مقدار 7 را می‌گیرد (قسمت اعشاری حذف می‌شود)
   ```

2. **مقداردهی به سبک لیست (`{}`)**:
   - این روش در C++11 معرفی شده است و از آکولاد (`{}`) برای مقداردهی اولیه استفاده می‌کند.
   - این روش امن‌تر است، زیرا از تبدیل‌های ناخواسته و غیرقابل کنترل جلوگیری می‌کند. به این معنا که اگر نوع مقدار با نوع متغیر کاملاً سازگار نباشد، کامپایلر خطا می‌دهد. برای مثال، اگر سعی کنید یک مقدار اعشاری را به یک متغیر صحیح اختصاص دهید، کامپایلر خطا خواهد داد.

   مثال:
   ```cpp
   int i {7.8};  // خطا: تبدیل اعشاری به صحیح مجاز نیست
   ```

### جمع‌بندی:
- `=` برای مقداردهی اولیه به سبک سنتی استفاده می‌شود و در برخی موارد ممکن است باعث تبدیل‌های ضمنی شود که می‌تواند به از دست رفتن دقت منجر شود.
- `{}` برای مقداردهی اولیه به سبک لیست استفاده می‌شود که امن‌تر است و از تبدیل‌های غیرمجاز جلوگیری می‌کند، بنابراین استفاده از آن در شرایطی که می‌خواهید مطمئن شوید خطاهای تبدیل رخ نمی‌دهد، توصیه می‌شود.

---

---
دستور زیر:

```cpp
complex<double> z = 1;
```

یک شیء از نوع `complex<double>` تعریف می‌کند و مقداردهی اولیه‌ای برای آن انجام می‌دهد. این نوع به معنای عدد مختلط با قسمت‌های حقیقی و موهومی از نوع `double` است. اما چیزی که در اینجا خاص است، مقداردهی اولیه با عدد صحیح `1` است.

### تجزیه و تحلیل:

1. **نوع `complex<double>`:**
   - این نوع داده متعلق به کتابخانه استاندارد C++ است و برای نشان دادن اعداد مختلط استفاده می‌شود. 
   - `complex<double>` یک عدد مختلط است که قسمت حقیقی و موهومی آن از نوع `double` هستند.

2. **مقداردهی اولیه با `1`:**
   - مقدار `1` به عنوان عدد حقیقی در نظر گرفته می‌شود.
   - در اینجا، کامپایلر مقدار `1` را به عنوان قسمت حقیقی عدد مختلط تفسیر می‌کند و قسمت موهومی را به صورت پیش‌فرض برابر با `0` در نظر می‌گیرد.
   - بنابراین، `z` برابر با عدد مختلطی خواهد بود که قسمت حقیقی آن `1.0` و قسمت موهومی آن `0.0` است.

   به صورت صریح می‌توانیم این عدد را به صورت `complex<double> z(1.0, 0.0);` نیز تعریف کنیم که معنای مشابهی دارد.

### نتیجه نهایی:
این دستور `complex<double> z = 1;` باعث می‌شود که شیء `z` برابر با عدد مختلطی باشد که دارای قسمت حقیقی `1.0` و قسمت موهومی `0.0` است.

### مثال تکمیلی:
اگر مقداردهی به صورت زیر انجام شود:

```cpp
complex<double> z2(2.0, 3.0);  // عدد مختلطی با قسمت حقیقی 2.0 و قسمت موهومی 3.0
```

در این حالت، `z2` یک عدد مختلط خواهد بود که هم قسمت حقیقی و هم قسمت موهومی به وضوح مشخص شده‌اند.

---

