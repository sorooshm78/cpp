## Introduction
هدف این فصل و سه فصل بعدی، این است که به شما ایده‌ای درباره‌ی C++ بدهد، بدون اینکه وارد جزئیات زیادی شود. این فصل به طور غیررسمی به ارائه‌ی نمادگذاری C++، مدل حافظه و محاسبات در C++ و مکانیزم‌های پایه‌ای برای سازمان‌دهی کد به یک برنامه می‌پردازد. اینها امکانات زبان هستند که از سبک‌هایی که اغلب در C دیده می‌شود و گاهی به آن‌ها برنامه‌نویسی رویه‌ای گفته می‌شود، پشتیبانی می‌کنند. فصل 3 با ارائه مکانیزم‌های انتزاعی C++ ادامه می‌یابد. فصل 4 و فصل 5 نیز مثال‌هایی از امکانات کتابخانه استاندارد ارائه می‌دهند.

---

در **Procedural programming** (برنامه‌نویسی رویه‌ای) یک سبک یا پارادایم برنامه‌نویسی است که در آن برنامه‌ها به عنوان مجموعه‌ای از توابع یا رویه‌ها تعریف می‌شوند. این رویکرد به جای تمرکز بر اشیا و داده‌ها، بر روی ترتیب اجرای دستورات و توابع تأکید دارد. در این سبک، برنامه‌نویس عملیات مورد نیاز برای حل یک مسئله را به بخش‌های کوچک‌تر (رویه‌ها یا توابع) تقسیم می‌کند که هر کدام کار خاصی را انجام می‌دهند.

ویژگی‌های اصلی برنامه‌نویسی رویه‌ای عبارتند از:

1. **توابع (Procedures/Functions)**: کد به صورت توابع یا زیرروال‌ها سازمان‌دهی می‌شود که هر کدام وظیفه خاصی را انجام می‌دهند. این توابع می‌توانند بارها و بارها در قسمت‌های مختلف برنامه فراخوانی شوند.
  
2. **ساختار کنترل**: برای کنترل جریان برنامه از ساختارهای کنترلی مانند حلقه‌ها (loops) و شرط‌ها (if/else) استفاده می‌شود.
  
3. **متغیرها و داده‌های سراسری**: متغیرها می‌توانند به صورت سراسری (global) یا محلی (local) تعریف شوند و در سراسر برنامه یا فقط در یک تابع خاص قابل دسترسی باشند.

4. **الگوریتم‌محور**: برنامه‌نویسی رویه‌ای بیشتر بر طراحی الگوریتم‌ها برای انجام کارها و ترتیب اجرای دستورات تمرکز دارد.

زبان‌هایی مثل C و پاسکال نمونه‌های بارزی از زبان‌های برنامه‌نویسی رویه‌ای هستند. در C++، با وجود اینکه این زبان از شی‌گرایی پشتیبانی می‌کند، هنوز هم می‌توان از این سبک برنامه‌نویسی استفاده کرد، همان‌طور که در زبان C انجام می‌شود.

---

این مرور سریع از C++ ما را از یک ارائه کاملاً «پایین به بالا» از امکانات زبان و کتابخانه نجات می‌دهد، با این امکان که حتی در فصل‌های اولیه هم از مجموعه‌ای غنی از امکانات استفاده کنیم. به عنوان مثال، حلقه‌ها تا فصل ۱۰ به‌طور مفصل بحث نمی‌شوند، اما خیلی زودتر از آن به شکل‌های آشکاری مورد استفاده قرار خواهند گرفت. به همین ترتیب، توضیحات جزئی درباره کلاس‌ها، الگوها (templates)، استفاده از حافظه پویا (free-store)، و کتابخانه استاندارد در طول فصل‌های زیادی پخش شده است، اما از انواع کتابخانه استاندارد مانند **vector**، **string**، **complex**، **map**، **unique_ptr**، و **ostream** در هر جا که لازم باشد، برای بهبود مثال‌های کد استفاده خواهد شد.

به‌عنوان یک قیاس، این مرور سریع را می‌توانید به یک تور دیدنی کوتاه از یک شهر، مانند کپنهاگ یا نیویورک، تشبیه کنید. در عرض چند ساعت، یک نگاه سریع به جاذبه‌های اصلی دارید، چند داستان پس‌زمینه شنیده‌اید و معمولاً چند پیشنهاد برای دیدن چیزهای دیگر دریافت می‌کنید. پس از چنین توری، شما شهر را به‌طور کامل نمی‌شناسید و همه آنچه دیده‌اید و شنیده‌اید را درک نمی‌کنید. برای شناخت واقعی یک شهر، باید سال‌ها در آن زندگی کنید. اما با کمی شانس، یک نمای کلی از شهر، ایده‌ای از ویژگی‌های خاص آن و چیزهایی که ممکن است برایتان جالب باشد به دست آورده‌اید. پس از این تور، اکتشاف واقعی می‌تواند آغاز شود.

این مرور، C++ را به‌عنوان یک کل یکپارچه ارائه می‌دهد، نه به‌عنوان یک «کیک چندلایه». به همین دلیل، ویژگی‌های زبان به‌عنوان ویژگی‌هایی که در C وجود داشته، بخشی از C++98 هستند یا در C++11 جدید هستند، مشخص نمی‌شوند. این اطلاعات تاریخی را می‌توانید در بخش ۱.۴ و فصل ۴۴ پیدا کنید.

## The Basics
زبان C++ یک زبان **کامپایل‌شونده** است. برای اجرای یک برنامه، کد منبع آن باید توسط کامپایلر پردازش شود که منجر به تولید فایل‌های شیء (object files) می‌شود. این فایل‌ها سپس توسط یک لینک‌کننده (linker) با هم ترکیب شده و یک برنامه اجرایی (executable) تولید می‌کنند. معمولاً یک برنامه C++ شامل بسیاری از فایل‌های کد منبع (که معمولاً به سادگی فایل‌های منبع نامیده می‌شوند) است.

![](./image/2/2.1.png)

یک برنامه اجرایی برای یک ترکیب خاص از سخت‌افزار/سیستم ساخته می‌شود؛ بنابراین، به‌طور مستقیم قابل انتقال از یک سیستم به سیستم دیگر، مثلاً از مک به ویندوز، نیست. هنگامی که درباره **قابلیت حمل (portability)** برنامه‌های C++ صحبت می‌کنیم، معمولاً منظور ما قابلیت حمل کد منبع است؛ یعنی کد منبع می‌تواند به‌طور موفقیت‌آمیز روی سیستم‌های مختلف کامپایل و اجرا شود.

استاندارد ISO C++ دو نوع موجودیت را تعریف می‌کند:
- **ویژگی‌های اصلی زبان**: مانند انواع داخلی (مثل `char` و `int`) و حلقه‌ها (مثل دستورات `for` و `while`).
- **اجزای کتابخانه استاندارد**: مانند **container**‌ها (مانند `vector` و `map`) و عملیات ورودی/خروجی (مثل `<<` و `getline()`).

اجزای کتابخانه استاندارد، کدهای عادی C++ هستند که توسط هر پیاده‌سازی C++ ارائه می‌شوند. به عبارت دیگر، کتابخانه استاندارد C++ می‌تواند در خود C++ پیاده‌سازی شود (و این کار انجام می‌شود، به جز استفاده‌های بسیار جزئی از کد ماشین برای چیزهایی مانند تعویض زمینه‌ی (context switching) رشته‌ها). این بدان معناست که C++ به اندازه کافی **بیان‌پذیر** و **کارآمد** برای انجام سخت‌ترین وظایف برنامه‌نویسی سیستم است.

زبان C++ یک زبان **با نوع ایستا** (statically typed) است. یعنی نوع هر موجودیت (مانند شیء، مقدار، نام و عبارت) باید در زمان استفاده از آن توسط کامپایلر مشخص باشد. نوع یک شیء تعیین می‌کند که چه مجموعه‌ای از عملیات روی آن قابل اجرا است.

---

در یک زبان **کامپایل‌شونده** مثل C++، فرآیند اجرای یک برنامه شامل چند مرحله است که در نهایت منجر به تولید یک فایل اجرایی می‌شود که می‌تواند روی سیستم اجرا شود. این فرآیند به شکل زیر انجام می‌شود:

1. **نوشتن کد منبع (Source Code)**:
   ابتدا برنامه‌نویس کد برنامه را به زبان C++ می‌نویسد. این کد به صورت فایل‌های متنی ذخیره می‌شود که به آن‌ها **فایل‌های منبع** یا **source files** گفته می‌شود. معمولاً فایل‌های C++ دارای پسوند `.cpp` یا `.h` هستند. 

2. **کامپایلر (Compiler)**:
   کامپایلر وظیفه دارد که کد منبع را به زبان ماشین ترجمه کند. زبان ماشین کدی است که مستقیماً توسط پردازنده سیستم قابل درک و اجرا است. هر کامپایلر برای معماری‌های سخت‌افزاری خاص و سیستم‌عامل‌های خاص طراحی می‌شود.

   فرآیند کامپایل به دو مرحله اصلی تقسیم می‌شود:
   - **تجزیه و تحلیل (Parsing)**: کامپایلر ابتدا کد منبع را تجزیه می‌کند و بررسی می‌کند که آیا قواعد نحوی (syntax) زبان C++ رعایت شده است یا خیر. همچنین، کامپایلر بررسی می‌کند که آیا انواع داده‌ها و ساختارهای تعریف شده در برنامه صحیح هستند یا خیر (چک کردن نوع، نوع ایستا).
   - **تولید کد (Code Generation)**: پس از تجزیه موفق، کامپایلر کد زبان ماشین را تولید می‌کند و آن را به عنوان فایل‌های **شیء** یا **object files** ذخیره می‌کند. فایل‌های شیء حاوی کدهای باینری هستند که فقط بخشی از برنامه را تشکیل می‌دهند و برای اجرا کامل نیاز به لینک شدن دارند.

3. **لینک‌کننده (Linker)**:
   در مرحله لینک کردن، **لینک‌کننده** فایل‌های شیء (object files) را با هم ترکیب می‌کند تا یک برنامه کامل و اجرایی ایجاد شود. لینک‌کننده وظیفه دارد که تمام توابع و متغیرهای تعریف‌شده در فایل‌های مختلف را به یکدیگر مرتبط کند. به‌عنوان مثال، ممکن است شما در یک فایل منبع یک تابع تعریف کرده باشید و در فایل دیگری آن را فراخوانی کنید. لینک‌کننده اطمینان می‌دهد که این ارتباطات به درستی برقرار می‌شوند.

   علاوه بر این، لینک‌کننده کتابخانه‌های خارجی (مثل کتابخانه استاندارد C++) را نیز به برنامه متصل می‌کند تا بتوان از امکانات آن‌ها استفاده کرد. پس از اتمام لینک کردن، نتیجه یک فایل **اجرایی (executable)** است که می‌تواند توسط سیستم‌عامل و سخت‌افزار مربوطه اجرا شود.

4. **فایل اجرایی (Executable)**:
   این فایل نهایی، همان برنامه‌ای است که روی یک سیستم خاص قابل اجراست. این برنامه برای ترکیب خاصی از سخت‌افزار و سیستم‌عامل ساخته شده و به‌طور مستقیم نمی‌تواند روی سیستم‌های متفاوتی اجرا شود. به عنوان مثال، یک فایل اجرایی که روی سیستم عامل ویندوز تولید شده، روی مک به‌صورت مستقیم اجرا نمی‌شود.

### قابلیت حمل (Portability)
وقتی از قابلیت حمل در C++ صحبت می‌کنیم، منظور **قابلیت حمل کد منبع** است، نه فایل اجرایی. به این معنا که کد منبعی که شما نوشته‌اید، باید بتواند روی سیستم‌های مختلف (مثل ویندوز، مک، لینوکس) کامپایل و اجرا شود. اما فایل اجرایی تولیدشده توسط کامپایلر معمولاً فقط روی همان سیستم و سخت‌افزاری که برای آن کامپایل شده است، قابل اجراست. بنابراین، برای اجرای برنامه روی سیستم‌های مختلف، باید کد منبع مجدداً روی آن سیستم کامپایل شود. 

در نتیجه:
- **کامپایلر** کد منبع را به کد ماشین ترجمه می‌کند.
- **لینک‌کننده** فایل‌های شیء و کتابخانه‌ها را ترکیب می‌کند تا یک فایل اجرایی ایجاد شود.
- فایل اجرایی تنها برای سیستم خاصی که برای آن کامپایل شده قابل اجراست، اما کد منبع می‌تواند روی سیستم‌های مختلف کامپایل و اجرا شود.


---




---

برای اینکه فرآیند کامپایل، لینک و ایجاد برنامه اجرایی در C++ را بهتر درک کنیم، بیایید آن را با دقت بیشتری همراه با مثال توضیح دهیم.

### 1. نوشتن کد منبع (Source Code)

فرض کنید شما می‌خواهید یک برنامه ساده بنویسید که دو عدد را جمع بزند. برای این کار ابتدا باید کد منبع برنامه را بنویسید. این کد به زبان C++ نوشته می‌شود و در یک فایل متنی با پسوند `.cpp` ذخیره می‌شود. به‌عنوان مثال:

**File: `main.cpp`**
```cpp
#include <iostream>  // این خط کتابخانه iostream را برای استفاده از ورودی و خروجی وارد می‌کند

int add(int a, int b) {
    return a + b;   // تابعی که دو عدد را می‌گیرد و آن‌ها را جمع می‌زند
}

int main() {
    int x = 5;    // عدد اول
    int y = 10;   // عدد دوم
    std::cout << "Sum: " << add(x, y) << std::endl;  // چاپ نتیجه جمع دو عدد
    return 0;
}
```

### 2. کامپایلر (Compiler)

پس از نوشتن کد، باید آن را کامپایل کنید. **کامپایلر** وظیفه دارد که کد C++ را به **کد ماشین** (که پردازنده سیستم می‌تواند آن را بفهمد) تبدیل کند.

#### مراحل کامپایل:
- **تجزیه و تحلیل نحوی (Parsing)**: کامپایلر ابتدا کد را بررسی می‌کند که آیا همه چیز مطابق با قوانین نحو (syntax) C++ است یا خیر. مثلاً بررسی می‌کند که `int` به درستی برای نوع داده استفاده شده و اینکه تابع `add` به درستی تعریف شده است.
- **تجزیه و تحلیل نوع (Type Checking)**: سپس کامپایلر مطمئن می‌شود که انواع داده‌ها (مثل `int`) به درستی استفاده شده‌اند. اگر مثلاً به جای عدد صحیح، یک رشته به تابع `add` ارسال شود، کامپایلر خطا خواهد داد.
- **تولید کد (Code Generation)**: در این مرحله، کامپایلر کد ماشین را تولید می‌کند. این کد مستقیماً توسط پردازنده قابل اجرا است.

نتیجه کامپایل، تولید فایل‌های شیء (object files) است. فایل‌های شیء فایل‌هایی هستند که شامل کد باینری قابل اجرا هستند، اما به صورت کامل لینک نشده‌اند. برای مثال، خروجی کامپایلر برای فایل `main.cpp` می‌تواند `main.o` باشد.

### 3. لینک‌کننده (Linker)

پس از اینکه فایل‌های شیء توسط کامپایلر تولید شدند، این فایل‌ها هنوز آماده اجرا نیستند. اینجاست که **لینک‌کننده (linker)** وارد عمل می‌شود.

#### وظایف لینک‌کننده:
- **لینک کردن توابع و متغیرها**: در فایل‌های منبع مختلف، ممکن است توابع و متغیرهایی تعریف شده باشند که در فایل‌های دیگر مورد استفاده قرار می‌گیرند. لینک‌کننده وظیفه دارد که این موارد را به هم مرتبط کند. به‌عنوان مثال، در کد بالا، تابع `add` در جایی جدا تعریف شده و در تابع `main` استفاده شده است. لینک‌کننده باید این دو را به هم وصل کند.
- **اتصال به کتابخانه‌ها (Libraries)**: علاوه بر فایل‌های شیء برنامه شما، لینک‌کننده همچنین کتابخانه‌های خارجی مثل کتابخانه استاندارد C++ (که شامل توابعی مثل `std::cout` و `std::endl` است) را به برنامه متصل می‌کند. برای مثال، `iostream` کتابخانه‌ای است که به شما اجازه می‌دهد از ورودی و خروجی استفاده کنید، و این کتابخانه باید توسط لینک‌کننده به برنامه شما متصل شود.

نتیجه لینک کردن یک فایل اجرایی (Executable) است که می‌تواند مستقیماً توسط سیستم‌عامل اجرا شود. در این مثال، فایل اجرایی ممکن است `main.exe` در ویندوز یا `a.out` در لینوکس نامیده شود.

### 4. فایل اجرایی (Executable)

فایل اجرایی نهایی شامل تمام کدهای باینری است که پردازنده سیستم می‌تواند آن را مستقیماً اجرا کند. شما می‌توانید این فایل اجرایی را در خط فرمان یا با دوبار کلیک کردن روی آن اجرا کنید. مثلاً در لینوکس:

```
./a.out
```

خروجی:
```
Sum: 15
```

### مثال جامع‌تر: برنامه چند فایل

حالا فرض کنید برنامه شما بزرگ‌تر باشد و از چندین فایل منبع استفاده کند. برای مثال:

**File: `math.cpp`**
```cpp
int add(int a, int b) {
    return a + b;
}
```

**File: `main.cpp`**
```cpp
#include <iostream>
int add(int, int);  // اعلام تابع add

int main() {
    int x = 5;
    int y = 10;
    std::cout << "Sum: " << add(x, y) << std::endl;
    return 0;
}
```

در اینجا، تابع `add` در فایل `math.cpp` تعریف شده و در `main.cpp` استفاده می‌شود. هر دو فایل باید کامپایل شوند، سپس لینک‌کننده آن‌ها را به هم متصل می‌کند.

#### کامپایل جداگانه:
```
g++ -c main.cpp -o main.o
g++ -c math.cpp -o math.o
```

#### لینک کردن:
```
g++ main.o math.o -o myprogram
```

خروجی:
```
./myprogram
Sum: 15
```

### توضیح مراحل:
1. **کامپایلر** هر فایل را جداگانه کامپایل می‌کند و فایل‌های شیء (مثل `main.o` و `math.o`) تولید می‌کند.
2. **لینک‌کننده** فایل‌های شیء را ترکیب کرده و یک فایل اجرایی نهایی به نام `myprogram` ایجاد می‌کند.

### نکته درباره **قابلیت حمل (Portability)**:
فایل اجرایی (`myprogram`) که روی سیستم‌عامل خاصی مثل لینوکس ساخته شده، نمی‌تواند به‌طور مستقیم روی سیستم‌عاملی دیگر مثل ویندوز اجرا شود. برای اجرای برنامه روی ویندوز، باید کد منبع (`main.cpp` و `math.cpp`) را روی آن سیستم کامپایل و لینک کنید.

اما **کد منبع** معمولاً قابل حمل است؛ یعنی اگر از ویژگی‌های مستقل از سیستم‌عامل استفاده کرده باشید، می‌توانید همین کد منبع را روی سیستم‌های مختلف (مثل ویندوز، مک، یا لینوکس) کامپایل کنید و برنامه اجرایی مخصوص آن سیستم تولید شود.

---

## Hello, World!
کوچکترین برنامه C++ به صورت زیر است:

```cpp
int main() { } // the minimal C++ program
```

این یک تابع به نام `main` تعریف می‌کند که هیچ آرگومانی نمی‌گیرد و هیچ کاری انجام نمی‌دهد. آکولادها `{ }` در C++ برای گروه‌بندی استفاده می‌شوند. در اینجا، آن‌ها شروع و پایان بدنه تابع را نشان می‌دهند. دو اسلش `//` یک کامنت را آغاز می‌کند که تا پایان خط ادامه دارد. کامنت برای خواننده انسان است؛ کامپایلر کامنت‌ها را نادیده می‌گیرد.

هر برنامه C++ باید دقیقاً یک تابع سراسری به نام `main()` داشته باشد. برنامه با اجرای این تابع شروع می‌شود. مقدار `int` که توسط تابع `main()` برگردانده می‌شود (در صورت وجود) مقدار بازگشتی برنامه به «سیستم» است. اگر هیچ مقداری برگردانده نشود، سیستم مقداری که نشان‌دهنده موفقیت‌آمیز بودن اجرای برنامه است را دریافت می‌کند. یک مقدار غیر صفر از `main()` نشان‌دهنده شکست است. هر سیستم‌عامل یا محیط اجرایی لزوماً از مقدار بازگشتی استفاده نمی‌کند: محیط‌های مبتنی بر لینوکس/یونیکس اغلب این کار را می‌کنند، اما محیط‌های مبتنی بر ویندوز به‌ندرت این کار را انجام می‌دهند.

معمولاً یک برنامه مقداری خروجی تولید می‌کند. در اینجا یک برنامه ساده که عبارت "Hello, World!" را می‌نویسد:

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, World!\n";  
}
```

این برنامه از کتابخانه استاندارد `iostream` استفاده می‌کند تا عبارت "Hello, World!" را به خروجی (معمولاً کنسول) بنویسد.

خط `#include <iostream>` به کامپایلر دستور می‌دهد تا اعلان‌های مربوط به امکانات ورودی/خروجی استاندارد (stream I/O) که در فایل هدر **iostream** تعریف شده‌اند را وارد کند. بدون این اعلان‌ها، عبارت زیر معنایی نداشت:

```cpp
std::cout << "Hello, World!\n";
```

اپراتور `<<` (به معنی "put to") آرگومان دوم خود را به آرگومان اول منتقل می‌کند. در اینجا، رشته‌ی "Hello, World!\n" به جریان خروجی استاندارد **std::cout** منتقل می‌شود. یک **رشته‌ی متنی (string literal)** دنباله‌ای از کاراکترهاست که با علامت‌های نقل‌قول دوگانه محصور شده است. درون یک رشته‌ی متنی، کاراکتر بک‌اسلش `\` به همراه کاراکتر دیگری یک **کاراکتر خاص** را نشان می‌دهد. در این مثال، `\n` به معنی کاراکتر **newline** (خط جدید) است، بنابراین کاراکترهایی که نوشته می‌شوند، عبارت **Hello, World!** به‌همراه یک خط جدید هستند.

عبارت `std::` مشخص می‌کند که نام **cout** در فضای نام (namespace) استاندارد (std) قرار دارد. به طور معمول، وقتی درباره ویژگی‌های استاندارد صحبت می‌کنم، از `std::` استفاده نمی‌کنم. در بخش `§2.4.2` توضیح داده شده که چگونه می‌توان نام‌ها را از یک فضای نام قابل مشاهده کرد بدون نیاز به استفاده از `std::` در هر بار.

تقریباً همه‌ی کدهای اجرایی در توابع قرار می‌گیرند و مستقیماً یا غیرمستقیم از تابع **main()** فراخوانی می‌شوند. برای مثال:

```cpp
#include <iostream>
using namespace std; // نام‌های موجود در فضای نام std بدون نیاز به std:: قابل استفاده می‌شوند

double square(double x) // محاسبه‌ی مربع یک عدد اعشاری با دقت دوگانه (double)
{
    return x * x;
}

void print_square(double x) // تابعی برای چاپ نتیجه‌ی محاسبه‌ی مربع
{
    cout << "the square of " << x << " is " << square(x) << "\n";
}

int main()
{
    print_square(1.234); // خروجی: the square of 1.234 is 1.52276
}
```

در این مثال، **void** به‌عنوان **نوع بازگشتی (return type)** به این معنی است که تابع هیچ مقداری را بازنمی‌گرداند. برای مثال، تابع `print_square` هیچ مقداری برنمی‌گرداند، اما خروجی مورد نظر را به کنسول چاپ می‌کند.

## Types, Variables, and Arithmetic
در زبان C++، هر نام و هر عبارت دارای یک **نوع (type)** است که تعیین می‌کند چه عملیات‌هایی می‌توان روی آن انجام داد. به عنوان مثال، اعلان زیر را در نظر بگیرید:

```cpp
int inch;
```

این خط مشخص می‌کند که متغیر `inch` از نوع `int` است؛ یعنی `inch` یک متغیر صحیح (integer) است.

### تعریف‌ها:
- **اعلان (Declaration)**: عبارتی که یک نام جدید را وارد برنامه می‌کند و نوع آن را مشخص می‌کند.
- **نوع (Type)**: مجموعه‌ای از مقادیر ممکن و مجموعه‌ای از عملیات‌های ممکن که روی یک شیء قابل انجام است.
- **شیء (Object)**: مقداری از حافظه که دارای یک مقدار از یک نوع خاص است.
- **مقدار (Value)**: مجموعه‌ای از بیت‌ها که بر اساس نوع مشخصی تفسیر می‌شوند.
- **متغیر (Variable)**: شیء‌ای است که دارای یک نام است.

C++ انواع پایه‌ای متعددی را ارائه می‌دهد. هر نوع پایه‌ای به طور مستقیم با امکانات سخت‌افزاری مطابقت دارد و اندازه ثابتی دارد که محدوده مقادیری که می‌توانند در آن ذخیره شوند را تعیین می‌کند.

### انواع پایه‌ای رایج:
- **`bool`**: نوع بولین، مقادیر ممکن آن `true` و `false` است.
- **`char`**: نوع کاراکتر، مقادیر ممکن شامل کاراکترهایی مانند `'a'`، `'z'` و `'9'` است.
- **`int`**: نوع عدد صحیح، مقادیر ممکن شامل اعدادی مانند `1`، `42` و `1066` است.
- **`double`**: نوع عدد اعشاری با دقت دوگانه، مقادیر ممکن شامل اعدادی مانند `3.14` و `299793.0` است.

### نوع‌ها و اندازه‌ها:

هر یک از این نوع‌ها اندازه‌ی مشخصی دارند که محدوده مقادیری که می‌توانند در آن‌ها ذخیره شوند را تعیین می‌کند. اندازه هر نوع توسط سخت‌افزار یا استاندارد زبان C++ تعریف شده و ممکن است در سیستم‌های مختلف متفاوت باشد. به عنوان مثال، یک متغیر `int` معمولاً ۴ بایت فضا اشغال می‌کند و قادر است مقادیر عدد صحیح بین حدود `-2,147,483,648` تا `2,147,483,647` را نگه دارد.

مثال‌های استفاده از این نوع‌ها:

```cpp
bool is_raining = true;     // متغیر بولین
char letter = 'A';          // متغیر کاراکتر
int age = 25;               // متغیر عدد صحیح
double pi = 3.14159;        // متغیر عدد اعشاری با دقت دوگانه
```

هر نوع دارای یک سری عملیات و مقادیر ممکن است که بر اساس آن نوع تعریف شده‌اند. به عنوان مثال، می‌توان عملیات‌های منطقی مانند AND و OR را روی نوع `bool` اعمال کرد، یا عملیات‌های جمع و ضرب را روی نوع‌های `int` و `double` انجام داد.

![](./image/2/2.2.png)

یک متغیر از نوع `char` به اندازه‌ی طبیعی برای نگهداری یک کاراکتر در یک ماشین خاص است (معمولاً یک بایت 8-بیتی)، و اندازه‌ی سایر نوع‌ها به صورت مضربی از اندازه‌ی `char` بیان می‌شود. اندازه‌ی یک نوع توسط پیاده‌سازی مشخص می‌شود (یعنی می‌تواند در ماشین‌های مختلف متفاوت باشد) و می‌توان آن را با استفاده از عملگر `sizeof` به دست آورد؛ به عنوان مثال، `sizeof(char)` برابر با ۱ است و `sizeof(int)` معمولاً ۴ است.

در C++، می‌توان از عملگرهای مختلفی برای انجام عملیات‌های ریاضی و مقایسه‌ای استفاده کرد:

### عملگرهای ریاضی:
- `x + y` // جمع
- `+x` // علامت مثبت (عملگر یک‌دانه‌ای برای مثبت کردن)
- `x - y` // تفریق
- `-x` // علامت منفی (عملگر یک‌دانه‌ای برای منفی کردن)
- `x * y` // ضرب
- `x / y` // تقسیم
- `x % y` // باقیمانده (برای اعداد صحیح، عملگر مدولوس)

### عملگرهای مقایسه‌ای:
- `x == y` // برابر
- `x != y` // نابرابر
- `x < y` // کوچکتر از
- `x > y` // بزرگتر از
- `x <= y` // کوچکتر یا مساوی
- `x >= y` // بزرگتر یا مساوی

در عملیات‌های محاسباتی و انتساب، C++ تمامی تبدیل‌های معنادار بین انواع پایه‌ای را انجام می‌دهد تا بتوان آن‌ها را به‌صورت ترکیبی استفاده کرد. برای مثال:

```cpp
void some_function() // تابعی که مقداری برنمی‌گرداند
{
    double d = 2.2; // مقداردهی اولیه به یک عدد اعشاری
    int i = 7; // مقداردهی اولیه به یک عدد صحیح
    d = d + i; // جمع و انتساب نتیجه به d
    i = d * i; // ضرب و انتساب نتیجه به i (مقدار اعشاری d*i به یک عدد صحیح تبدیل و مقادیر اضافی حذف می‌شود)
}
```

دقت کنید که `=` عملگر **انتساب** است، در حالی که `==` برای **برابری** استفاده می‌شود.

C++ چندین روش برای مقداردهی اولیه ارائه می‌دهد، مانند استفاده از `=` در مثال بالا، یا استفاده از **لیست‌های مقداردهی محصور در آکولاد** به‌صورت زیر:

```cpp
double d1 = 2.3; 
double d2 {2.3}; // استفاده از {} برای مقداردهی اولیه
complex<double> z = 1; // عدد مختلط با مقادیر اعشاری
complex<double> z2 {d1, d2}; // عدد مختلط با دو عدد اعشاری
complex<double> z3 = {1, 2}; // علامت = اختیاری است وقتی از {} استفاده می‌کنیم
vector<int> v {1, 2, 3, 4, 5, 6}; // برداری از اعداد صحیح
```

استفاده از فرم `=` سنتی است و به زبان C برمی‌گردد، اما اگر شک دارید، بهتر است از فرم کلی `{}` استفاده کنید. این روش شما را از تبدیل‌های نادرست که منجر به از دست دادن اطلاعات می‌شوند، محافظت می‌کند. برای مثال:

```cpp
int i1 = 7.2; // i1 تبدیل به 7 می‌شود (اطلاعات اعشاری حذف می‌شود)
int i2 {7.2}; // خطا: تبدیل اعشاری به عدد صحیح مجاز نیست
int i3 = {7.2}; // خطا: تبدیل اعشاری به عدد صحیح (علامت = اضافی است)
```

یک **ثابت** نمی‌تواند بدون مقداردهی اولیه باشد، و یک **متغیر** فقط در شرایط بسیار خاص باید بدون مقداردهی اولیه رها شود. تا زمانی که یک مقدار مناسب ندارید، نامی را معرفی نکنید. انواع تعریف‌شده توسط کاربر (مانند `string`، `vector`، `Matrix`، `Motor_controller` و `Orc_warrior`) می‌توانند به‌طور ضمنی مقداردهی اولیه شوند.

هنگام تعریف یک متغیر، نیازی نیست که نوع آن را به‌طور صریح بیان کنید، زمانی که می‌توان آن را از مقداردهی اولیه استنباط کرد. برای مثال:

```cpp
auto b = true;    // یک متغیر از نوع bool
auto ch = 'x';    // یک متغیر از نوع char
auto i = 123;     // یک متغیر از نوع int
auto d = 1.2;     // یک متغیر از نوع double
auto z = sqrt(y); // نوع z همان نوع خروجی تابع sqrt(y) است
```

هنگام استفاده از `auto`، از سینتکس `=` استفاده می‌کنیم چون هیچ تبدیل نوعی که باعث مشکلات شود، دخیل نیست.

از `auto` در جایی استفاده می‌کنیم که دلیل خاصی برای ذکر صریح نوع نداشته باشیم. برخی از این دلایل خاص عبارتند از:
- تعریف در یک محدوده بزرگ که می‌خواهیم نوع متغیر برای خوانندگان کد به‌وضوح مشخص باشد.
- می‌خواهیم در مورد دقت یا محدوده متغیر به‌طور صریح صحبت کنیم (مانند استفاده از `double` به جای `float`).

با استفاده از `auto`، از تکرار غیرضروری و نوشتن نام‌های طولانی نوع جلوگیری می‌کنیم. این موضوع در برنامه‌نویسی جنریک (generic programming) که نوع دقیق یک شیء ممکن است برای برنامه‌نویس به‌سختی مشخص باشد، اهمیت بیشتری دارد، به‌خصوص وقتی نام‌های نوع می‌توانند بسیار طولانی باشند.

### عملگرهای ترکیبی برای تغییر متغیر:
علاوه بر عملگرهای محاسباتی و منطقی معمول، C++ عملگرهای خاص‌تری برای تغییر مقادیر متغیرها ارائه می‌دهد:

- `x += y` // معادل `x = x + y`
- `++x` // افزایش مقدار: `x = x + 1`
- `x -= y` // معادل `x = x - y`
- `--x` // کاهش مقدار: `x = x - 1`
- `x *= y` // مقیاس‌بندی: `x = x * y`
- `x /= y` // مقیاس‌بندی: `x = x / y`
- `x %= y` // معادل `x = x % y`

این عملگرها مختصر، کاربردی و بسیار رایج هستند.

---

در C++، دو روش برای مقداردهی اولیه متغیرها وجود دارد که هر دو در مثال‌های زیر نشان داده شده‌اند:

```cpp
double d1 = 2.3; // مقداردهی اولیه به سبک سنتی با استفاده از علامت =
double d2 {2.3}; // مقداردهی اولیه به سبک لیست با استفاده از {}
```

### تفاوت‌های اصلی بین این دو روش:

1. **مقداردهی سنتی (`=`)**:
   - در این روش از علامت `=` برای مقداردهی اولیه استفاده می‌شود. این روش سنتی است و از زبان C به ارث رسیده است.
   - در اینجا مقدار به متغیر اختصاص داده می‌شود، و اگر نوع مقدار با نوع متغیر سازگار نباشد، ممکن است تبدیل ضمنی انجام شود. به‌عنوان مثال، اگر مقدار `2.3` را به یک متغیر صحیح (`int`) اختصاص دهید، بدون خطا فقط قسمت صحیح عدد در نظر گرفته می‌شود.

   مثال:
   ```cpp
   int i = 7.8;  // i مقدار 7 را می‌گیرد (قسمت اعشاری حذف می‌شود)
   ```

2. **مقداردهی به سبک لیست (`{}`)**:
   - این روش در C++11 معرفی شده است و از آکولاد (`{}`) برای مقداردهی اولیه استفاده می‌کند.
   - این روش امن‌تر است، زیرا از تبدیل‌های ناخواسته و غیرقابل کنترل جلوگیری می‌کند. به این معنا که اگر نوع مقدار با نوع متغیر کاملاً سازگار نباشد، کامپایلر خطا می‌دهد. برای مثال، اگر سعی کنید یک مقدار اعشاری را به یک متغیر صحیح اختصاص دهید، کامپایلر خطا خواهد داد.

   مثال:
   ```cpp
   int i {7.8};  // خطا: تبدیل اعشاری به صحیح مجاز نیست
   ```

### جمع‌بندی:
- `=` برای مقداردهی اولیه به سبک سنتی استفاده می‌شود و در برخی موارد ممکن است باعث تبدیل‌های ضمنی شود که می‌تواند به از دست رفتن دقت منجر شود.
- `{}` برای مقداردهی اولیه به سبک لیست استفاده می‌شود که امن‌تر است و از تبدیل‌های غیرمجاز جلوگیری می‌کند، بنابراین استفاده از آن در شرایطی که می‌خواهید مطمئن شوید خطاهای تبدیل رخ نمی‌دهد، توصیه می‌شود.

---

---
دستور زیر:

```cpp
complex<double> z = 1;
```

یک شیء از نوع `complex<double>` تعریف می‌کند و مقداردهی اولیه‌ای برای آن انجام می‌دهد. این نوع به معنای عدد مختلط با قسمت‌های حقیقی و موهومی از نوع `double` است. اما چیزی که در اینجا خاص است، مقداردهی اولیه با عدد صحیح `1` است.

### تجزیه و تحلیل:

1. **نوع `complex<double>`:**
   - این نوع داده متعلق به کتابخانه استاندارد C++ است و برای نشان دادن اعداد مختلط استفاده می‌شود. 
   - `complex<double>` یک عدد مختلط است که قسمت حقیقی و موهومی آن از نوع `double` هستند.

2. **مقداردهی اولیه با `1`:**
   - مقدار `1` به عنوان عدد حقیقی در نظر گرفته می‌شود.
   - در اینجا، کامپایلر مقدار `1` را به عنوان قسمت حقیقی عدد مختلط تفسیر می‌کند و قسمت موهومی را به صورت پیش‌فرض برابر با `0` در نظر می‌گیرد.
   - بنابراین، `z` برابر با عدد مختلطی خواهد بود که قسمت حقیقی آن `1.0` و قسمت موهومی آن `0.0` است.

   به صورت صریح می‌توانیم این عدد را به صورت `complex<double> z(1.0, 0.0);` نیز تعریف کنیم که معنای مشابهی دارد.

### نتیجه نهایی:
این دستور `complex<double> z = 1;` باعث می‌شود که شیء `z` برابر با عدد مختلطی باشد که دارای قسمت حقیقی `1.0` و قسمت موهومی `0.0` است.

### مثال تکمیلی:
اگر مقداردهی به صورت زیر انجام شود:

```cpp
complex<double> z2(2.0, 3.0);  // عدد مختلطی با قسمت حقیقی 2.0 و قسمت موهومی 3.0
```

در این حالت، `z2` یک عدد مختلط خواهد بود که هم قسمت حقیقی و هم قسمت موهومی به وضوح مشخص شده‌اند.

---

## Constants
ترجمه:

C++ دو مفهوم تغییرناپذیری را پشتیبانی می‌کند:
- **const**: به معنای تقریبی «من قول می‌دهم این مقدار را تغییر ندهم» است. این بیشتر برای مشخص کردن رابط‌ها استفاده می‌شود، به طوری که داده‌ها می‌توانند به توابع منتقل شوند بدون اینکه ترس از تغییر آنها وجود داشته باشد. کامپایلر به وعده‌ای که توسط `const` داده شده، عمل می‌کند.
- **constexpr**: به معنای تقریبی «در زمان کامپایل ارزیابی شود» است. این بیشتر برای مشخص کردن ثابت‌ها استفاده می‌شود تا امکان قرارگیری داده‌ها در حافظه‌ای فراهم شود که احتمال خراب شدن آن کم است و همچنین برای بهبود عملکرد استفاده می‌شود.

```cpp
double sum(const vector<double>&); // sum آرگومان خود را تغییر نخواهد داد
vector<double> v {1.2, 3.4, 4.5}; // v یک ثابت نیست
const double s1 = sum(v); // قابل قبول: در زمان اجرا ارزیابی می‌شود
constexpr double s2 = sum(v); // خطا: sum(v) یک عبارت ثابت نیست
```

برای اینکه یک تابع قابل استفاده در یک عبارت ثابت باشد، یعنی در عبارتی که توسط کامپایلر ارزیابی می‌شود، باید به صورت `constexpr` تعریف شود. برای مثال:

```cpp
constexpr double square(double x) { return x * x; }
```

برای اینکه یک تابع `constexpr` باشد، باید نسبتاً ساده باشد: فقط یک عبارت `return` که مقداری را محاسبه می‌کند. یک تابع `constexpr` می‌تواند برای آرگومان‌های غیرثابت نیز استفاده شود، اما در این حالت نتیجه یک عبارت ثابت نخواهد بود. ما به تابع `constexpr` اجازه می‌دهیم که با آرگومان‌های غیرثابت فراخوانی شود در زمینه‌هایی که عبارات ثابت نیاز ندارند، تا مجبور نباشیم دو تابع تقریباً مشابه تعریف کنیم: یکی برای عبارات ثابت و دیگری برای متغیرها.

در چند مورد، عبارات ثابت توسط قوانین زبان الزامی هستند (مثلاً اندازه آرایه‌ها، برچسب‌های case، برخی از آرگومان‌های الگو و ثابت‌هایی که با `constexpr` اعلام می‌شوند). در موارد دیگر، ارزیابی در زمان کامپایل برای عملکرد مهم است. مستقل از مسائل عملکردی، مفهوم تغییرناپذیری (یک شیء با حالت غیرقابل تغییر) یک نگرانی مهم در طراحی است.

برای مثال:

```cpp
const int dmv = 17; // dmv یک ثابت نام‌گذاری شده است
int var = 17; // var یک ثابت نیست
constexpr double max1 = 1.4 * square(dmv); // اگر square(17) یک عبارت ثابت باشد، قابل قبول است
constexpr double max2 = 1.4 * square(var); // خطا: var یک عبارت ثابت نیست
const double max3 = 1.4 * square(var); // قابل قبول، ممکن است در زمان اجرا ارزیابی شود
```

---

در C++، کلیدواژه‌های **`const`** و **`constexpr`** هر دو برای بیان مفهوم ثابت بودن و تغییرناپذیری استفاده می‌شوند، اما هر کدام کاربردها، محدودیت‌ها و رفتارهای متفاوتی دارند. در ادامه با توضیحات دقیق‌تر و مثال‌های بیشتری به بررسی این دو مفهوم می‌پردازیم:

### 1. `const`
کلمه کلیدی `const` به این معناست که **یک متغیر پس از مقداردهی اولیه دیگر نمی‌تواند تغییر کند**. اما این مقدار می‌تواند در زمان **اجرا** (run-time) تعیین شود. بنابراین، `const` صرفاً یک نوع **تعهد** یا **قول** به کامپایلر است که این متغیر نباید پس از مقداردهی تغییر کند.

#### ویژگی‌ها:
- **مقدار متغیر در زمان اجرا تعیین می‌شود**.
- پس از مقداردهی اولیه، مقدار آن دیگر قابل تغییر نیست.
- از `const` می‌توان برای حفاظت از پارامترهای ورودی توابع استفاده کرد تا از تغییر آن‌ها در داخل تابع جلوگیری شود.

#### مثال ۱: تعریف یک متغیر ثابت
```cpp
const int x = 10;
x = 20;  // خطا: نمی‌توان مقدار یک متغیر const را تغییر داد.
```

#### مثال ۲: استفاده از `const` در پارامترهای توابع
```cpp
void printVector(const vector<int>& v) {
    for (int i : v) {
        cout << i << " ";  // فقط خواندن داده‌ها
    }
    // v.push_back(10);  // خطا: نمی‌توان یک مقدار جدید به بردار اضافه کرد.
}

int main() {
    vector<int> nums = {1, 2, 3, 4};
    printVector(nums);  // فراخوانی تابع با آرگومان ثابت
}
```
در این مثال، پارامتر ورودی `v` یک بردار از نوع `const` است، بنابراین تابع نمی‌تواند محتوای بردار را تغییر دهد.

#### مثال ۳: تعریف اشاره‌گر `const`
```cpp
int a = 10;
int b = 20;
const int* ptr = &a;  // اشاره‌گر به یک متغیر ثابت
*ptr = 30;  // خطا: نمی‌توان مقدار a را از طریق اشاره‌گر تغییر داد.
ptr = &b;  // قابل قبول: می‌توان اشاره‌گر را به یک آدرس دیگر تغییر داد.
```
در اینجا، `ptr` یک اشاره‌گر به یک متغیر ثابت است، به این معنا که از طریق این اشاره‌گر نمی‌توان مقدار متغیری که به آن اشاره شده است را تغییر داد، اما خود اشاره‌گر می‌تواند به آدرس دیگری اشاره کند.

### 2. `constexpr`
کلمه کلیدی `constexpr` به این معناست که **مقدار متغیر یا تابع باید در زمان کامپایل محاسبه شود**. از `constexpr` زمانی استفاده می‌شود که بخواهیم یک مقدار ثابت را در زمان کامپایل تعیین کنیم، که این موضوع می‌تواند باعث بهبود عملکرد برنامه شود زیرا کامپایلر می‌تواند نتیجه را در زمان کامپایل محاسبه کرده و از محاسبه‌های زمان اجرا جلوگیری کند.

#### ویژگی‌ها:
- **مقدار متغیر باید در زمان کامپایل قابل محاسبه باشد**.
- توابع `constexpr` باید ساده و حاوی یک عبارت `return` باشند که کامپایلر بتواند آن را در زمان کامپایل ارزیابی کند.
- اگر تابع `constexpr` با مقادیری که در زمان کامپایل قابل ارزیابی نیستند فراخوانی شود، تابع به‌طور عادی در زمان اجرا ارزیابی خواهد شد.

#### مثال ۱: تعریف ثابت زمان کامپایل
```cpp
constexpr int x = 10;  // 'x' در زمان کامپایل مقداردهی می‌شود.
```

#### مثال ۲: استفاده از `constexpr` در تابع
```cpp
constexpr int square(int x) {
    return x * x;
}

constexpr int result = square(5);  // این مقدار در زمان کامپایل محاسبه می‌شود.
```
در این مثال، تابع `square` به عنوان `constexpr` تعریف شده است و چون آرگومان آن یک مقدار ثابت (۵) است، نتیجه‌ی تابع نیز در زمان کامپایل محاسبه می‌شود.

#### مثال ۳: ارزیابی زمان کامپایل و زمان اجرا
```cpp
constexpr int square(int x) {
    return x * x;
}

int main() {
    constexpr int constValue = square(5);  // محاسبه در زمان کامپایل
    int dynamicValue = 10;
    int result = square(dynamicValue);  // محاسبه در زمان اجرا
}
```
در این مثال، وقتی تابع `square` با مقدار ثابت `5` فراخوانی می‌شود، کامپایلر مقدار `square(5)` را در زمان کامپایل محاسبه می‌کند. اما وقتی تابع با متغیر `dynamicValue` که مقدار آن فقط در زمان اجرا مشخص می‌شود، فراخوانی شود، کامپایلر نمی‌تواند مقدار را در زمان کامپایل محاسبه کند و این محاسبه در زمان اجرا انجام خواهد شد.

### تفاوت‌های دقیق‌تر بین `const` و `constexpr`:

1. **زمان محاسبه**:
   - `const`: مقدار متغیر می‌تواند در زمان اجرا محاسبه شود.
   - `constexpr`: مقدار متغیر یا نتیجه تابع **باید** در زمان کامپایل محاسبه شود.

2. **کاربرد**:
   - `const`: برای ثابت کردن مقدارهایی که در زمان اجرا تعیین می‌شوند.
   - `constexpr`: برای ثابت کردن مقدارهایی که در زمان کامپایل باید محاسبه شوند.

3. **توابع**:
   - توابع `const` نداریم، اما می‌توانیم از `const` برای پارامترها و اعضای توابع استفاده کنیم.
   - توابع `constexpr` می‌توانند هم برای محاسبات زمان کامپایل و هم زمان اجرا استفاده شوند، اما وقتی از ورودی‌های ثابت استفاده شود، در زمان کامپایل ارزیابی می‌شوند.

#### مثال ۴: استفاده ترکیبی از `const` و `constexpr`
```cpp
constexpr int square(int x) {
    return x * x;
}

int main() {
    const int a = 5;   // 'a' یک ثابت در زمان اجرا است.
    constexpr int b = 10;  // 'b' یک ثابت در زمان کامپایل است.
    
    constexpr int result1 = square(b);  // در زمان کامپایل محاسبه می‌شود.
    const int result2 = square(a);  // ممکن است در زمان اجرا محاسبه شود.
    
    return 0;
}
```
در این مثال:
- `result1` یک مقدار ثابت است که در زمان کامپایل محاسبه می‌شود زیرا `b` ثابت زمان کامپایل است.
- `result2` ممکن است در زمان اجرا محاسبه شود زیرا `a` فقط یک مقدار ثابت زمان اجرا است.

### جمع‌بندی:
- **`const`** برای مواقعی استفاده می‌شود که می‌خواهید پس از مقداردهی، دیگر نتوان مقدار یک متغیر را تغییر داد. این مقدار ممکن است در زمان اجرا محاسبه شود.
- **`constexpr`** برای مواقعی استفاده می‌شود که می‌خواهید کامپایلر مقدار را در زمان کامپایل محاسبه کند. این قابلیت باعث بهبود عملکرد و جلوگیری از محاسبات غیرضروری در زمان اجرا می‌شود.


---

---

دلیل خطا در این خط:

```cpp
constexpr double max2 = 1.4 * square(var); // error: var is not a constant expression
```

این است که متغیر `var` یک **ثابت زمان کامپایل** (compile-time constant) نیست.

### توضیح بیشتر:
کلیدواژه `constexpr` به این معناست که **تمام** مقادیر و عملیات‌هایی که در محاسبه‌ی مقدار یک متغیر `constexpr` دخیل هستند، باید در زمان **کامپایل** قابل ارزیابی باشند. به عبارت دیگر، **تمام آرگومان‌های توابع `constexpr` باید ثابت‌های زمان کامپایل** باشند.

- در خطی که خطا می‌دهد، متغیر `var` یک متغیر ساده است:
  
  ```cpp
  int var = 17;  // var is not a constant
  ```

  چون `var` یک **ثابت زمان اجرا** (run-time constant) نیست، کامپایلر نمی‌تواند مقدار `square(var)` را در زمان کامپایل محاسبه کند. برای اینکه کامپایلر بتواند یک مقدار را در زمان کامپایل محاسبه کند، همه مقادیر باید ثابت زمان کامپایل باشند.

### دلیل خطا:
- در خط زیر:
  
  ```cpp
  constexpr double max2 = 1.4 * square(var);  // خطا
  ```
  
  چون `var` یک متغیر عادی است که مقدار آن در زمان اجرا (run-time) تعیین می‌شود، نمی‌توان از آن در یک عبارت `constexpr` که در زمان کامپایل محاسبه می‌شود، استفاده کرد. بنابراین، کامپایلر نمی‌تواند مقدار `max2` را در زمان کامپایل محاسبه کند و خطا می‌دهد.

### تفاوت با `dmv`:
در مقایسه با `var`، متغیر `dmv` که در خط زیر استفاده شده است:
  
```cpp
constexpr double max1 = 1.4 * square(dmv);  // OK
```

متغیر `dmv` به صورت `const` و با یک مقدار ثابت زمان کامپایل (`17`) تعریف شده است:

```cpp
const int dmv = 17;  // dmv یک ثابت است
```

چون مقدار `dmv` در زمان کامپایل مشخص است، محاسبه `square(dmv)` در زمان کامپایل بدون مشکل انجام می‌شود و کامپایلر می‌تواند مقدار `max1` را به عنوان یک عبارت ثابت زمان کامپایل تعیین کند.

### خلاصه:
دلیل خطا این است که `var` یک مقدار ثابت زمان اجرا است، در حالی که محاسبات مربوط به `constexpr` باید در زمان کامپایل انجام شوند.

---

---

در زبان ++C، تابع `constexpr` به تابعی گفته می‌شود که قابلیت ارزیابی در زمان کامپایل (compile-time) را دارد. به این معنا که اگر تمامی آرگومان‌های ورودی به این تابع مقادیر ثابت (مانند ثابت‌های عددی) باشند، کامپایلر می‌تواند نتیجه آن را در زمان کامپایل محاسبه کند.

با این حال، نکته مهم این است که توابع `constexpr` تنها به مقادیر ثابت محدود نمی‌شوند و می‌توانند با آرگومان‌های غیرثابت (non-constant) نیز کار کنند. در این صورت، تابع به جای اینکه در زمان کامپایل ارزیابی شود، در زمان اجرا (runtime) اجرا می‌شود. در واقع، یک تابع `constexpr` هم می‌تواند در زمان کامپایل استفاده شود و هم در زمان اجرا، بسته به نوع ورودی‌ها.

### مثال:
فرض کنید تابعی داریم که دو عدد را با هم جمع می‌کند و این تابع را به عنوان `constexpr` تعریف کرده‌ایم:

```cpp
constexpr int add(int a, int b) {
    return a + b;
}
```

در اینجا اگر تابع با مقادیر ثابت فراخوانی شود:

```cpp
constexpr int result = add(3, 4);
```

کامپایلر مقدار `result` را در زمان کامپایل محاسبه می‌کند و در کد نهایی مقدار آن مستقیماً جایگزین می‌شود.

اما اگر تابع با مقادیر غیرثابت (مثلاً متغیرهایی که در زمان اجرا مقداردهی می‌شوند) فراخوانی شود:

```cpp
int x = 5;
int y = 10;
int result = add(x, y);
```

در این حالت، تابع `add` در زمان اجرا (runtime) اجرا می‌شود، زیرا متغیرهای `x` و `y` در زمان کامپایل مقدار مشخصی ندارند.

### نکات مهم:
1. **تابع `constexpr` هم در زمان کامپایل و هم در زمان اجرا می‌تواند استفاده شود.** اگر ورودی‌ها ثابت باشند، تابع در زمان کامپایل ارزیابی می‌شود و اگر ورودی‌ها غیرثابت باشند، در زمان اجرا محاسبه می‌شود.
2. **انعطاف‌پذیری توابع `constexpr`**: این قابلیت به توابع `constexpr` انعطاف‌پذیری می‌دهد تا در هر دو حالت کامپایل و اجرا به کار گرفته شوند، و از آن‌ها برای بهینه‌سازی برنامه‌ها استفاده کرد.
3. **قواعد `constexpr`**: این توابع همچنان باید یک سری قواعد را رعایت کنند. مثلاً، بدنه تابع باید فقط شامل عملیاتی باشد که قابل ارزیابی در زمان کامپایل هستند.

در نتیجه، استفاده از توابع `constexpr` می‌تواند به بهینه‌سازی‌های قدرتمندی در کدهای ++C منجر شود، در صورتی که با داده‌های ثابت کار می‌کنند، اما همچنان قابلیت استفاده با داده‌های متغیر در زمان اجرا را نیز دارند.

---


---

در زبان‌های برنامه‌نویسی مدرن، مثل C++، مفهوم «عبارت ثابت» (constant expression) و «تابع constexpr» نقش مهمی در بهبود عملکرد و طراحی کد ایفا می‌کند. برای درک بهتر مطالب گفته شده، بیایید به صورت جزئی‌تر به توضیح این مفاهیم بپردازیم:

### 1. **عبارت ثابت (Constant Expression)**
یک عبارت ثابت، عبارتی است که می‌تواند در زمان کامپایل محاسبه شود. یعنی کامپایلر می‌تواند قبل از اجرای برنامه مقدار این عبارت را بداند و در جای مناسب از آن استفاده کند. این نوع عبارات در زمان اجرای برنامه دوباره محاسبه نمی‌شوند، بلکه در حین کامپایل ثابت می‌شوند و از آنجا به بعد برنامه به جای محاسبه، از این مقدار ثابت استفاده می‌کند.

برای مثال:

```cpp
constexpr int x = 5 + 3; // کامپایلر این مقدار را در زمان کامپایل محاسبه می‌کند.
int arr[x]; // اندازه آرایه به یک مقدار ثابت نیاز دارد.
```

### 2. **تابع `constexpr`**
تابع `constexpr` تابعی است که کامپایلر می‌تواند آن را در زمان کامپایل اجرا کند و نتیجه آن را به عنوان یک مقدار ثابت در نظر بگیرد. این توابع به کامپایلر کمک می‌کنند که بتواند برخی محاسبات را زودتر انجام دهد و نیازی به انجام آن‌ها در زمان اجرای برنامه نباشد.

مثال:

```cpp
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : (n * factorial(n - 1));
}
```

در اینجا، اگر تابع `factorial` را با یک مقدار ثابت فراخوانی کنیم، مثلاً `factorial(5)`، کامپایلر می‌تواند مقدار آن را در زمان کامپایل محاسبه کند.

### 3. **شرایط تابع `constexpr`**
تا زمانی که تابع شما خیلی پیچیده نباشد، می‌توانید آن را به صورت `constexpr` تعریف کنید. محدودیت‌های اصلی تابع `constexpr` عبارت‌اند از:
- تابع باید فقط شامل یک عبارت بازگشتی (`return`) باشد که یک مقدار را محاسبه و برگرداند.
- نمی‌توان درون تابع از عملیات‌های پیچیده یا استفاده از متغیرهای متغیرپذیر (قابل تغییر) استفاده کرد.
- استفاده از عملیات‌های I/O یا سیستم‌عاملی مجاز نیست.

مثلاً، یک تابع `constexpr` نمی‌تواند مستقیماً از یک آرایه پویا استفاده کند، چون در زمان کامپایل اندازه‌های پویا قابل محاسبه نیستند.

### 4. **استفاده‌های تابع `constexpr`**
تابع `constexpr` هم برای بهینه‌سازی عملکرد مهم است و هم در جاهایی که قوانین زبان نیاز به عبارات ثابت دارند. برخی از مواردی که به عبارات ثابت نیاز دارند، عبارت‌اند از:
- **اندازه آرایه‌ها**: در C++، اندازه آرایه‌ها باید در زمان کامپایل مشخص باشد. پس اگر بخواهید از یک تابع برای تعیین اندازه آرایه استفاده کنید، آن تابع باید `constexpr` باشد.
  
  مثال:
  ```cpp
  constexpr int size_of_array = factorial(5); // اندازه آرایه باید ثابت باشد
  int arr[size_of_array]; // آرایه‌ای با اندازه ثابت
  ```

- **برچسب‌های `case` در switch**: در یک دستور `switch`، برچسب‌های `case` باید مقدارهای ثابت باشند. بنابراین، اگر بخواهید از یک تابع برای محاسبه این مقدار استفاده کنید، باید تابع `constexpr` باشد.

  مثال:
  ```cpp
  constexpr int value = factorial(3);
  
  switch(value) {
      case 6: // این مقدار باید در زمان کامپایل مشخص شود
          // کارهایی که باید انجام شود
          break;
  }
  ```

- **آرگومان‌های الگو (Template Arguments)**: برخی آرگومان‌های الگو، به خصوص در الگوهای تابع یا کلاس، باید ثابت باشند. پس اگر یک تابع برای محاسبه آرگومان‌ها استفاده می‌شود، باید `constexpr` باشد.

  مثال:
  ```cpp
  template<int N>
  struct Array {
      int data[N];
  };
  
  constexpr int length = factorial(4);
  Array<length> myArray; // N باید یک مقدار ثابت باشد
  ```

### 5. **چرا `constexpr` برای عملکرد مهم است؟**
استفاده از توابع `constexpr` باعث می‌شود که بسیاری از محاسبات که به صورت عادی باید در زمان اجرا انجام شوند، در زمان کامپایل انجام شوند. این کار می‌تواند سرعت اجرای برنامه را بهبود دهد، زیرا بسیاری از محاسبات از قبل انجام شده و فقط نتایج نهایی ذخیره و استفاده می‌شوند.

### 6. **تفاوت با توابع معمولی**
اگر تابعی `constexpr` باشد، می‌تواند در زمان اجرا (runtime) نیز برای آرگومان‌های غیرثابت استفاده شود. اما وقتی این تابع با آرگومان‌های غیرثابت فراخوانی شود، نتیجه آن دیگر یک عبارت ثابت نخواهد بود.

به این معنی که:
- اگر آرگومان تابع `constexpr` در زمان کامپایل شناخته‌شده باشد، کامپایلر مقدار را در زمان کامپایل محاسبه می‌کند.
- اگر آرگومان در زمان اجرا مشخص شود، تابع در زمان اجرا محاسبه می‌شود.

این انعطاف باعث می‌شود که ما مجبور نباشیم یک تابع را دو بار تعریف کنیم: یک بار برای محاسبات ثابت و یک بار برای محاسبات متغیر.

---

به طور کلی، `constexpr` یکی از ویژگی‌های قدرتمند C++ است که به ما اجازه می‌دهد محاسبات پیچیده را به زمان کامپایل منتقل کنیم و به این ترتیب هم عملکرد بهتری داشته باشیم و هم از نوشتن کد تکراری جلوگیری کنیم.

---

```
const int dmv = 17; // dmv is a named constant
int var = 17; // var is not a constant
constexpr double max1 = 1.4∗square(dmv); // OK if square(17) is a constant expression
constexpr double max2 = 1.4∗square(var); // error : var is not a constant expression
const double max3 = 1.4∗square(var); // OK, may be evaluated at run timeSection 2.2.3 Constants 43
double sum(const vector<double>&); // sum will not modify its argument (§2.2.5)
vector<double> v {1.2, 3.4, 4.5}; // v is not a constant
const double s1 = sum(v); // OK: evaluated at run time
constexpr double s2 = sum(v); // error : sum(v) not constant expression
```

## Tests and Loops
