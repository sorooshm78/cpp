# The Design of C++
هدف یک زبان برنامه‌نویسی کمک به بیان ایده‌ها در قالب کد است. در این راستا، یک زبان برنامه‌نویسی دو وظیفه مرتبط را انجام می‌دهد: وسیله‌ای فراهم می‌کند تا برنامه‌نویس بتواند اقداماتی را که باید توسط ماشین اجرا شود، مشخص کند، و مجموعه‌ای از مفاهیم را برای برنامه‌نویس فراهم می‌کند تا از آن‌ها هنگام تفکر درباره کاری که می‌تواند انجام شود، استفاده کند. هدف اول به‌طور ایده‌آل نیاز به زبانی دارد که "نزدیک به ماشین" باشد، به‌گونه‌ای که همه جنبه‌های مهم ماشین به‌صورت ساده و کارآمد و به شکلی که برای برنامه‌نویس به‌طور معقولی واضح باشد، مدیریت شوند. زبان C عمدتاً با این هدف طراحی شده است. هدف دوم به‌طور ایده‌آل نیاز به زبانی دارد که "نزدیک به مسئله‌ای که باید حل شود" باشد، به‌گونه‌ای که مفاهیم یک راه‌حل را بتوان به‌طور مستقیم و مختصر بیان کرد. امکاناتی که به C افزوده شدند تا C++ ایجاد شود، مانند بررسی آرگومان‌های تابع، کلمه کلیدی const، کلاس‌ها، سازنده‌ها و مخرب‌ها، استثناها و قالب‌ها (templates)، عمدتاً با این هدف طراحی شده‌اند. بنابراین، C++ بر اساس این ایده استوار است که هم

- نگاشت‌های مستقیم عملیات و انواع داخلی به سخت‌افزار را برای استفاده کارآمد از حافظه و عملیات سطح پایین کارآمد فراهم کند، و
- مکانیزم‌های انتزاعی مقرون‌به‌صرفه و انعطاف‌پذیری را برای ایجاد انواع تعریف‌شده توسط کاربر با همان پشتیبانی از نشانه‌گذاری، دامنه کاربرد و عملکرد مانند انواع داخلی ارائه دهد.

اهمیت عبارت «تمایل به برنامه‌نویسی سیستم‌ها» در تعریف طولانی‌مدت من از C++ این است که C++ با حذف قابلیت‌هایی که برای استفاده در سطح تخصصی از سخت‌افزار و منابع سیستم طراحی شده‌اند، ساده‌سازی (یا مصالحه) نشده است، با این امید که آن را برای حوزه‌های کاربردی دیگر مناسب‌تر کند.

دو اصل زیر باید مورد توجه قرار گیرد:

• هیچ جایی برای زبان سطح پایین‌تری زیر C++ باقی نگذارید (به جز در موارد نادر که از کد اسمبلی استفاده می‌شود). اگر بتوان کدی با کارایی بالاتر در یک زبان سطح پایین‌تر نوشت، آن زبان احتمالاً به زبان انتخابی برای برنامه‌نویسی سیستم‌ها تبدیل خواهد شد.

• چیزی که استفاده نمی‌کنید، هزینه‌ای برای شما ندارد. اگر برنامه‌نویسان بتوانند به‌طور دستی کدی معقول برای شبیه‌سازی یک ویژگی زبانی یا انتزاع بنیادی بنویسند و حتی عملکردی کمی بهتر ارائه دهند، قطعاً کسی این کار را خواهد کرد و بسیاری از دیگران از آن تقلید خواهند کرد. بنابراین، یک ویژگی زبان و یک انتزاع بنیادی باید به گونه‌ای طراحی شود که نسبت به جایگزین‌های معادل، حتی یک بایت یا یک سیکل پردازنده را هدر ندهد. این به‌عنوان اصل «عدم سربار اضافی» شناخته می‌شود.

اصل «چیزی که استفاده نمی‌کنید، هزینه‌ای برای شما ندارد» (که به عنوان **اصل عدم سربار اضافی** یا **zero-overhead principle** شناخته می‌شود) یکی از اصول کلیدی طراحی زبان C++ است. این اصل بیان می‌کند که اگر شما از ویژگی یا قابلیت خاصی در زبان استفاده نکنید، نباید هیچ هزینه اضافی از لحاظ کارایی (مثل مصرف حافظه یا زمان پردازش) برای برنامه شما تحمیل شود.

### جزئیات بیشتر:
1. **عملکرد بهینه**: 
   این اصل بر این مبنا است که زبان باید به برنامه‌نویسان اجازه دهد تا بدون پرداخت هزینه اضافی برای ویژگی‌هایی که استفاده نمی‌کنند، به همان میزان کارایی و بهینگی که با زبان‌های سطح پایین (مثل اسمبلی یا C) می‌توان به دست آورد، دسترسی داشته باشند. به بیان دیگر، اگر شما یک قابلیت خاص مثل شی‌گرایی، استثناها یا قالب‌ها (templates) را در برنامه خود به کار نمی‌برید، نباید حتی یک بایت اضافی حافظه یا یک سیکل پردازنده بیشتر از آنچه در زبان‌های سطح پایین انتظار می‌رود مصرف شود.

2. **اجتناب از سربار ناخواسته**: 
   یکی از دلایل کلیدی که برنامه‌نویسان ممکن است یک زبان سطح پایین‌تر مثل اسمبلی را برای نوشتن کد انتخاب کنند، جلوگیری از سربار اضافی ناشی از ویژگی‌های زبان سطح بالاتر است. در C++ تلاش شده است تا این سربار حذف شود یا به حداقل برسد. به این معنا که وقتی یک ویژگی مثل کلاس‌ها یا الگوها (templates) را استفاده می‌کنید، فقط به میزانی که دقیقاً نیاز دارید هزینه می‌پردازید، و اگر از آنها استفاده نمی‌کنید، هیچ هزینه اضافی به برنامه شما تحمیل نمی‌شود.

3. **مقایسه با جایگزین‌های معادل**: 
   اگر یک برنامه‌نویس بتواند یک ویژگی زبانی یا انتزاع بنیادی (مثل توابع مجازی یا مدیریت خودکار حافظه) را به‌طور دستی و با کارایی بهتر پیاده‌سازی کند، دیگران نیز از او پیروی خواهند کرد و آن زبان را کنار خواهند گذاشت. بنابراین، ویژگی‌های C++ باید به گونه‌ای طراحی شوند که استفاده از آنها همان کارایی را داشته باشد که خود برنامه‌نویس با نوشتن کد دستی به آن می‌رسد. به عبارت دیگر، هیچ بایت حافظه یا سیکل پردازنده‌ای نباید در مقایسه با جایگزین‌های دستی هدر رود.

### مثال‌ها:
1. **الگوها (Templates)**: 
   یکی از مهم‌ترین مثال‌های این اصل، الگوها در C++ است. الگوها به گونه‌ای طراحی شده‌اند که وقتی از آن‌ها استفاده می‌کنید، کد بهینه‌ای تولید می‌شود که دقیقاً معادل کدی است که ممکن است برنامه‌نویس به صورت دستی برای انواع مختلف بنویسد. به این ترتیب، شما از قابلیت استفاده مجدد و انتزاع در کد بهره‌مند می‌شوید بدون اینکه کارایی خود را قربانی کنید.

2. **توابع درون‌خطی (Inline Functions)**: 
   توابع درون‌خطی نمونه دیگری هستند. اگر شما تابعی را به صورت inline تعریف کنید، کامپایلر تلاش می‌کند تا این تابع را مستقیماً به جای فراخوانی، در کد جایگذاری کند، به این ترتیب سربار فراخوانی تابع از بین می‌رود.

به‌طور خلاصه، اصل عدم سربار اضافی تضمین می‌کند که اگر برنامه‌نویس از یک ویژگی یا انتزاع در C++ استفاده نکند، نباید هیچ هزینه اضافی بابت آن بپردازد و اگر از آن استفاده کند، کارایی آن با کدی که دستی نوشته شده قابل مقایسه باشد.

## Programming Style
مفهوم ویژگی‌های زبان‌های برنامه‌نویسی به این معناست که آن‌ها به پشتیبانی از سبک‌های مختلف برنامه‌نویسی کمک می‌کنند. نباید به هر ویژگی زبان به عنوان یک راه‌حل مستقل نگاه کرد، بلکه باید آن را به عنوان یکی از اجزای سازنده‌ای در نظر گرفت که می‌توانند با هم ترکیب شوند تا راه‌حل‌ها را بیان کنند.

ایده‌های کلی برای طراحی و برنامه‌نویسی به سادگی قابل بیان هستند:

- ایده‌ها را به طور مستقیم در کد بیان کنید.
- ایده‌های مستقل را به طور مستقل در کد بیان کنید.
- روابط میان ایده‌ها را به طور مستقیم در کد نمایان کنید.
- ایده‌های بیان شده در کد را به طور آزاد ترکیب کنید، فقط در جایی که ترکیب‌ها منطقی است.
- ایده‌های ساده را به سادگی بیان کنید.

احساس ناخوشایندی دارم وقتی کسی C++ را به طور انحصاری از طریق یکی از این سبک‌ها توصیف می‌کند (مثلاً "C++ یک زبان شیءگرا است") یا از اصطلاحی مانند "ترکیبی" یا "چندپارادایمی" استفاده می‌کند تا به این نکته اشاره کند که یک زبان محدودتر ممکن است بهتر باشد. دیدگاه اول این واقعیت را نادیده می‌گیرد که همه این سبک‌ها به چیزی مهم در ترکیب‌بندی C++ کمک کرده‌اند؛ و دیدگاه دوم اعتبار این ترکیب را زیر سؤال می‌برد. این سبک‌ها گزینه‌های جایگزین متمایزی نیستند؛ هرکدام تکنیک‌هایی به سبک برنامه‌نویسی اضافه می‌کنند که بیانگر و کارآمدتر هستند، و C++ به‌طور مستقیم پشتیبانی زبانی برای استفاده ترکیبی از آن‌ها فراهم می‌کند.

- کلاس‌ها از تمامی سبک‌های ذکر شده پشتیبانی می‌کنند؛ همه آن‌ها به این امر متکی هستند که کاربر ایده‌ها را به صورت نوع‌های تعریف‌شده توسط کاربر یا اشیاء مربوط به نوع‌های تعریف‌شده توسط کاربر نمایش دهد.

- کنترل دسترسی عمومی/خصوصی از انتزاع داده و برنامه‌نویسی شی‌گرا پشتیبانی می‌کند، با ایجاد تمایز واضح بین واسط (interface) و پیاده‌سازی (implementation).
- توابع عضو، سازنده‌ها، مخرب‌ها و انتساب تعریف‌شده توسط کاربر یک رابط کاربردی تمیز برای اشیاء فراهم می‌کنند که در انتزاع داده و برنامه‌نویسی شی‌گرا نیاز است. آن‌ها همچنین یک نشانه‌گذاری یکنواخت برای برنامه‌نویسی جنریک فراهم می‌کنند. بارگذاری بیش از حد (overloading) عمومی‌تر باید تا سال 1984 و مقداردهی یکنواخت تا سال 2010 صبر می‌کرد.
- اعلان‌های تابع (function declarations) واسط‌های خاصی با بررسی استاتیک برای توابع عضو و همچنین توابع مستقل ارائه می‌دهند، بنابراین از همه سبک‌های ذکر شده پشتیبانی می‌کنند. این اعلان‌ها برای بارگذاری بیش از حد ضروری هستند. در آن زمان، C از "نمونه‌های تابع" (function prototypes) برخوردار نبود، اما Simula هم اعلان‌های تابع و هم توابع عضو داشت.
- توابع جنریک و نوع‌های پارامتری (که از توابع و کلاس‌ها با استفاده از ماکروها تولید می‌شدند) از برنامه‌نویسی جنریک پشتیبانی می‌کنند. تمپلیت‌ها تا سال 1988 امکان‌پذیر نبودند.
- کلاس‌های پایه و مشتق‌شده بنیان برنامه‌نویسی شی‌گرا و برخی از اشکال انتزاع داده را فراهم می‌کنند. توابع مجازی (virtual functions) باید تا سال 1983 منتظر می‌ماندند.
- استفاده از قابلیت‌های درون‌خطی (inlining) این امکانات را در برنامه‌نویسی سیستمی و برای ساخت کتابخانه‌های بهینه از نظر زمان اجرا و فضای حافظه، مقرون به صرفه کرد.

این ویژگی‌های اولیه، مکانیسم‌های انتزاع کلی هستند، نه پشتیبانی از سبک‌های برنامه‌نویسی مجزا. C++ امروزی پشتیبانی بسیار بهتری برای طراحی و برنامه‌نویسی مبتنی بر انتزاع سبک ارائه می‌دهد، اما هدف از همان ابتدا کدنویسی زیبا و کارآمد بود. توسعه‌های از سال 1981 به بعد، پشتیبانی بهتری از ترکیب سبک‌های برنامه‌نویسی (یا «پارادایم‌ها») که در ابتدا مورد توجه بودند، فراهم کردند و به طور قابل توجهی به بهبود یکپارچگی آن‌ها کمک کردند.

در C++، یک شیء بنیادی دارای هویت است؛ به این معنی که در مکان مشخصی در حافظه قرار دارد و می‌توان آن را با مقایسه آدرس‌ها از دیگر اشیاء (که ممکن است ارزش یکسانی داشته باشند) تمایز داد. عبارات نمایانگر این اشیاء را lvalue می‌نامند. با این حال، حتی از اولین روزهای زبان‌های اجدادی C++ [Barron, 1963]، اشیایی نیز وجود داشته‌اند که بدون هویت هستند (اشیائی که آدرس آن‌ها نمی‌تواند به‌طور ایمن برای استفاده‌های بعدی ذخیره شود). در C++11، این مفهوم rvalue به یک مفهوم توسعه یافته تبدیل شد که به ما امکان می‌دهد مقدار را با هزینه کم جابه‌جا کنیم. چنین اشیائی پایه تکنیک‌هایی هستند که شبیه به برنامه‌نویسی تابعی هستند (جایی که مفهوم اشیاء با هویت به شدت مورد انتقاد قرار می‌گیرد). این موضوع به خوبی تکنیک‌ها و ویژگی‌های زبانی (مانند عبارات لامبدا) که عمدتاً برای برنامه‌نویسی جنریک توسعه یافته‌اند، تکمیل می‌کند. همچنین، مشکلات کلاسیکی مرتبط با «نوع‌های داده انتزاعی ساده» را حل می‌کند، مانند اینکه چگونه به شکلی زیبا و کارآمد یک ماتریس بزرگ را از یک عملیات (مثلاً ماتریس +) بازگردانیم.


از همان ابتدا، برنامه‌های C++ و طراحی خود C++ بر مدیریت منابع متمرکز بوده‌اند. هدف این بوده (و همچنان هست) که مدیریت منابع به این صورت باشد:

- ساده (برای پیاده‌سازان و به ویژه برای کاربران)،
- عمومی (هر منبعی که باید از جایی کسب شود و بعداً آزاد شود)،
- کارآمد (مطابق با اصل «بدون هزینه اضافی»؛ §1.2)،
- کامل (هیچ نشتی قابل قبول نیست)، و
- ایمن از نظر نوع ایستا.

بسیاری از کلاس‌های مهم C++، مانند کلاس‌های استاندارد کتابخانه‌ای از جمله vector، string، thread، mutex، unique_ptr، fstream و regex، به‌عنوان دستگیره‌های منابع عمل می‌کنند. کتابخانه‌های پایه و کاربردی فراتر از کتابخانه استاندارد نیز مثال‌های بسیاری ارائه کرده‌اند، مانند Matrix و Widget. اولین گام در پشتیبانی از مفهوم دستگیره‌های منابع با ارائه سازنده‌ها (constructors) و مخرب‌ها (destructors) در اولین پیش‌نویس «C with Classes» برداشته شد. به‌زودی این ویژگی با امکان کنترل کپی از طریق تعریف انتساب و سازنده‌های کپی پشتیبانی شد. معرفی سازنده‌های جابجایی (move constructors) و انتساب‌های جابجایی (move assignments) در C++11 این خط فکری را کامل کرد و امکان جابجایی ارزان اشیاء بزرگ از یک محدوده به محدوده دیگر و کنترل ساده عمر اشیاء چندشکلی (polymorphic) یا اشتراکی (shared) را فراهم کرد.

قابلیت‌هایی که از مدیریت منابع پشتیبانی می‌کنند، همچنین برای انتزاعاتی که دستگیره منابع نیستند نیز مفید هستند. هر کلاسی که یک ویژگی ثابت (invariant) را برقرار کرده و حفظ می‌کند، به مجموعه‌ای از این ویژگی‌ها وابسته است.

## Type Checking
ارتباط بین زبانی که در آن فکر یا برنامه‌نویسی می‌کنیم و مشکلات و راه‌حل‌هایی که می‌توانیم تصور کنیم بسیار نزدیک است. به همین دلیل، محدود کردن ویژگی‌های زبان با هدف از بین بردن خطاهای برنامه‌نویس، در بهترین حالت می‌تواند خطرناک باشد. یک زبان به برنامه‌نویس مجموعه‌ای از ابزارهای مفهومی ارائه می‌دهد؛ اگر این ابزارها برای یک کار ناکافی باشند، نادیده گرفته خواهند شد. طراحی خوب و نبود خطاها نمی‌تواند صرفاً با حضور یا عدم حضور ویژگی‌های خاص زبان تضمین شود. با این حال، ویژگی‌های زبان و سیستم نوع‌بندی (type system) برای برنامه‌نویس فراهم شده‌اند تا بتواند یک طراحی را به‌طور دقیق و مختصر در کد بیان کند.

مفهوم انواع استاتیک (static types) و بررسی نوع در زمان کامپایل نقش محوری در استفاده مؤثر از C++ دارد. استفاده از انواع استاتیک برای بیان‌پذیری، نگهداری‌پذیری، و عملکرد بسیار کلیدی است. پس از Simula، طراحی انواع تعریف‌شده توسط کاربر با واسط‌هایی که در زمان کامپایل بررسی می‌شوند، اساس بیان‌پذیری C++ را تشکیل می‌دهد. سیستم نوع‌بندی C++ به روش‌های غیر بدیهی قابل گسترش است و هدف آن پشتیبانی برابر از انواع داخلی و انواع تعریف‌شده توسط کاربر است.

ویژگی‌های بررسی نوع و پنهان‌سازی داده در C++ بر تحلیل زمان کامپایل برنامه‌ها تکیه دارند تا از فساد تصادفی داده جلوگیری کنند. این ویژگی‌ها برای حفاظت در برابر فردی که عمداً قوانین را زیر پا می‌گذارد، ارائه نشده‌اند: C++ از خطاهای تصادفی محافظت می‌کند، نه از تقلب. با این حال، می‌توان این ویژگی‌ها را بدون ایجاد هزینه‌های زمانی یا فضایی در زمان اجرا به‌طور آزاد استفاده کرد. ایده اصلی این است که یک ویژگی زبانی باید نه تنها زیبا باشد، بلکه در زمینه یک برنامه واقعی نیز مقرون‌به‌صرفه باشد.

سیستم نوع‌بندی استاتیک C++ انعطاف‌پذیر است و استفاده از انواع ساده تعریف‌شده توسط کاربر تقریباً هیچ هزینه‌ای ندارد. هدف این است که سبکی از برنامه‌نویسی را پشتیبانی کنیم که ایده‌های مجزا را به عنوان انواع مجزا نشان دهد، به‌جای اینکه به‌طور عمومی از انواع کلی مانند عدد صحیح، عدد اعشاری، رشته، «حافظه خام» یا «شیء» استفاده کنیم. سبک برنامه‌نویسی غنی از نوع (type-rich) باعث می‌شود که کد خواناتر، نگهداری‌پذیرتر و قابل تحلیل‌تر باشد. سیستم نوع‌بندی پیش‌پاافتاده فقط تحلیل‌های ساده‌ای را ممکن می‌کند، در حالی که سبک غنی از نوع فرصت‌هایی را برای کشف خطاهای پیچیده و بهینه‌سازی‌ها فراهم می‌کند. کامپایلرها و ابزارهای توسعه C++ از چنین تحلیلی مبتنی بر نوع پشتیبانی می‌کنند.

حفظ بیشتر زبان C به عنوان یک زیرمجموعه و حفظ نگاشت مستقیم به سخت‌افزار که برای وظایف برنامه‌نویسی سیستم‌های سطح پایین ضروری است، به معنی امکان نقض سیستم نوع استاتیک است. با این حال، ایده‌آل من (و همیشه هم بوده) امنیت کامل نوع است. در این مورد، من با دنیس ریچی موافقم که گفت: «C یک زبان با تایپ قوی و بررسی ضعیف است.» Simula هم ایمن از نظر نوع بود و هم انعطاف‌پذیر. در واقع، ایده‌آل من وقتی که C++ را شروع کردم، «Algol68 با کلاس‌ها» بود، نه «C با کلاس‌ها». با این حال، دلایل قوی و طولانی در برابر استفاده از Algol68 به عنوان پایه کار من وجود داشت. بنابراین، امنیت کامل نوع یک ایده‌آل است که C++ به عنوان یک زبان فقط می‌تواند به آن نزدیک شود. اما این ایده‌آلی است که برنامه‌نویسان C++ (به ویژه سازندگان کتابخانه‌ها) می‌توانند برای آن تلاش کنند.

در طول سال‌ها، مجموعه ویژگی‌های زبانی، اجزای کتابخانه استاندارد، و تکنیک‌های پشتیبانی‌کننده از این ایده‌آل گسترش یافته‌اند. به جز در بخش‌های سطح پایین کد (که امیدواریم با واسط‌های ایمن از نظر نوع جدا شده باشند)، کدهایی که با کدهایی که از قراردادهای زبانی متفاوتی پیروی می‌کنند (مانند واسط تماس سیستم‌عامل) تعامل دارند، و پیاده‌سازی انتزاعات بنیادی (مانند رشته و بردار)، اکنون نیاز کمی به کدهای ناامن از نظر نوع وجود دارد.

------------ 

عبارت **«C یک زبان با تایپ قوی و بررسی ضعیف است»** که توسط **دنیس ریچی**، خالق زبان C، بیان شده است، به یکی از جنبه‌های مهم طراحی زبان C اشاره دارد. این عبارت به این معنا است که اگرچه C دارای سیستم نوع‌بندی (typing system) قوی است و انواع داده‌ها به وضوح تعریف می‌شوند، اما بررسی تطابق نوع‌ها به طور کامل و دقیق توسط کامپایلر انجام نمی‌شود.

در اینجا، این دو مفهوم را بیشتر توضیح می‌دهم:

### 1. **تایپ قوی (Strong Typing)**:
این اصطلاح به این معنا است که هر داده در C باید به یک نوع مشخص تعلق داشته باشد و این نوع در طول اجرای برنامه باید رعایت شود. مثلاً، شما نمی‌توانید یک عدد صحیح (integer) را مستقیماً به عنوان یک اشاره‌گر (pointer) استفاده کنید یا بدون تبدیل مشخص نوع‌ها، بین انواع مختلف مثل عدد صحیح و عدد اعشاری (float) جابه‌جا شوید. این رفتار، نشانه‌ای از «تایپ قوی» است که مانع از انجام عملیات ناسازگار یا غیرمجاز بین انواع مختلف داده‌ها می‌شود.

### 2. **بررسی ضعیف (Weakly Checked)**:
این به معنای این است که سیستم بررسی نوع‌ها در C به اندازه کافی دقیق نیست تا همه تطابق‌های نادرست نوعی را در زمان کامپایل یا اجرا تشخیص دهد. زبان C به برنامه‌نویس اجازه می‌دهد تا برخی از قواعد نوع‌بندی را نقض کند یا به اصطلاح **نوع‌ها را به صورت صریح (explicit) تبدیل کند**. به عنوان مثال:
   - شما می‌توانید از عملگرهای تبدیل نوع (type casting) استفاده کنید تا یک نوع داده را به نوع دیگری تبدیل کنید. این می‌تواند در بعضی مواقع به اشتباهات جدی منجر شود، زیرا کامپایلر نمی‌تواند همیشه بررسی کند که آیا این تبدیل‌ها امن هستند یا خیر.
   - مثلاً، می‌توانید اشاره‌گری به عدد صحیح را به یک اشاره‌گر به یک نوع داده دیگر تبدیل کنید و کامپایلر C این را بدون اخطار یا بررسی دقیق قبول می‌کند، حتی اگر این کار منجر به خطاهای اجرایی شود.

### مثال‌هایی از بررسی ضعیف:
- شما می‌توانید یک اشاره‌گر به `int` را به یک اشاره‌گر به `float` تبدیل کنید. C چنین تبدیل‌هایی را به عنوان عملیات قانونی قبول می‌کند، هرچند ممکن است در زمان اجرا منجر به رفتار نادرست یا حتی خرابی برنامه شود.
- در زبان C، تابع‌ها نیازی ندارند که نوع ورودی و خروجی‌شان به‌طور دقیق بررسی شود (در نسخه‌های اولیه). مثلاً اگر تابعی انتظار یک `int` بگیرد اما شما `float` ارسال کنید، کامپایلر ممکن است اخطاری ندهد یا نوع را خودکار تبدیل کند.

### مقایسه با زبان‌های با تایپ و بررسی قوی‌تر:
در مقابل، زبان‌هایی با **تایپ و بررسی قوی‌تر** (مثل Python یا Java) در زمان کامپایل یا اجرا به دقت نوع‌ها را بررسی می‌کنند و از تبدیل‌های نادرست یا ناسازگار جلوگیری می‌کنند. در این زبان‌ها، تطابق نوع‌ها دقیق‌تر بررسی می‌شود و اغلب خطاهای نوعی که در C ممکن است در زمان اجرا اتفاق بیفتد، در این زبان‌ها در زمان کامپایل یا قبل از اجرا شناسایی می‌شود.

### نتیجه‌گیری:
بنابراین، جمله ریچی به این موضوع اشاره دارد که C یک زبان با سیستم نوع‌بندی مشخص و قدرتمند است، اما به برنامه‌نویس اجازه می‌دهد که در برخی مواقع این قوانین را دور بزند و از ابزارهایی استفاده کند که کامپایلر نمی‌تواند یا نمی‌خواهد به طور کامل و دقیق صحت آن‌ها را بررسی کند. این ویژگی باعث انعطاف‌پذیری بیشتر C برای برنامه‌نویسی در سطوح پایین (مانند کار با حافظه و سخت‌افزار) می‌شود، اما در عین حال می‌تواند باعث ایجاد مشکلات پیچیده و خطاهای پنهانی در برنامه شود.

--------------

**Simula** یک زبان برنامه‌نویسی است که در دهه 1960 توسط **اول-یوهان دال** و **کریستین نیگارد** در نروژ توسعه یافت. این زبان به عنوان اولین زبان برنامه‌نویسی شی‌گرا شناخته می‌شود و تأثیر قابل‌توجهی بر طراحی و توسعه زبان‌های برنامه‌نویسی مدرن مانند C++، Java و Python داشته است.

### ویژگی‌های کلیدی Simula:
1. **شی‌گرایی (Object-Oriented Programming)**:
   Simula اولین زبان بود که مفاهیم شی‌گرایی را معرفی کرد. در این زبان، **اشیاء (objects)** و **کلاس‌ها (classes)** برای مدل‌سازی اشیاء و موجودیت‌های واقعی به کار می‌رفتند. این مفهوم پایه‌ای برای برنامه‌نویسی شی‌گرا در زبان‌های مدرن است.

2. **کلاس‌ها و وراثت (Classes and Inheritance)**:
   Simula مفاهیمی مانند کلاس‌ها را معرفی کرد که به توسعه‌دهندگان اجازه می‌دادند **اشیاء** را با خصوصیات و رفتارهای مشخصی تعریف کنند. همچنین، مفهوم **وراثت (inheritance)** به توسعه‌دهندگان اجازه می‌داد تا کلاس‌های جدیدی بر اساس کلاس‌های موجود ایجاد کنند و رفتار آن‌ها را تغییر دهند یا توسعه دهند.

3. **مدل‌سازی و شبیه‌سازی (Simulation)**:
   هدف اولیه از توسعه Simula ساخت زبانی برای **شبیه‌سازی سیستم‌های پیچیده** بود، به خصوص سیستم‌های فیزیکی و اقتصادی. نام Simula نیز از «شبیه‌سازی» گرفته شده است. این زبان به کاربران اجازه می‌داد سیستم‌هایی را با استفاده از کلاس‌ها و اشیاء مدل‌سازی کنند که با دنیای واقعی تطابق دارند.

4. **وراثت و چندریختی (Inheritance and Polymorphism)**:
   Simula مفهوم وراثت را به همراه **چندریختی (polymorphism)** معرفی کرد، که به توسعه‌دهندگان اجازه می‌دهد تا متدهایی را به طور عمومی برای کلاس‌های مختلف پیاده‌سازی کنند.

### تأثیر Simula:
در Simula تأثیر بسیار عمیقی بر زبان‌های برنامه‌نویسی مدرن داشت. به طور خاص، **C++** که توسط **بیارن استراس‌تروپ** توسعه داده شد، بسیاری از مفاهیم اصلی Simula را مانند شی‌گرایی، کلاس‌ها و وراثت به ارث برده است. Simula همچنین الهام‌بخش زبان‌هایی مانند Java و Python شد، که هر دو بر پایه مفاهیم شی‌گرایی کار می‌کنند.

### Simula و کاربردهای اصلی آن:
در ابتدا Simula برای شبیه‌سازی سیستم‌های فیزیکی، اقتصادی و سازمانی طراحی شده بود. کاربران می‌توانستند رفتار سیستم‌ها را در محیطی مجازی شبیه‌سازی کنند و نتایج مختلف را مورد بررسی قرار دهند.

### نتیجه‌گیری:
در Simula یک زبان بسیار پیشگام و نوآور بود که پایه‌های شی‌گرایی را در دنیای برنامه‌نویسی بنیان نهاد. اگرچه امروز به ندرت از آن استفاده می‌شود، اما مفاهیم و اصولی که معرفی کرد، به‌طور گسترده در اکثر زبان‌های برنامه‌نویسی مدرن به کار گرفته می‌شود.

----------------

```
???
lvalue, rvalue
```

## C Compatibility
در ++C از زبان برنامه‌نویسی C توسعه یافته و با چند استثناء، همچنان C را به عنوان زیرمجموعه‌ای از خود حفظ کرده است. دلایل اصلی برای اتکا به C این بود که بتوان بر پایه مجموعه‌ای از امکانات زبان‌های سطح پایین که امتحان خود را پس داده‌اند، کار کرد و همچنین بخشی از یک جامعه‌ی فنی بود. اهمیت زیادی به حفظ درجه بالایی از سازگاری با C داده شد [Koenig, 1989] [Stroustrup, 1994] (فصل 44)؛ این موضوع (متأسفانه) مانع از پاکسازی و اصلاح سینتکس (دستور زبان) C شد. تکامل هم‌زمان و تقریباً موازی C و ++C به طور مداوم موجب نگرانی بوده و نیازمند توجه مداوم است [Stroustrup, 2002]. داشتن دو کمیته که به حفظ دو زبان پرکاربرد و "تا حد امکان سازگار" اختصاص یافته‌اند، روش چندان خوبی برای سازمان‌دهی کار نیست. به خصوص، تفاوت‌هایی در نظرها در مورد ارزش سازگاری وجود دارد، تفاوت‌هایی در نظرها در مورد آنچه برنامه‌نویسی خوب محسوب می‌شود و تفاوت‌هایی در نظرها در مورد پشتیبانی لازم برای برنامه‌نویسی خوب وجود دارد. تنها برقراری ارتباط بین این کمیته‌ها خود مقدار زیادی کار است.

سازگاری صد درصدی C/++C هرگز هدف ++C نبود، زیرا این امر باعث به خطر افتادن ایمنی نوع (type safety) و یکپارچگی روان بین انواع تعریف‌شده توسط کاربر و انواع داخلی می‌شد. با این حال، تعریف ++C بارها مورد بازبینی قرار گرفته است تا ناسازگاری‌های غیرضروری حذف شوند؛ اکنون ++C نسبت به گذشته با C سازگارتر است. ++C98 بسیاری از جزئیات C89 را پذیرفت (§44.3.1). وقتی C از C89 [C, 1990] به C99 [C, 1999] تکامل یافت، ++C تقریباً تمام ویژگی‌های جدید را پذیرفت و تنها آرایه‌های با طول متغیر (VLAs) را به عنوان یک ویژگی نامطلوب و مقداردهنده‌های مشخص را به عنوان ویژگی اضافی حذف کرد. امکانات C برای انجام وظایف برنامه‌نویسی سیستم‌های سطح پایین حفظ و بهبود یافته‌اند؛ به عنوان مثال، به "inline کردن" (§3.2.1.1, §12.1.5, §16.2.8) و constexpr (§2.2.3, §10.4, §12.1.6) مراجعه کنید.

به‌عکس، C مدرن بسیاری از ویژگی‌های ++C را با درجات مختلفی از دقت و کارآمدی پذیرفته است (مانند `const`، پروتوتایپ‌های تابع، و inlining؛ به [Stroustrup, 2002] مراجعه کنید). تعریف ++C بازبینی شده است تا اطمینان حاصل شود که ساختاری که هم در C و هم در ++C قانونی است، در هر دو زبان معنای یکسانی داشته باشد (§44.3).

یکی از اهداف اولیه زبان C این بود که جایگزین کدنویسی اسمبلی برای وظایف برنامه‌نویسی سیستم‌های سطح بالا و پیچیده شود. هنگام طراحی ++C، دقت شد که این دستاوردها در این حوزه به خطر نیفتد. تفاوت اصلی بین C و ++C در میزان تأکید بر نوع‌ها (types) و ساختار است. C زبانی انعطاف‌پذیر و پر از آزادی عمل است. ++C با استفاده گسترده از سیستم نوع‌ها، حتی بیانگرتر از C است، بدون اینکه عملکرد را از دست بدهد.

دانستن زبان C پیش‌نیازی برای یادگیری ++C نیست. برنامه‌نویسی در C بسیاری از تکنیک‌ها و ترفندهایی را تشویق می‌کند که با ویژگی‌های زبان ++C غیرضروری می‌شوند. برای مثال، تبدیل نوع صریح (casting) در ++C کمتر از C مورد نیاز است (§1.3.3). با این حال، برنامه‌های خوب C معمولاً برنامه‌های ++C نیز هستند. برای مثال، هر برنامه‌ای در کتاب **Kernighan and Ritchie**، زبان برنامه‌نویسی C، ویرایش دوم [Kernighan, 1988]، یک برنامه ++C نیز هست. تجربه با هر زبان نوع‌گذاری استاتیک در یادگیری ++C کمک‌کننده خواهد بود.

## Language, Libraries, and Systems
انواع بنیادی (داخلی) ++C، عملگرها و دستورات آن، مواردی هستند که سخت‌افزار کامپیوتر به طور مستقیم با آنها سر و کار دارد: اعداد، کاراکترها، و آدرس‌ها. ++C هیچ نوع داده سطح بالای داخلی و هیچ عملگر اولیه سطح بالایی ندارد. به عنوان مثال، زبان ++C نوع ماتریس با عملگر معکوس یا نوع رشته با عملگر الحاق ارائه نمی‌دهد. اگر کاربری به چنین نوعی نیاز داشته باشد، می‌تواند آن را در خود زبان تعریف کند. در واقع، تعریف یک نوع عمومی یا نوع خاص برنامه جدید، بنیادی‌ترین فعالیت برنامه‌نویسی در ++C است. یک نوع تعریف‌شده توسط کاربر که به‌خوبی طراحی شده باشد، فقط از نظر نحوه تعریف با نوع داخلی تفاوت دارد، نه از نظر نحوه استفاده. کتابخانه استاندارد ++C (فصل 4، فصل 5، فصل 30، فصل 31، و غیره) بسیاری از مثال‌های چنین نوع‌ها و کاربردهای آنها را فراهم می‌کند. از دید کاربر، تفاوت چندانی بین یک نوع داخلی و یک نوع ارائه‌شده توسط کتابخانه استاندارد وجود ندارد. به‌جز چند حادثه تاریخی ناگوار و کم‌اهمیت، کتابخانه استاندارد ++C به زبان ++C نوشته شده است. نوشتن کتابخانه استاندارد ++C به زبان ++C یک آزمون اساسی برای سیستم نوع‌ها و مکانیسم‌های انتزاعی ++C است: این مکانیسم‌ها باید به اندازه کافی قدرتمند (بیانگر) و کارا (مقرون‌به‌صرفه) برای دشوارترین وظایف برنامه‌نویسی سیستم‌ها باشند، و همین‌طور هم هستند. این تضمین می‌کند که آنها می‌توانند در سیستم‌های بزرگ که معمولاً از لایه‌های مختلف انتزاع تشکیل شده‌اند، مورد استفاده قرار گیرند.

ویژگی‌هایی که حتی زمانی که استفاده نمی‌شدند باعث سربار زمانی یا حافظه‌ای می‌شدند، اجتناب شده‌اند. برای مثال، ساختارهایی که نیازمند ذخیره «اطلاعات نگهداری» در هر شیء بودند، رد شدند. بنابراین اگر کاربری ساختاری را تعریف کند که از دو مقدار 16 بیتی تشکیل شده باشد، آن ساختار در یک رجیستر 32 بیتی جا می‌شود. به‌جز عملگرهای new، delete، typeid، dynamic_cast، و throw، و بلاک try، عبارات و دستورات فردی ++C به هیچ پشتیبانی در زمان اجرا نیاز ندارند. این امر می‌تواند برای برنامه‌های کاربردی توکار (embedded) و با کارایی بالا ضروری باشد. به طور خاص، این بدان معناست که مکانیسم‌های انتزاعی ++C برای برنامه‌های توکار، با کارایی بالا، با قابلیت اطمینان بالا و برنامه‌های زمان واقعی قابل استفاده هستند. بنابراین، برنامه‌نویسان چنین برنامه‌هایی مجبور نیستند با مجموعه‌ای از ویژگی‌های سطح پایین (مستعد خطا، محدود و کم‌بازده) زبان کار کنند.

-----------
```
???
housekeeping information
```

در ++C برای استفاده در محیط‌های سنتی کامپایل و زمان اجرا طراحی شده بود: محیط برنامه‌نویسی C در سیستم UNIX [UNIX, 1985]. خوشبختانه، ++C هرگز به UNIX محدود نشد؛ بلکه به سادگی از UNIX و C به عنوان الگویی برای روابط بین زبان، کتابخانه‌ها، کامپایلرها، لینک‌کننده‌ها، محیط‌های اجرا و غیره استفاده کرد. این مدل حداقلی به ++C کمک کرد تا تقریباً در هر پلتفرم محاسباتی موفق باشد. با این حال، دلایل خوبی برای استفاده از ++C در محیط‌هایی که پشتیبانی بیشتری در زمان اجرا ارائه می‌دهند، وجود دارد. امکاناتی مانند بارگذاری پویا، کامپایل تدریجی، و یک پایگاه داده از تعاریف نوع می‌توانند بدون تأثیر بر خود زبان به خوبی مورد استفاده قرار گیرند.

هر قطعه کدی نمی‌تواند به‌خوبی ساختار یافته، مستقل از سخت‌افزار، و آسان برای خواندن باشد. ++C ویژگی‌هایی دارد که برای دستکاری امکانات سخت‌افزاری به‌طور مستقیم و کارآمد طراحی شده‌اند، بدون توجه به ایمنی یا سهولت درک. همچنین، امکاناتی برای پنهان کردن چنین کدی پشت رابط‌های زیبا و ایمن وجود دارد.

طبیعی است که استفاده از ++C برای برنامه‌های بزرگتر منجر به استفاده از این زبان توسط گروه‌های برنامه‌نویس شود. تأکید ++C بر ماژولار بودن، رابط‌های strongly typed و انعطاف‌پذیری در این زمینه مؤثر است. با این حال، با بزرگ‌تر شدن برنامه‌ها، مشکلات مربوط به توسعه و نگهداری آنها از مشکلات زبان به مشکلات کلی‌تر ابزار و مدیریت تبدیل می‌شوند.

این کتاب بر تکنیک‌هایی تأکید می‌کند که به ارائه امکانات عمومی، انواع مفید عمومی، کتابخانه‌ها و غیره می‌پردازند. این تکنیک‌ها به برنامه‌نویسان برنامه‌های کوچک و همچنین به برنامه‌نویسان برنامه‌های بزرگ کمک خواهند کرد. علاوه بر این، از آنجا که همه برنامه‌های غیرساده از بسیاری از بخش‌های نیمه‌مستقل تشکیل شده‌اند، تکنیک‌های نوشتن چنین بخش‌هایی به برنامه‌نویسان تمامی کاربردها خدمت می‌کند.

من از پیاده‌سازی و استفاده از اجزای کتابخانه استاندارد، مانند `vector`، به عنوان مثال استفاده می‌کنم. این موضوع اجزای کتابخانه و مفاهیم طراحی و تکنیک‌های پیاده‌سازی زیرین آنها را معرفی می‌کند. چنین مثال‌هایی نشان می‌دهند که چگونه برنامه‌نویسان ممکن است کتابخانه‌های خود را طراحی و پیاده‌سازی کنند. با این حال، اگر کتابخانه استاندارد جزئی را ارائه دهد که یک مشکل را حل کند، تقریباً همیشه بهتر است از آن جز استفاده کنید تا اینکه خودتان آن را بسازید. حتی اگر جز استاندارد به لحاظ کمی از یک جز سفارشی برای یک مشکل خاص ضعیف‌تر به نظر برسد، احتمالاً جز استاندارد از لحاظ کاربرد، دسترسی و شناخت عمومی بیشتر است. در بلندمدت، جز استاندارد (که احتمالاً از طریق یک رابط سفارشی مناسب به آن دسترسی پیدا می‌شود) به احتمال زیاد هزینه‌های نگهداری، جابجایی، بهینه‌سازی و آموزش را کاهش خواهد داد.

شاید شما فکر کنید که مشخص کردن یک برنامه با استفاده از یک ساختار نوعی دقیق‌تر، اندازه متن منبع برنامه (یا حتی اندازه کد تولیدشده) را افزایش می‌دهد. اما در مورد ++C، اینطور نیست. یک برنامه ++C که نوع‌های آرگومان تابع را اعلام می‌کند و از کلاس‌ها استفاده می‌کند، معمولاً کمی کوتاه‌تر از برنامه معادل C است که از این امکانات استفاده نمی‌کند. جایی که از کتابخانه‌ها استفاده می‌شود، یک برنامه ++C به مراتب کوتاه‌تر از معادل C خود به نظر می‌رسد، به شرطی که البته یک معادل کارا در C بتوان ساخته شود.

در ++C از برنامه‌نویسی سیستم پشتیبانی می‌کند. این به این معنی است که کد ++C قادر است به‌طور مؤثر با نرم‌افزاری که به زبان‌های دیگر در یک سیستم نوشته شده، تعامل داشته باشد. ایده نوشتن تمام نرم‌افزارها به یک زبان، یک خیال باطل است. از ابتدای طراحی، ++C برای تعامل ساده و کارآمد با C، اسمبلی و Fortran طراحی شده بود. به این معنی که یک تابع در ++C، C، اسمبلی یا Fortran می‌تواند بدون سربار اضافی یا تبدیل ساختارهای داده‌ای که بین آنها منتقل می‌شود، توابعی را در زبان‌های دیگر فراخوانی کند.

در ++C طوری طراحی شده است که در یک فضای آدرس واحد عمل کند. استفاده از چندین فرآیند و چندین فضای آدرس به پشتیبانی (خارج از زبان) سیستم‌عامل وابسته بود. به‌ویژه، من فرض کردم که یک برنامه‌نویس ++C زبان فرمان سیستم‌عامل را برای ترکیب فرآیندها در یک سیستم در دسترس خواهد داشت. در ابتدا، من به شل UNIX برای این منظور متکی بودم، اما تقریباً هر «زبان اسکریپت» دیگری نیز مناسب است. بنابراین، ++C هیچ پشتیبانی برای چندین فضای آدرس و هیچ پشتیبانی برای چندین فرآیند ارائه نمی‌دهد، اما از اولین روزها برای سیستم‌هایی که به این ویژگی‌ها وابسته بودند، استفاده شد. ++C به‌گونه‌ای طراحی شده است که بخشی از سیستم‌های بزرگ، همزمان و چندزبانه باشد.

این متن درباره طراحی زبان برنامه‌نویسی C++ و تعامل آن با سیستم‌عامل‌ها توضیح می‌دهد. بیایید آن را دقیق‌تر و واضح‌تر بررسی کنیم:

### 1. فضای آدرس واحد
- **تعریف**: زبان C++ به گونه‌ای طراحی شده که همه برنامه‌ها و داده‌ها در یک فضای آدرس حافظه مشترک قرار دارند.
- **مفهوم**: این بدان معنی است که تمامی اطلاعات و متغیرها در یک ناحیه حافظه مشخص قرار می‌گیرند و هیچ تقسیم‌بندی خاصی برای جدا کردن حافظه بین برنامه‌ها وجود ندارد.

### 2. عدم پشتیبانی داخلی از چند پردازه
- **چند پردازه**: به معنای اجرای همزمان چندین برنامه (یا پردازه) در یک سیستم است.
- **فضای آدرس چندگانه**: یعنی هر پردازه می‌تواند فضای حافظه جداگانه‌ای داشته باشد.
- **محدودیت C++**: زبان C++ به طور مستقیم قابلیت مدیریت پردازه‌های متعدد یا فضای حافظه جداگانه برای هر پردازه را ندارد.

### 3. نیاز به سیستم‌عامل
- **پشتیبانی سیستم‌عامل**: برای استفاده از قابلیت‌های چند پردازه و مدیریت فضای آدرس‌های جداگانه، برنامه‌نویسان C++ باید از امکانات سیستم‌عامل خود استفاده کنند.
- **زبان‌های اسکریپتی**: برنامه‌نویسان می‌توانند از زبان‌های اسکریپتی (مانند شل UNIX) استفاده کنند تا پردازه‌ها را مدیریت کرده و با سیستم‌عامل تعامل داشته باشند.

### 4. استفاده از شل UNIX
- **شل UNIX**: این یک ابزار خط فرمان است که به کاربران اجازه می‌دهد دستورات را اجرا کنند و پردازه‌ها را کنترل کنند.
- **مثال**: در سیستم‌های UNIX، از شل برای راه‌اندازی، متوقف کردن و مدیریت پردازه‌ها استفاده می‌شود.

### 5. سیستم‌های چند زبانه و هم‌زمان
- **طراحی برای همکاری**: C++ طوری طراحی شده که در سیستم‌های بزرگ و پیچیده‌ای که ممکن است شامل چند زبان برنامه‌نویسی باشند، استفاده شود.
- **مفهوم**: این به معنای این است که C++ می‌تواند با سایر زبان‌ها (مثل Python یا Java) در یک پروژه کار کند و نقش مهمی در ساخت نرم‌افزارهای پیچیده ایفا کند.

### نتیجه‌گیری
به طور خلاصه، C++ به عنوان یک زبان برنامه‌نویسی طراحی شده است که در یک فضای حافظه مشترک کار می‌کند و برای مدیریت چند پردازه و فضای آدرس‌های جداگانه، به پشتیبانی و امکانات سیستم‌عامل نیاز دارد. بنابراین، C++ برای ساخت سیستم‌های بزرگ و چند زبانه که نیاز به هم‌زمانی و همکاری دارند، مناسب است.


# Learning C++
هیچ زبان برنامه‌نویسی کاملی وجود ندارد. خوشبختانه، یک زبان برنامه‌نویسی برای این که یک ابزار خوب برای ساخت سیستم‌های عالی باشد، نیازی به کامل بودن ندارد. در واقع، یک زبان برنامه‌نویسی عمومی نمی‌تواند برای تمام وظایف متعددی که به آن سپرده می‌شود، کامل باشد. آنچه برای یک وظیفه کامل است، اغلب برای وظیفه دیگری نقص جدی دارد، زیرا کامل بودن در یک زمینه به معنای تخصصی شدن است. بنابراین، زبان C++ به گونه‌ای طراحی شده است که یک ابزار خوب برای ساخت طیف گسترده‌ای از سیستم‌ها باشد و اجازه دهد که ایده‌های متنوع به‌طور مستقیم بیان شوند.

همه چیز را نمی‌توان به‌طور مستقیم با استفاده از ویژگی‌های داخلی یک زبان بیان کرد. در واقع، این حتی هدف ایده‌آل هم نیست. ویژگی‌های زبان وجود دارند تا از سبک‌ها و تکنیک‌های مختلف برنامه‌نویسی پشتیبانی کنند. بنابراین، وظیفه یادگیری یک زبان باید بر تسلط بر سبک‌های بومی و طبیعی آن زبان متمرکز باشد، نه بر درک هر جزئیات کوچکی از هر ویژگی زبان. نوشتن برنامه‌ها ضروری است؛ درک یک زبان برنامه‌نویسی فقط یک تمرین فکری نیست. کاربرد عملی ایده‌ها لازم است.

هیچ سیستم مهمی به‌طور انحصاری با استفاده از ویژگی‌های خود زبان ساخته نمی‌شود. ما کتابخانه‌ها را برای ساده‌تر کردن وظیفه برنامه‌نویسی و افزایش کیفیت سیستم‌های خود می‌سازیم و استفاده می‌کنیم. ما از کتابخانه‌ها برای بهبود قابلیت نگهداری، قابلیت حمل و عملکرد استفاده می‌کنیم. مفاهیم بنیادی کاربردها به‌صورت انتزاعی (مثلاً کلاس‌ها، الگوها و سلسله‌مراتب کلاس‌ها) در کتابخانه‌ها نمایش داده می‌شوند. بسیاری از مفاهیم اساسی برنامه‌نویسی در کتابخانه استاندارد ارائه شده‌اند. بنابراین، یادگیری کتابخانه استاندارد بخش جدایی‌ناپذیر از یادگیری C++ است. کتابخانه استاندارد مخزنی از دانش ارزشمندی است که در مورد نحوه استفاده بهینه از C++ به دست آمده است.

باید اشاره کرد که C++ کوچک‌ترین یا پاک‌ترین زبان طراحی‌شده تا به حال نیست. با این حال، این زبان:

- به اندازه کافی ساختار یافته است تا مفاهیم پایه طراحی و برنامه‌نویسی را به‌طور موفقیت‌آمیز آموزش دهد.
- به اندازه کافی جامع است تا بستری برای آموزش مفاهیم و تکنیک‌های پیشرفته باشد.
- به اندازه کافی واقع‌گرایانه، کارآمد و انعطاف‌پذیر است تا برای پروژه‌های پیچیده و سنگین مناسب باشد.
- به اندازه کافی تجاری است تا آنچه آموخته می‌شود، در استفاده‌های غیردانشگاهی به کار رود.
- به اندازه کافی در دسترس است تا برای سازمان‌ها و همکاری‌هایی که به محیط‌های توسعه و اجرا متنوع متکی هستند، مناسب باشد.

مهم‌ترین کاری که هنگام یادگیری C++ باید انجام دهید، تمرکز بر مفاهیم اساسی (مانند ایمنی نوع، مدیریت منابع و پایستگی‌ها) و تکنیک‌های برنامه‌نویسی (مانند مدیریت منابع با استفاده از اشیاء محلی و استفاده از پیمایشگرها در الگوریتم‌ها) است و نباید در جزئیات فنی زبان گم شوید. هدف از یادگیری یک زبان برنامه‌نویسی، تبدیل شدن به یک برنامه‌نویس بهتر است، یعنی کارآمدتر شدن در طراحی و پیاده‌سازی سیستم‌های جدید و نگهداری سیستم‌های قدیمی. برای این منظور، درک تکنیک‌های برنامه‌نویسی و طراحی بسیار مهم‌تر از تسلط بر همه جزئیات فنی است. درک این جزئیات با گذر زمان و تمرین به دست می‌آید.

برنامه‌نویسی C++ بر اساس بررسی قوی نوع ایستا (static type checking) استوار است و بیشتر تکنیک‌ها هدفشان دستیابی به سطح بالایی از انتزاع و نمایش مستقیم ایده‌های برنامه‌نویس است. این کار معمولاً بدون به خطر انداختن کارایی زمان اجرا و فضای حافظه، در مقایسه با تکنیک‌های سطح پایین‌تر، انجام می‌شود. برای بهره‌گیری از مزایای C++، برنامه‌نویسانی که از زبان‌های دیگر به آن می‌آیند، باید سبک و تکنیک‌های خاص و رایج برنامه‌نویسی C++ را یاد بگیرند و درونی کنند. همین موضوع برای برنامه‌نویسانی که به نسخه‌های قدیمی‌تر و کمتر بیان‌گرای C++ عادت دارند، صدق می‌کند.

به‌کارگیری بی‌فکرانه تکنیک‌هایی که در یک زبان موثر هستند در زبانی دیگر، معمولاً به کدهای نامناسب، با کارایی ضعیف و سخت برای نگهداری منجر می‌شود. نوشتن چنین کدی همچنین بسیار آزاردهنده است، زیرا هر خط کد و هر پیام خطای کامپایلر به برنامه‌نویس یادآوری می‌کند که زبان مورد استفاده با "زبان قدیمی" متفاوت است. شما می‌توانید به سبک Fortran، C، Lisp، Java و غیره در هر زبانی کدنویسی کنید، اما انجام این کار در زبانی با فلسفه‌ای متفاوت نه لذت‌بخش است و نه اقتصادی. هر زبان می‌تواند منبعی پر بار از ایده‌ها برای نوشتن برنامه‌های C++ باشد، اما این ایده‌ها باید به شکلی تبدیل شوند که با ساختار کلی و سیستم نوع C++ سازگار باشد تا در این زبان موثر باشند. پیروزی در برابر سیستم نوع یک زبان تنها به قیمت شکست در اصول اساسی ممکن است (پیروزی پیروس).

بهترین راه این است که مستقیماً به سراغ C++ بروید. C++ ایمن‌تر و بیان‌گراتر است و نیاز به تمرکز بر تکنیک‌های سطح پایین را کاهش می‌دهد. یادگیری بخش‌های پیچیده‌تر زبان C که برای جبران فقدان امکانات سطح بالاتر آن لازم است، پس از آنکه با بخش‌های مشترک C و C++ و برخی از تکنیک‌های سطح بالاتر که به‌طور مستقیم در C++ پشتیبانی می‌شوند آشنا شدید، آسان‌تر خواهد بود. فصل 44 راهنمایی برای برنامه‌نویسانی است که از C++ به C می‌روند، مثلاً برای کار با کدهای قدیمی. نظر من درباره نحوه آموزش C++ به مبتدیان در [Stroustrup, 2008] آمده است.

چندین پیاده‌سازی مستقل از C++ وجود دارد که توسط مجموعه‌ای غنی از ابزارها، کتابخانه‌ها و محیط‌های توسعه نرم‌افزار پشتیبانی می‌شوند. برای کمک به تسلط بر همه این‌ها، می‌توانید از کتاب‌های درسی، راهنماها و منابع آنلاین بسیار متنوعی استفاده کنید. اگر قصد دارید C++ را به‌طور جدی استفاده کنید، به شدت پیشنهاد می‌کنم که به چندین منبع از این دست دسترسی پیدا کنید. هر منبع تمرکز و دیدگاه خاص خود را دارد، بنابراین حداقل از دو منبع مختلف استفاده کنید.

## Programming in C++
پرسش "چگونه می‌توان برنامه‌های خوب در C++ نوشت؟" بسیار شبیه به پرسش "چگونه می‌توان نثر انگلیسی خوبی نوشت؟" است. دو پاسخ برای آن وجود دارد: "بدانید که چه می‌خواهید بگویید" و "تمرین کنید. نوشتار خوب را تقلید کنید." هر دو پاسخ به همان اندازه که برای C++ مناسب هستند، برای زبان انگلیسی هم کاربرد دارند – و به همان اندازه پیروی از آن‌ها دشوار است.

ایده‌آل اصلی برای برنامه‌نویسی در C++ – همانند بیشتر زبان‌های سطح بالا – این است که مفاهیم (ایده‌ها، تصورات، و غیره) یک طراحی را مستقیماً در کد بیان کنیم. ما سعی می‌کنیم اطمینان حاصل کنیم که مفاهیمی که درباره آن‌ها صحبت می‌کنیم، آن‌ها را با جعبه‌ها و پیکان‌ها روی تخته‌سفید خود نشان می‌دهیم و در کتاب‌های غیربرنامه‌نویسی خود می‌یابیم، معادل‌های مستقیم و واضحی در برنامه‌های ما دارند.

در ادامه، چندین اصل مهم برای نوشتن برنامه‌های خوب در C++ بیان شده است:

1. **ایده‌ها را به‌طور مستقیم در کد بیان کنید.**
2. **روابط میان ایده‌ها را به‌طور مستقیم در کد نمایش دهید** (مثلاً، روابط سلسله‌مراتبی، پارامتریک و مالکیتی).
3. **ایده‌های مستقل را به‌طور مستقل در کد نمایان کنید.**
4. **چیزهای ساده را ساده نگه‌دارید** (بدون اینکه چیزهای پیچیده را غیرممکن کنید).

به‌طور خاص‌تر:

5. **راه‌حل‌های با بررسی نوع ایستا را ترجیح دهید** (در مواقعی که قابل اعمال باشد).
6. **اطلاعات را محلی نگه‌دارید** (مثلاً، از متغیرهای جهانی پرهیز کنید و از استفاده بیش از حد از اشاره‌گرها بکاهید).
7. **زیاد انتزاع نکنید** (یعنی، فراتر از نیازها و تجربیات واضح، تعمیم ندهید، سلسله‌مراتب کلاسی ایجاد نکنید یا پارامترسازی نکنید).

توصیه‌های مشخص‌تری در بخش §1.3.2 ارائه شده است.

## Suggestions for C++ Programmers
اکنون بسیاری از افراد به مدت یک یا دو دهه است که از C++ استفاده می‌کنند. بسیاری دیگر در یک محیط خاص از C++ استفاده کرده و یاد گرفته‌اند با محدودیت‌های ایجاد شده توسط کامپایلرهای اولیه و کتابخانه‌های نسل اول زندگی کنند. اغلب، آنچه که یک برنامه‌نویس باتجربه C++ در طول سال‌ها متوجه نشده است، نه معرفی ویژگی‌های جدید به‌طور خاص، بلکه تغییرات در روابط میان ویژگی‌هاست که تکنیک‌های جدید برنامه‌نویسی بنیادی را ممکن می‌سازد. به عبارت دیگر، آنچه را که هنگام یادگیری اولیه C++ به آن فکر نکردید یا آن را غیرعملی یافتید، ممکن است امروز رویکردی برتر باشد. شما تنها با بازنگری در مبانی متوجه خواهید شد.

فصول کتاب را به ترتیب مطالعه کنید. اگر از محتوای یک فصل آگاه هستید، ممکن است در عرض چند دقیقه به پایان برسانید. اگر از محتوای آن آگاه نیستید، چیزی غیرمنتظره یاد خواهید گرفت. من در حین نوشتن این کتاب اطلاعات زیادی کسب کردم و مشکوکم که تقریباً هیچ برنامه‌نویس C++ همه ویژگی‌ها و تکنیک‌های ارائه‌شده را نمی‌شناسد. علاوه بر این، برای استفاده مؤثر از زبان، نیاز به دیدگاهی دارید که به مجموعه ویژگی‌ها و تکنیک‌ها نظم ببخشد. این کتاب از طریق سازماندهی و مثال‌های خود چنین دیدگاهی را ارائه می‌دهد.

از امکانات جدید C++11 برای مدرن‌سازی تکنیک‌های طراحی و برنامه‌نویسی خود بهره ببرید:

1. **از سازنده‌ها برای ایجاد پایستگی‌ها استفاده کنید** (§2.4.3.2, §13.4, §17.2.1).
2. **از جفت‌های سازنده/ویرانگر برای ساده‌سازی مدیریت منابع استفاده کنید** (RAII; §5.2, §13.3).
3. **از new و delete بدون هیچ پوششی پرهیز کنید** (§3.2.1.2, §11.2.1).
4. **از контейنرها و الگوریتم‌ها به جای آرایه‌های داخلی و کدهای موردی استفاده کنید** (§4.4, §4.5, §7.4, فصل 32).
5. **امکانات کتابخانه استاندارد را به کدهای محلی ترجیح دهید** (§1.2.4).
6. **از استثناها، به جای کدهای خطا، برای گزارش خطاهایی که نمی‌توان به‌طور محلی مدیریت کرد، استفاده کنید** (§2.4.3, §13.1).
7. **از معنای جابجایی برای جلوگیری از کپی کردن اشیاء بزرگ استفاده کنید** (§3.3.2, §17.5.2).
8. **از unique_ptr برای اشاره به اشیاء نوع چندشکلی استفاده کنید** (§5.2.1).
9. **از shared_ptr برای اشاره به اشیاء مشترک، یعنی اشیائی بدون مالک واحد که مسئول تخریب آن‌ها هستند، استفاده کنید** (§5.2.1).
10. **از الگوها برای حفظ ایمنی نوع استاتیک (حذف تبدیل‌ها) و جلوگیری از استفاده غیرضروری از سلسله‌مراتب‌های کلاسی استفاده کنید** (§27.2).

همچنین ممکن است ایده خوبی باشد که مشاوره‌های مربوط به برنامه‌نویسان C و Java را مرور کنید (§1.3.3, §1.3.4).


## Suggestions for C Programmers
هر چه فردی C را بهتر بشناسد، به نظر می‌رسد دشوارتر باشد که از نوشتن C++ به سبک C اجتناب کند و بدین ترتیب بسیاری از مزایای بالقوه C++ را از دست بدهد. لطفاً به فصل 44 نگاهی بیندازید که تفاوت‌های بین C و C++ را توصیف می‌کند.

1. **C++ را به عنوان C با چند ویژگی اضافی در نظر نگیرید.** می‌توان C++ را به این شکل استفاده کرد، اما این فقط به‌طور زیر بهینه است. برای به‌دست آوردن مزایای واقعی C++ نسبت به C، نیاز است که سبک‌های طراحی و پیاده‌سازی متفاوتی را به‌کار ببرید.

2. **در C++ به سبک C ننویسید؛** این معمولاً برای نگهداری و عملکرد به‌شدت زیر بهینه است.

3. **از کتابخانه استاندارد C++ به عنوان معلمی برای تکنیک‌ها و سبک‌های برنامه‌نویسی جدید استفاده کنید.** به تفاوت آن با کتابخانه استاندارد C توجه کنید (برای مثال، استفاده از `=` به جای `strcpy()` برای کپی و `==` به جای `strcmp()` برای مقایسه).

4. **استفاده از جایگزینی ماکرو تقریباً هرگز در C++ ضروری نیست.** از `const` (§7.5)، `constexpr` (§2.2.3, §10.4)، `enum` یا `enum class` (§8.4) برای تعریف ثابت‌های مانفیست، `inline` (§12.1.5) برای جلوگیری از اضافه‌بار فراخوانی تابع، الگوها (§3.4, فصل 23) برای مشخص کردن خانواده‌های تابع و نوع‌ها، و فضای نام (§2.4.2, §14.3.1) برای جلوگیری از تداخل نام‌ها استفاده کنید.

5. **متغیرها را قبل از نیاز به آن‌ها اعلام نکنید و بلافاصله مقداردهی اولیه کنید.** یک اعلام می‌تواند هرجا که یک عبارت می‌تواند (§9.3) اتفاق بیفتد، در مقداردهی اولیه در حلقه for (§9.5) و در شرایط (§9.4.3) صورت بگیرد.

6. **از `malloc()` استفاده نکنید.** عملگر `new` (§11.2) همان کار را بهتر انجام می‌دهد و به جای `realloc()`، از یک `vector` (§3.4.2) استفاده کنید. فقط `malloc()` و `free()` را با `new` و `delete` بدون پوشش جایگزین نکنید (§3.2.1.2, §11.2.1).

7. **از `void*`، اتحادها و تبدیل‌ها اجتناب کنید،** مگر در عمق پیاده‌سازی برخی از توابع یا کلاس‌ها. استفاده از آن‌ها پشتیبانی‌ای را که می‌توانید از سیستم نوع بگیرید محدود می‌کند و می‌تواند بر عملکرد تأثیر بگذارد. در بیشتر موارد، یک تبدیل نشانه‌گذار یک خطای طراحی است. اگر مجبورید از یک تبدیل نوع صریح استفاده کنید، سعی کنید از یکی از تبدیل‌های نام‌گذاری‌شده (برای مثال، `static_cast`; §11.5.2) برای بیان دقیق‌تر آنچه می‌خواهید انجام دهید، استفاده کنید.

8. **استفاده از آرایه‌ها و رشته‌های به سبک C را به حداقل برسانید.** رشته‌های کتابخانه استاندارد C++ (§4.2)، آرایه‌ها (§8.2.4) و `vector`ها (§4.4.1) می‌توانند معمولاً برای نوشتن کد ساده‌تر و قابل نگهداری‌تر استفاده شوند نسبت به سبک سنتی C. به‌طور کلی، سعی کنید چیزی را که توسط کتابخانه استاندارد ارائه شده است، دوباره نساخته و از خودتان نسازید.

9. **از حساب‌های اشاره‌گر اجتناب کنید** مگر در کدهای بسیار تخصصی (مانند یک مدیر حافظه) و برای عبور ساده از آرایه‌ها (به‌عنوان مثال، `++p`).

10. **فرض نکنید که چیزی که به‌طور سخت‌کوشانه به سبک C نوشته شده (اجتناب از ویژگی‌های C++ مانند کلاس‌ها، الگوها و استثناها) کارآمدتر از یک گزینه کوتاه‌تر است** (برای مثال، استفاده از امکانات کتابخانه استاندارد). اغلب (اما البته نه همیشه)، عکس این موضوع صحیح است.

برای رعایت کنوانسیون‌های لینک C، یک تابع C++ باید به‌گونه‌ای اعلام شود که لینک C داشته باشد (§15.2.5).


## Suggestions for Jav a Programmers
در C++ و Java زبان‌ها از نظر سینتکس بسیار شبیه هستند، اما اهداف و دامنه‌های کاربرد آن‌ها به‌طور قابل توجهی متفاوت است. جاوا جانشین مستقیم C++ نیست به معنای زبانی که می‌تواند همان کارهایی را که پیشینیانش انجام می‌دهند، بهتر و بیشتر انجام دهد. برای استفاده مؤثر از C++، باید تکنیک‌های برنامه‌نویسی و طراحی مناسب با C++ را بپذیرید، نه اینکه سعی کنید جاوا را در C++ بنویسید. این تنها مسئله به یادآوری حذف اشیایی که با `new` ایجاد کرده‌اید نیست زیرا نمی‌توانید به وجود یک جمع‌کننده زباله اتکا کنید:

1. **تنها از سبک جاوا در C++ تقلید نکنید؛** این معمولاً برای نگهداری و عملکرد به‌شدت زیر بهینه است.

2. **از مکانیزم‌های انتزاع C++ (مانند کلاس‌ها و الگوها) استفاده کنید؛** به سبک برنامه‌نویسی C به‌خاطر یک احساس کاذب از آشنایی برنگردید.

3. **از کتابخانه استاندارد C++ به عنوان معلمی برای تکنیک‌ها و سبک‌های برنامه‌نویسی جدید استفاده کنید.**

4. **بلافاصله یک پایه منحصر به فرد برای تمام کلاس‌های خود اختراع نکنید (یک کلاس Object).** معمولاً می‌توانید برای بسیاری از کلاس‌ها بهتر عمل کنید بدون آن.

5. **استفاده از متغیرهای مرجع و اشاره‌گر را به حداقل برسانید؛** از متغیرهای محلی و عضو استفاده کنید (§3.2.1.2, §5.2, §16.3.4, §17.1).

6. **به خاطر داشته باشید: یک متغیر هرگز به‌طور ضمنی یک مرجع نیست.**

7. **به اشاره‌گرها به عنوان معادل مراجع جاوا در C++ فکر کنید؛** مراجع C++ محدودتر هستند؛ زیرا در C++ تغییر مکان مراجع وجود ندارد.

8. **یک تابع به‌طور پیش‌فرض مجازی نیست.** نه هر کلاسی برای وراثت طراحی شده است.

9. **از کلاس‌های انتزاعی به عنوان رابط‌هایی برای سلسله‌مراتب کلاس‌ها استفاده کنید؛** از «کلاس‌های پایه شکننده» که شامل اعضای داده هستند، اجتناب کنید.

10. **هرگاه ممکن است از مدیریت منابع محلی (RAII؛ «به‌دست‌آوری منبع برابر با مقداردهی اولیه») استفاده کنید.**

11. **از یک سازنده برای ایجاد یک invariant کلاس استفاده کنید (و اگر نمی‌تواند این کار را انجام دهد، استثنایی پرتاب کنید).**

12. **اگر یک عمل پاک‌سازی هنگام حذف یک شی لازم است (برای مثال، زمانی که از دامنه خارج می‌شود)، از یک ویرایش‌گر برای آن استفاده کنید.** از تقلید از `finally` اجتناب کنید (زیرا این کار به‌صورت تصادفی و در درازمدت کار بیشتری نسبت به اتکا به ویرایش‌گرها است).

13. **از `new` و `delete` «عریان» اجتناب کنید؛** به‌جای آن، از کانتینرها (مانند `vector`، `string` و `map`) و کلاس‌های مدیریت (مانند `lock` و `unique_ptr`) استفاده کنید.

14. **از توابع مستقل (توابع غیرعضو) برای به حداقل رساندن پیوند استفاده کنید (برای مثال، به الگوریتم‌های استاندارد مراجعه کنید) و از فضای نام (§2.4.2، فصل 14) برای محدود کردن دامنه توابع مستقل استفاده کنید.**

15. **از مشخصات استثنا استفاده نکنید (به جز `noexcept`؛ §13.5.1.1).**

16. **یک کلاس تو در C++ به یک شیء از کلاس محاطی دسترسی ندارد.**

17. **C++ تنها حداقل بازتاب زمان اجرا را ارائه می‌دهد:** `dynamic_cast` و `typeid` (فصل 22). بیشتر بر امکانات زمان کامپایل تکیه کنید (برای مثال، چندریختی زمان کامپایل؛ فصل 27، فصل 28).

بیشتر این مشاوره به‌طور مساوی برای برنامه‌نویسان C# نیز صدق می‌کند.


# History
من C++ را اختراع کردم، تعریفات اولیه آن را نوشتم و اولین پیاده‌سازی آن را تولید کردم. من معیارهای طراحی برای C++ را انتخاب و فرموله کردم، ویژگی‌های اصلی زبان آن را طراحی کردم، بسیاری از کتابخانه‌های اولیه را توسعه دادم یا به توسعه آن‌ها کمک کردم و مسئول پردازش پیشنهادات گسترش در کمیته استاندارد C++ بودم.

این C++ به‌گونه‌ای طراحی شده است که امکانات سازمان‌دهی برنامه Simula را [Dahl, 1970] [Dahl, 1972] به همراه کارایی و انعطاف‌پذیری C برای برنامه‌نویسی سیستمی [Kernighan, 1978] [Kernighan, 1988] ارائه دهد. Simula منبع اولیه مکانیزم‌های انتزاع C++ است. مفهوم کلاس (با کلاس‌های مشتق شده و توابع مجازی) از آن اقتباس شده است. با این حال، الگوها و استثناها بعداً به C++ اضافه شدند و الهامات مختلفی برای آن‌ها وجود داشت.

تکامل C++ همیشه در زمینه استفاده آن صورت گرفته است. من زمان زیادی را به شنیدن نظرات کاربران و جست‌وجوی نظرات برنامه‌نویسان باتجربه گذراندم. به‌طور خاص، همکارانم در آزمایشگاه‌های بل AT&T در طول دهه اول رشد C++ نقش اساسی داشتند.

این بخش یک مرور کلی است و سعی نمی‌کند همه ویژگی‌های زبان و اجزای کتابخانه را ذکر کند. علاوه بر این، به جزئیات نمی‌پردازد. برای اطلاعات بیشتر و به‌ویژه برای نام‌های بیشتر از افرادی که در این زمینه کمک کرده‌اند، به [Stroustrup, 1993]، [Stroustrup, 2007] و [Stroustrup, 1994] مراجعه کنید. دو مقاله من از کنفرانس تاریخ زبان‌های برنامه‌نویسی ACM و کتاب من با عنوان **طراحی و تکامل C++** (که به عنوان "D&E" شناخته می‌شود) طراحی و تکامل C++ را به‌طور مفصل توصیف می‌کند و تأثیرات زبان‌های برنامه‌نویسی دیگر را مستند می‌سازد.

بیشتر اسنادی که به عنوان بخشی از تلاش‌های استانداردسازی ISO C++ تولید شده‌اند، به‌صورت آنلاین در دسترس هستند [WG21]. در بخش سوالات متداول من، سعی می‌کنم ارتباطی بین امکانات استاندارد و افرادی که آن امکانات را پیشنهاد و بهبود بخشیده‌اند، برقرار کنم [Stroustrup, 2010]. C++ نتیجه کار یک کمیته ناشناس و بی‌چهره یا یک "دیکتاتور مادام‌العمر" نیست؛ بلکه حاصل تلاش‌های بسیاری از افراد متعهد، باتجربه و سخت‌کوش است.

## Timeline
کاری که منجر به توسعه C++ شد، در پاییز 1979 با نام «C with Classes» (سی با کلاس‌ها) آغاز شد. در اینجا یک جدول زمانی ساده شده ارائه شده است:

- **1979**: کار بر روی «C with Classes» آغاز شد. مجموعه ویژگی‌های اولیه شامل کلاس‌ها و کلاس‌های مشتق، کنترل دسترسی عمومی/خصوصی، سازنده‌ها و مخرب‌ها، و اعلامیه‌های تابع با بررسی آرگومان‌ها بود. اولین کتابخانه از وظایف همزمان غیرپیش‌دستانه و مولدهای اعداد تصادفی پشتیبانی می‌کرد.
  
- **1984**: «C with Classes» به C++ تغییر نام داد. تا آن زمان، C++ دارای توابع مجازی، سربارگذاری تابع و عملگر، مرجع‌ها (references)، و کتابخانه‌های جریان‌های ورودی/خروجی و اعداد مختلط بود.
  
- **1985**: اولین نسخه تجاری C++ (14 اکتبر). کتابخانه شامل جریان‌های ورودی/خروجی، اعداد مختلط، و وظایف (زمان‌بندی غیرپیش‌دستانه) بود.
  
- **1985**: کتاب «زبان برنامه‌نویسی C++» (TC++PL، 14 اکتبر) [Stroustrup,1986].
  
- **1989**: کتاب «راهنمای مرجع تشریحی C++» (Annotated C++ Reference Manual یا ARM).
  
- **1991**: نسخه دوم کتاب «زبان برنامه‌نویسی C++» [Stroustrup,1991]، برنامه‌نویسی جنریک با استفاده از قالب‌ها (templates) و مدیریت خطاها بر اساس استثناها (از جمله ایدئوم «تخصیص منبع به عنوان مقداردهی اولیه» برای مدیریت عمومی منابع) را معرفی کرد.
  
- **1997**: نسخه سوم کتاب «زبان برنامه‌نویسی C++» [Stroustrup,1997]، C++ استاندارد ISO را معرفی کرد که شامل نام‌فضاها، dynamic_cast و بسیاری از بهبودهای قالب‌ها بود. کتابخانه استاندارد، چارچوب STL از ظروف جنریک و الگوریتم‌ها را اضافه کرد.
  
- **1998**: استاندارد ISO C++.
  
- **2002**: کار بر روی استاندارد بازبینی شده، به نام غیررسمی C++0x، آغاز شد.
  
- **2003**: یک بازبینی "رفع باگ" از استاندارد ISO C++ صادر شد. یک گزارش فنی C++ مؤلفه‌های جدید کتابخانه استاندارد، مانند عبارات منظم (regular expressions)، ظروف نامرتب (جداول هش) و اشاره‌گرهای مدیریت منابع را معرفی کرد که بعداً به C++0x افزوده شدند.
  
- **2006**: یک گزارش فنی ISO C++ در مورد عملکرد صادر شد تا به سوالاتی درباره هزینه، پیش‌بینی‌پذیری و تکنیک‌ها، بیشتر در رابطه با برنامه‌نویسی سیستم‌های تعبیه‌شده، پاسخ دهد.
  
- **2009**: C++0x به ویژگی‌های کامل رسید. این استاندارد مقداردهی اولیه یکنواخت، معنای حرکت (move semantics)، آرگومان‌های قالب متغیر، عبارات لامبدا، نام‌های مستعار نوع (type aliases)، یک مدل حافظه مناسب برای هم‌زمانی و موارد دیگر را فراهم کرد. کتابخانه استاندارد چندین مؤلفه را اضافه کرد، از جمله نخ‌ها (threads)، قفل‌ها (locks) و بیشتر مؤلفه‌های گزارش فنی 2003.
  
- **2011**: استاندارد ISO C++11 به طور رسمی تأیید شد.
  
- **2012**: اولین پیاده‌سازی‌های کامل C++11 ظاهر شد.
  
- **2012**: کار بر روی استانداردهای آینده ISO C++ (که به نام C++14 و C++17 شناخته می‌شوند) آغاز شد.
  
- **2013**: نسخه چهارم کتاب «زبان برنامه‌نویسی C++» معرفی کننده C++11 بود.
  
در طول توسعه، C++11 به نام C++0x شناخته می‌شد. مانند بسیاری از پروژه‌های بزرگ، ما در مورد تاریخ تکمیل پروژه بیش از حد خوش‌بین بودیم.

## The Early Years
من در ابتدا زبان C++ را طراحی و پیاده‌سازی کردم زیرا می‌خواستم خدمات هسته‌ی UNIX را بر روی چندپردازنده‌ها و شبکه‌های محلی (که اکنون به عنوان چند هسته‌ای‌ها و خوشه‌ها شناخته می‌شوند) توزیع کنم. برای این کار، نیاز به شبیه‌سازی‌های رویداد-محور داشتم که Simula می‌توانست برای آن ایده‌آل باشد، به‌جز از نظر ملاحظات عملکرد. همچنین نیاز داشتم که مستقیماً با سخت‌افزار کار کنم و مکانیزم‌های برنامه‌نویسی همزمان با کارایی بالا فراهم کنم که C برای آن مناسب بود، به‌جز ضعف آن در پشتیبانی از مدولاریت و بررسی نوع‌ها. نتیجه افزودن کلاس‌های به سبک Simula به C، «C with Classes» بود که برای پروژه‌های بزرگ استفاده شد. در این پروژه‌ها امکانات این زبان برای نوشتن برنامه‌هایی که از حداقل زمان و فضا استفاده می‌کنند، به شدت مورد آزمایش قرار گرفت. این زبان فاقد ویژگی‌هایی مانند سربارگذاری عملگر، مراجع، توابع مجازی، قالب‌ها، استثناها و بسیاری از جزئیات دیگر بود [Stroustrup, 1982]. اولین استفاده از C++ خارج از یک سازمان تحقیقاتی در ژوئیه 1983 آغاز شد.

نام C++ (که «سی پلاس پلاس» تلفظ می‌شود) توسط ریک ماسچیتی در تابستان 1983 ابداع شد و من آن را به عنوان جایگزین نام «C with Classes» انتخاب کردم. این نام نشان‌دهنده ماهیت تکاملی تغییرات از C است؛ «++» عملگر افزایش در C است. نام کوتاه‌تر «C+» یک خطای نحوی است؛ همچنین به عنوان نام یک زبان غیرمرتبط دیگر استفاده شده بود. علاقه‌مندان به معنای C ممکن است C++ را ضعیف‌تر از ++C بدانند. زبان به نام D نامگذاری نشد زیرا گسترشی از C بود و هدفش رفع مشکلات با حذف ویژگی‌ها نبود و همچنین چندین زبان جانشین بالقوه C به نام D وجود داشتند. برای تفسیر دیگری از نام C++، به پیوست کتاب [Orwell, 1949] مراجعه کنید.

C++ عمدتاً به این منظور طراحی شد که دوستان من و من مجبور نباشیم با اسمبلی، C یا زبان‌های سطح بالای مد روز آن زمان برنامه‌نویسی کنیم. هدف اصلی آن آسان‌تر و لذت‌بخش‌تر کردن نوشتن برنامه‌های خوب برای برنامه‌نویس فردی بود. در سال‌های اولیه، هیچ طراحی کتبی برای C++ وجود نداشت؛ طراحی، مستندسازی و پیاده‌سازی همزمان انجام می‌شدند. همچنین پروژه‌ای به نام «C++» یا کمیته‌ای برای طراحی آن وجود نداشت. در تمام این مدت، C++ برای مقابله با مشکلاتی که کاربران با آن‌ها مواجه می‌شدند و نتیجه بحث‌های من، دوستانم و همکارانم تکامل یافت.

```
???
event-driven simulations 
```

## Language Features and Library Facilities
اولین طراحی C++ (که در آن زمان «C with Classes» نامیده می‌شد) شامل اعلامیه‌های تابع با بررسی نوع آرگومان‌ها و تبدیل‌های ضمنی، کلاس‌هایی با تمایز عمومی/خصوصی بین رابط و پیاده‌سازی، کلاس‌های مشتق‌شده، و سازنده‌ها و مخرب‌ها بود. من از ماکروها برای فراهم کردن پارامترسازی اولیه استفاده کردم. این طراحی تا اواسط سال 1980 مورد استفاده قرار گرفت. اواخر همان سال، توانستم مجموعه‌ای از امکانات زبانی را ارائه دهم که از مجموعه‌ای همگون از سبک‌های برنامه‌نویسی پشتیبانی می‌کرد؛ به بخش 1.2.1 مراجعه کنید. با نگاه به گذشته، معرفی سازنده‌ها و مخرب‌ها را مهم‌ترین بخش طراحی می‌دانم.

در اصطلاحات آن زمان، «یک سازنده محیط اجرایی لازم برای توابع عضو را ایجاد می‌کند و مخرب آن را برعکس می‌کند.» این رویکرد ریشه‌ای استراتژی‌های مدیریت منابع در C++ است (که منجر به نیاز به استثناها شد) و کلید بسیاری از تکنیک‌ها برای کوتاه و واضح کردن کدهای کاربر است. اگر در آن زمان زبان‌های دیگری وجود داشتند که از چندین سازنده پشتیبانی می‌کردند که قادر به اجرای کد عمومی بودند، من از آن‌ها اطلاع نداشتم و هنوز هم نمی‌دانم. مخرب‌ها در C++ ویژگی جدیدی بودند.

در C++ در اکتبر 1985 به صورت تجاری عرضه شد. تا آن زمان، ویژگی‌هایی مانند توابع درون‌خطی (inlining)، ثابت‌ها (consts)، سربارگذاری توابع، مراجع (references)، سربارگذاری عملگرها و توابع مجازی به زبان اضافه کرده بودم. از میان این ویژگی‌ها، پشتیبانی از چندریختی زمان اجرا (run-time polymorphism) به شکل توابع مجازی بحث‌برانگیزترین ویژگی بود. من ارزش آن را از Simula می‌دانستم، اما متقاعد کردن اکثر افراد در دنیای برنامه‌نویسی سیستم‌ها از ارزش آن بسیار دشوار بود. برنامه‌نویسان سیستم‌ها تمایل داشتند با دید تردید به فراخوانی توابع غیرمستقیم نگاه کنند، و کسانی که با زبان‌های دیگر پشتیبان برنامه‌نویسی شیءگرا آشنا بودند، به سختی باور می‌کردند که توابع مجازی می‌توانند به اندازه کافی سریع باشند تا در کدهای سیستم مفید باشند.

در مقابل، بسیاری از برنامه‌نویسان با پس‌زمینه شیءگرا (و هنوز هم بسیاری از آن‌ها) به سختی می‌توانند با این ایده کنار بیایند که شما فقط زمانی از فراخوانی توابع مجازی استفاده می‌کنید که باید انتخابی در زمان اجرا انجام شود. مقاومت در برابر توابع مجازی ممکن است با مقاومت در برابر این ایده مرتبط باشد که می‌توان سیستم‌های بهتری از طریق ساختار منظم‌تر کد به دست آورد که توسط یک زبان برنامه‌نویسی پشتیبانی می‌شود. به نظر می‌رسید بسیاری از برنامه‌نویسان C معتقدند که آنچه واقعاً اهمیت دارد، انعطاف‌پذیری کامل و تنظیم دقیق و دستی هر جزئی از یک برنامه است. دیدگاه من (و همچنان نیز همین است) این بود که ما به هر کمکی که می‌توانیم از زبان‌ها و ابزارها دریافت کنیم نیاز داریم؛ پیچیدگی ذاتی سیستم‌هایی که سعی در ساخت آن‌ها داریم همیشه در مرز آنچه می‌توانیم بیان کنیم قرار دارد.

در نیمه دوم دهه 1980، من همچنان به افزودن ویژگی‌های جدید به زبان در پاسخ به نظرات کاربران ادامه دادم. مهم‌ترین این ویژگی‌ها الگوها (templates) [Stroustrup, 1988] و مدیریت استثناها (exception handling) [Koenig, 1990] بودند، که در زمانی که تلاش‌ها برای استانداردسازی آغاز شد، ویژگی‌هایی تجربی محسوب می‌شدند. در طراحی الگوها، من مجبور بودم بین انعطاف‌پذیری، کارایی و بررسی نوع در مراحل اولیه تصمیم بگیرم. در آن زمان، هیچ‌کس نمی‌دانست چگونه می‌توان به‌طور همزمان به هر سه ویژگی دست یافت، و برای رقابت با کد به سبک C در کاربردهای سیستم‌های پرتقاضا، احساس کردم که باید دو ویژگی اول را انتخاب کنم. با نگاهی به گذشته، فکر می‌کنم این انتخاب درست بود و جستجو برای بررسی بهتر نوع در الگوها همچنان ادامه دارد [Gregor, 2006] [Sutton, 2011] [Stroustrup, 2012a].

طراحی استثناها بر روی انتقال چندسطحی استثناها، انتقال اطلاعات دلخواه به یک مدیریت‌کننده خطا، و یکپارچگی بین استثناها و مدیریت منابع متمرکز بود، با استفاده از اشیاء محلی دارای مخرب‌ها (destructors) برای نمایندگی و آزادسازی منابع. این مفهوم که من به طور دست و پا شکسته آن را «تخصیص منابع به‌عنوان مقداردهی اولیه» (Resource Acquisition Is Initialization) نامیدم، نقش مهمی در این طراحی داشت.

من مکانیزم‌های ارث‌بری در C++ را تعمیم دادم تا از چندین کلاس پایه پشتیبانی کند [Stroustrup, 1987a]. این ویژگی که به آن ارث‌بری چندگانه (multiple inheritance) گفته می‌شود، در آن زمان دشوار و بحث‌برانگیز تلقی می‌شد. با این حال، من آن را به مراتب کمتر از الگوها (templates) یا مدیریت استثناها مهم می‌دانستم. ارث‌بری چندگانه از کلاس‌های انتزاعی (که اغلب به آن‌ها واسط‌ها یا interfaces گفته می‌شود) اکنون در زبان‌هایی که از بررسی نوع ایستا و برنامه‌نویسی شیءگرا پشتیبانی می‌کنند، به‌صورت جهانی پذیرفته شده است.

زبان C++ همگام با برخی از امکانات کلیدی کتابخانه‌ای که در این کتاب ارائه شده است، تکامل یافت. به عنوان مثال، من کلاس‌های **complex** [Stroustrup, 1984]، **vector**، **stack** و **(I/O) stream** [Stroustrup, 1985] را همراه با مکانیزم‌های سربارگذاری عملگر طراحی کردم. اولین کلاس‌های **string** و **list** نیز توسط من و جاناتان شوپایرو به عنوان بخشی از همین تلاش توسعه داده شدند. کلاس‌های string و list جاناتان، اولین کلاس‌هایی بودند که به صورت گسترده در کتابخانه‌ها مورد استفاده قرار گرفتند. کلاس **string** موجود در کتابخانه استاندارد C++ ریشه در این تلاش‌های اولیه دارد.

کتابخانه وظایف (task library) که در [Stroustrup, 1987b] شرح داده شده است، بخشی از اولین برنامه‌ای بود که با استفاده از «C with Classes» در سال 1980 نوشته شد. من این کتابخانه و کلاس‌های مرتبط با آن را برای پشتیبانی از شبیه‌سازی‌های به سبک Simula طراحی کردم. متأسفانه، ما مجبور شدیم تا سال 2011 (30 سال!) منتظر بمانیم تا پشتیبانی از همزمانی به صورت استاندارد و در دسترس همگان قرار گیرد. توسعه قابلیت‌های قالب (template) تحت تأثیر انواع مختلفی از قالب‌های **vector**، **map**، **list** و **sort** بود که توسط اندرو کونیگ، الکس استپانوف، من و دیگران طراحی شد.

در C++ در محیطی پر از زبان‌های برنامه‌نویسی تثبیت‌شده و آزمایشی رشد کرد (مانند Ada [Ichbiah, 1979]، Algol 68 [Woodward, 1974]، و ML [Paulson, 1996]). در آن زمان، من با حدود 25 زبان مختلف راحت بودم و تأثیرات آن‌ها بر C++ در [Stroustrup, 1994] و [Stroustrup, 2007] مستند شده است. با این حال، تأثیرات تعیین‌کننده همواره از برنامه‌ها و کاربردهایی که با آن‌ها مواجه می‌شدم نشأت می‌گرفت. این یک سیاست آگاهانه بود که توسعه C++ بر اساس «مشکل‌محور» بودن انجام شود، نه تقلید از دیگر زبان‌ها.

## The 1998 Standard
رشد انفجاری استفاده از C++ باعث ایجاد تغییراتی شد. در حدود سال 1987، مشخص شد که استانداردسازی رسمی C++ اجتناب‌ناپذیر است و باید برای این تلاش استانداردسازی آماده شویم [Stroustrup, 1994]. نتیجه این شد که یک تلاش آگاهانه برای حفظ ارتباط بین پیاده‌کنندگان کامپایلرهای C++ و کاربران عمده صورت گرفت. این ارتباط از طریق نامه‌های کاغذی و الکترونیکی و همچنین جلسات حضوری در کنفرانس‌های C++ و سایر مکان‌ها برقرار می‌شد.

آزمایشگاه‌های AT&T Bell سهم عمده‌ای در توسعه C++ و جامعه گسترده‌تر آن داشتند، زیرا به من اجازه دادند پیش‌نویس نسخه‌های اصلاح‌شده از **راهنمای مرجع C++** را با پیاده‌کنندگان و کاربران به اشتراک بگذارم. از آنجا که بسیاری از این افراد برای شرکت‌هایی کار می‌کردند که ممکن بود به عنوان رقیب AT&T در نظر گرفته شوند، اهمیت این اقدام نباید دست‌کم گرفته شود. یک شرکت کمتر آگاه می‌توانست به سادگی با انجام هیچ کاری، مشکلات عمده‌ای از جمله تکه‌تکه شدن زبان ایجاد کند. همان‌طور که اتفاق افتاد، حدود صد نفر از ده‌ها سازمان مختلف این پیش‌نویس را خواندند و درباره آن اظهار نظر کردند. این پیش‌نویس به عنوان راهنمای مرجع پذیرفته‌شده عمومی و سند پایه برای تلاش‌های استانداردسازی ANSI C++ تبدیل شد. نام این افراد را می‌توان در کتاب **The Annotated C++ Reference Manual** (یا همان "ARM") یافت [Ellis, 1989].

کمیته X3J16 ANSI در دسامبر 1989 به ابتکار Hewlett-Packard تشکیل شد. در ژوئن 1991، این استانداردسازی ملی آمریکایی برای C++ بخشی از تلاش استانداردسازی بین‌المللی ISO برای C++ شد و به WG21 نام‌گذاری شد. از سال 1990، این کمیته‌های مشترک استاندارد C++ به اصلی‌ترین بستر برای تکامل C++ و پالایش تعریف آن تبدیل شدند. من در تمام این مدت در این کمیته‌ها حضور داشتم. به‌ویژه به‌عنوان رئیس گروه کاری توسعه (که بعدها گروه تکامل نامیده شد)، من مستقیماً مسئول بررسی پیشنهادات برای تغییرات عمده در C++ و افزودن ویژگی‌های جدید زبان بودم.

یک پیش‌نویس اولیه برای بازبینی عمومی در آوریل 1995 منتشر شد. اولین استاندارد ISO C++ (ISO/IEC 14882-1998) [C++, 1998] در سال 1998 با رأی 22-0 ملی تصویب شد. یک نسخه رفع اشکال از این استاندارد در سال 2003 منتشر شد، بنابراین گاهی از آن به عنوان **C++03** یاد می‌شود، اما این اساساً همان زبان **C++98** است.

## Language Features
تا زمانی که تلاش‌های استانداردسازی ANSI و ISO آغاز شد، بیشتر ویژگی‌های عمده زبان در محل خود قرار داشت و در **ARM** [Ellis, 1989] مستند شده بود. بنابراین، بیشتر کارها شامل پالایش ویژگی‌ها و مشخصات آن‌ها بود. به‌ویژه، مکانیزم‌های قالب (template) از کارهای دقیق و مفصل بهره‌مند شدند. **فضاهای نام** (namespaces) برای مقابله با افزایش اندازه برنامه‌های C++ و افزایش تعداد کتابخانه‌ها معرفی شدند. به ابتکار دیمیتری لنکوف از **Hewlett-Packard**، امکانات حداقلی برای استفاده از اطلاعات نوع در زمان اجرا (**RTTI**؛ فصل 22) معرفی شدند. من این امکانات را از C++ حذف کرده بودم، زیرا متوجه شده بودم که در **Simula** به شدت مورد استفاده قرار می‌گیرند. تلاش کردم تا امکانی برای جمع‌آوری زباله به‌صورت اختیاری و محافظه‌کارانه پذیرفته شود، اما ناکام ماندم. ما مجبور شدیم تا استاندارد 2011 برای آن منتظر بمانیم.

به وضوح، زبان 1998 از نظر ویژگی‌ها و به‌ویژه از نظر جزئیات مشخصات نسبت به زبان 1989 بسیار برتر بود. با این حال، همه تغییرات بهبود نبودند. علاوه بر اشتباهات جزئی اجتناب‌ناپذیر، دو ویژگی عمده به زبان افزوده شدند که به‌نظرم در retrospect نباید اضافه می‌شدند:

- **مشخصات استثنا** (exception specifications) برای اجرای قوانین مربوط به استثناهایی که یک تابع مجاز به پرتاب آن‌ها بود، در زمان اجرا معرفی شد. این ویژگی به ابتکار پرشور افرادی از **Sun Microsystems** اضافه شد. مشخصات استثناها بدتر از بی‌فایده بودن در بهبود خوانایی، قابلیت اطمینان و عملکرد ظاهر شد. این ویژگی در استاندارد 2011 منسوخ شد (برنامه‌ریزی برای حذف در آینده). استاندارد 2011 ویژگی **noexcept** (§13.5.1.1) را به عنوان یک راه‌حل ساده‌تر برای بسیاری از مشکلاتی که مشخصات استثناها supposed to address اضافه کرد.

- همواره واضح بود که **کامپایل جداگانه** (separate compilation) از قالب‌ها و استفاده‌های آن‌ها ایده‌آل خواهد بود [Stroustrup, 1994]. با این حال، نحوه دستیابی به این هدف تحت محدودیت‌های ناشی از استفاده‌های واقعی از قالب‌ها به هیچ وجه واضح نبود. پس از یک بحث طولانی در کمیته، یک مصالحه به دست آمد و چیزی به نام **قالب‌های صادراتی** (export templates) به عنوان بخشی از استاندارد 1998 مشخص شد. این یک راه‌حل زیبا برای مشکل نبود، فقط یک فروشنده (گروه طراحی ادیسون) از export پشتیبانی کرد و این ویژگی از استاندارد 2011 حذف شد. ما هنوز به دنبال یک راه‌حل هستیم. نظر من این است که مشکل بنیادی، کامپایل جداگانه به خودی خود نیست، بلکه تمایز بین **رابط** (interface) و **پیاده‌سازی** (implementation) یک قالب به خوبی مشخص نشده است. بنابراین، export مشکل اشتباهی را حل کرد. در آینده، پشتیبانی زبان برای **"مفاهیم"** (§24.3) ممکن است با ارائه مشخصات دقیق از الزامات قالب کمک کند. این حوزه‌ای است که در حال حاضر تحقیق و طراحی فعال دارد [Sutton, 2011] [Stroustrup, 2012a].

## The Standard Library
تا زمانی که تلاش‌های استانداردسازی ANSI و ISO آغاز شد، بیشتر ویژگی‌های عمده زبان در محل خود قرار داشت و در **ARM** [Ellis, 1989] مستند شده بود. بنابراین، بیشتر کارها شامل پالایش ویژگی‌ها و مشخصات آن‌ها بود. به‌ویژه، مکانیزم‌های قالب (template) از کارهای دقیق و مفصل بهره‌مند شدند. **فضاهای نام** (namespaces) برای مقابله با افزایش اندازه برنامه‌های C++ و افزایش تعداد کتابخانه‌ها معرفی شدند. به ابتکار دیمیتری لنکوف از **Hewlett-Packard**، امکانات حداقلی برای استفاده از اطلاعات نوع در زمان اجرا (**RTTI**؛ فصل 22) معرفی شدند. من این امکانات را از C++ حذف کرده بودم، زیرا متوجه شده بودم که در **Simula** به شدت مورد استفاده قرار می‌گیرند. تلاش کردم تا امکانی برای جمع‌آوری زباله به‌صورت اختیاری و محافظه‌کارانه پذیرفته شود، اما ناکام ماندم. ما مجبور شدیم تا استاندارد 2011 برای آن منتظر بمانیم.

به وضوح، زبان 1998 از نظر ویژگی‌ها و به‌ویژه از نظر جزئیات مشخصات نسبت به زبان 1989 بسیار برتر بود. با این حال، همه تغییرات بهبود نبودند. علاوه بر اشتباهات جزئی اجتناب‌ناپذیر، دو ویژگی عمده به زبان افزوده شدند که به‌نظرم در retrospect نباید اضافه می‌شدند:

- **مشخصات استثنا** (exception specifications) برای اجرای قوانین مربوط به استثناهایی که یک تابع مجاز به پرتاب آن‌ها بود، در زمان اجرا معرفی شد. این ویژگی به ابتکار پرشور افرادی از **Sun Microsystems** اضافه شد. مشخصات استثناها بدتر از بی‌فایده بودن در بهبود خوانایی، قابلیت اطمینان و عملکرد ظاهر شد. این ویژگی در استاندارد 2011 منسوخ شد (برنامه‌ریزی برای حذف در آینده). استاندارد 2011 ویژگی **noexcept** (§13.5.1.1) را به عنوان یک راه‌حل ساده‌تر برای بسیاری از مشکلاتی که مشخصات استثناها supposed to address اضافه کرد.

- همواره واضح بود که **کامپایل جداگانه** (separate compilation) از قالب‌ها و استفاده‌های آن‌ها ایده‌آل خواهد بود [Stroustrup, 1994]. با این حال، نحوه دستیابی به این هدف تحت محدودیت‌های ناشی از استفاده‌های واقعی از قالب‌ها به هیچ وجه واضح نبود. پس از یک بحث طولانی در کمیته، یک مصالحه به دست آمد و چیزی به نام **قالب‌های صادراتی** (export templates) به عنوان بخشی از استاندارد 1998 مشخص شد. این یک راه‌حل زیبا برای مشکل نبود، فقط یک فروشنده (گروه طراحی ادیسون) از export پشتیبانی کرد و این ویژگی از استاندارد 2011 حذف شد. ما هنوز به دنبال یک راه‌حل هستیم. نظر من این است که مشکل بنیادی، کامپایل جداگانه به خودی خود نیست، بلکه تمایز بین **رابط** (interface) و **پیاده‌سازی** (implementation) یک قالب به خوبی مشخص نشده است. بنابراین، export مشکل اشتباهی را حل کرد. در آینده، پشتیبانی زبان برای **"مفاهیم"** (§24.3) ممکن است با ارائه مشخصات دقیق از الزامات قالب کمک کند. این حوزه‌ای است که در حال حاضر تحقیق و طراحی فعال دارد [Sutton, 2011] [Stroustrup, 2012a].

## The 2011 Standard
در C++ فعلی، C++11، که سال‌ها به عنوان C++0x شناخته می‌شد، نتیجه کار اعضای **WG21** است. این کمیته تحت فرآیندها و رویه‌های خودتحمیل‌شده‌ای که به‌طور فزاینده‌ای سختگیرانه‌تر می‌شد، کار کرد. این فرآیندها احتمالاً به مشخصات بهتر (و دقیق‌تری) منجر شدند، اما همچنین نوآوری را محدود کردند [Stroustrup, 2007]. یک پیش‌نویس استاندارد اولیه برای بررسی عمومی در سال 2009 تهیه شد. دومین استاندارد ISO C++ (ISO/IEC 14882-2011) [C++, 2011] در آگوست 2011 با رأی 21-0 تصویب شد.

یکی از دلایل فاصله طولانی بین دو استاندارد این است که بیشتر اعضای کمیته (از جمله من) تحت تأثیر تصور نادرستی بودند که قوانین ISO نیاز به یک "دوره انتظار" پس از صدور استاندارد قبل از شروع کار بر روی ویژگی‌های جدید دارند. به همین دلیل، کار جدی بر روی ویژگی‌های جدید زبان تا سال 2002 آغاز نشد. دلایل دیگر شامل افزایش اندازه زبان‌های مدرن و کتابخانه‌های پایه آن‌ها بود. به لحاظ تعداد صفحات متن استاندارد، زبان تقریباً 30% و کتابخانه استاندارد حدود 100% رشد کرد. بخش زیادی از این افزایش به دلیل مشخصات دقیق‌تر بود، نه عملکرد جدید. همچنین، کار بر روی یک استاندارد جدید C++ به وضوح باید با احتیاط انجام می‌شد تا کدهای قدیمی را از طریق تغییرات ناسازگار مختل نکند. میلیاردها خط کد C++ در حال استفاده وجود دارد که کمیته نباید آن‌ها را خراب کند.

اهداف کلی تلاش برای C++11 عبارت بودند از:
- بهتر کردن C++ به عنوان یک زبان برای برنامه‌نویسی سیستم‌ها و ساخت کتابخانه‌ها.
- آسان‌تر کردن C++ برای آموزش و یادگیری.

این اهداف در [Stroustrup, 2007] مستند و تفصیل داده شده‌اند.

یک تلاش بزرگ برای ایمن و قابل حمل ساختن برنامه‌نویسی سیستم‌های همزمان (concurrent) انجام شد. این شامل یک مدل حافظه (§41.2) و مجموعه‌ای از امکانات برای برنامه‌نویسی بدون قفل (§41.3) بود که عمدتاً کار **هانس بوهیم**، **برایان مک‌کایت** و دیگران است. بر روی این پایه، ما کتابخانه‌ی رشته‌ها (threads library) را اضافه کردیم. **پیت بکر**، **پیتر دیموف**، **هوارد هینانت**، **ویلیام کِمپف**، **آنتونی ویلیامز** و دیگران کارهای زیادی در این زمینه انجام دادند. به عنوان یک مثال از آنچه می‌تواند بر روی تسهیلات ابتدایی همزمانی (concurrency facilities) حاصل شود، من کار بر روی "روشی برای تبادل اطلاعات بین وظایف بدون استفاده صریح از قفل" را پیشنهاد دادم که به **futures** و **async()** (§5.3.5) تبدیل شد؛ **لارنس کرول** و **دتلف فولمن** بیشتر کارهای آن را انجام دادند. همزمانی حوزه‌ای است که ارائه یک لیست کامل و دقیق از اینکه چه کسی چه کاری انجام داد و چرا نیاز به یک مقاله بسیار طولانی دارد. در اینجا، حتی نمی‌توانم تلاشی در این زمینه داشته باشم.

## What is C++ used for?
تا سال ۲۰۱۳، C++ تقریباً در همه‌جا استفاده می‌شود: در کامپیوتر شما، تلفن همراه، خودرو و احتمالاً حتی در دوربین شما. معمولاً آن را نمی‌بینید. C++ یک زبان برنامه‌نویسی سیستم است و استفاده‌های گسترده‌اش عمیقاً در زیرساخت‌هایی است که ما به عنوان کاربران هرگز به آن نگاه نمی‌کنیم.

زبان C++ توسط میلیون‌ها برنامه‌نویس در تقریباً هر حوزه کاربردی استفاده می‌شود. میلیاردها (هزاران میلیون) خط کد C++ در حال حاضر در محیط‌های عملیاتی قرار دارند. این استفاده وسیع به کمک چندین پیاده‌سازی مستقل، هزاران کتابخانه، صدها کتاب درسی و ده‌ها وب‌سایت پشتیبانی می‌شود. آموزش و پرورش در سطوح مختلف به‌طور گسترده در دسترس است.

برنامه‌های اولیه تمایل داشتند که رنگ و بوی قوی‌تری از برنامه‌نویسی سیستم داشته باشند. به عنوان مثال، چندین سیستم‌عامل اولیه در C++ نوشته شده‌اند: [Campbell,1987] (آکادمیک)، [Rozier,1988] (زمان واقعی)، و [Berg,1995] (ورودی/خروجی با توان بالا). بسیاری از سیستم‌عامل‌های فعلی (مانند ویندوز، سیستم‌عامل اپل، لینوکس و بیشتر سیستم‌عامل‌های دستگاه‌های قابل حمل) بخش‌های کلیدی خود را در C++ پیاده‌سازی کرده‌اند. به احتمال زیاد تلفن همراه و روترهای اینترنتی شما نیز به زبان C++ نوشته شده‌اند. من کارایی بی‌چون و چرای سطح پایین را برای C++ ضروری می‌دانم. این امر به ما اجازه می‌دهد تا با استفاده از C++ درایورهای دستگاه و دیگر نرم‌افزارهایی را بنویسیم که به دست‌کاری مستقیم سخت‌افزار تحت محدودیت‌های زمان واقعی وابسته‌اند. در چنین کدی، پیش‌بینی‌پذیری عملکرد حداقل به اندازه سرعت خام اهمیت دارد. اغلب، جمع و جوری سیستم حاصل نیز مهم است. C++ به گونه‌ای طراحی شده است که هر ویژگی زبانی قابل استفاده در کدی باشد که تحت محدودیت‌های شدید زمان و فضا قرار دارد (§1.2.4) [Stroustrup,1994,§4.5].

برخی از سیستم‌های امروزی که بسیار قابل مشاهده و مورد استفاده هستند، قسمت‌های حیاتی آن‌ها به زبان C++ نوشته شده است. نمونه‌هایی از این سیستم‌ها شامل Amadeus (بلیط‌فروشی هواپیما)، Amazon (تجارت الکترونیک)، Bloomberg (اطلاعات مالی)، Google (جستجوی وب) و Facebook (رسانه اجتماعی) می‌شوند. بسیاری از زبان‌های برنامه‌نویسی و فناوری‌های دیگر به‌طور بحرانی به عملکرد و قابلیت اطمینان C++ در پیاده‌سازی خود وابسته هستند. به عنوان مثال، ماشین‌های مجازی جاوا (مانند HotSpot اوراکل)، مفسرهای جاوا اسکریپت (مانند V8 گوگل)، مرورگرها (مانند Internet Explorer مایکروسافت، Firefox موزیلا، Safari اپل و Chrome گوگل) و چارچوب‌های کاربردی (مانند چارچوب خدمات وب .NET مایکروسافت) به C++ وابسته‌اند. من C++ را به عنوان زبانی با قدرت‌های منحصر به فرد در زمینه نرم‌افزار زیرساخت می‌دانم【Stroustrup,2012a】.

بیشتر برنامه‌ها دارای بخش‌هایی از کد هستند که برای دستیابی به عملکرد قابل قبول حیاتی هستند. با این حال، بیشترین حجم کد در این بخش‌ها نیست. برای اکثر کدها، قابلیت نگهداری، سهولت گسترش و سهولت آزمایش از اهمیت بالایی برخوردارند. پشتیبانی C++ از این موارد، به استفاده گسترده از آن در حوزه‌هایی که نیاز به قابلیت اطمینان دارند و نیازها در طول زمان به طور قابل توجهی تغییر می‌کنند، منجر شده است. به عنوان مثال، در سیستم‌های مالی، ارتباطات از راه دور، کنترل دستگاه و برنامه‌های نظامی. به مدت چندین دهه، کنترل مرکزی سیستم تلفن‌های دوردست ایالات متحده به C++ وابسته بوده و هر تماس 800 (یعنی تماسی که هزینه آن توسط طرف مورد تماس پرداخت می‌شود) توسط یک برنامه C++ مسیریابی شده است【Kamath,1993】. بسیاری از این برنامه‌ها بزرگ و با عمر طولانی هستند. در نتیجه، ثبات، سازگاری و مقیاس‌پذیری همواره از دغدغه‌های اصلی در توسعه C++ بوده‌اند. برنامه‌های C++ چندمیلیون خطی معمول هستند.

بازی‌ها نیز یکی دیگر از حوزه‌هایی هستند که در آن نیاز به وجود چندین زبان و ابزار مختلف در کنار یک زبان با کارایی بی‌نقص (که غالباً بر روی سخت‌افزارهای "غیرمعمول" اجرا می‌شود) احساس می‌شود. از این رو، بازی‌ها یکی دیگر از زمینه‌های اصلی کاربرد C++ به شمار می‌روند. 

C++ به خاطر قدرت و کارایی خود در ایجاد بازی‌های پیچیده و با کیفیت بالا، به یکی از زبان‌های محبوب در صنعت بازی‌سازی تبدیل شده است. این زبان امکانات فراوانی برای مدیریت منابع، گرافیک، فیزیک و صدا ارائه می‌دهد که به توسعه‌دهندگان این امکان را می‌دهد تا تجربه‌های بازی غنی و واقعی را ایجاد کنند. 

از آنجایی که بازی‌ها معمولاً نیاز به بهینه‌سازی بالا و عملکرد دقیق دارند، C++ به عنوان زبان اصلی بسیاری از موتورهای بازی مانند Unreal Engine و Unity (در بخش‌های خاص) مورد استفاده قرار می‌گیرد. 

به همین دلیل، C++ در صنعت بازی‌سازی یک نقش کلیدی ایفا می‌کند و به توسعه‌دهندگان کمک می‌کند تا تجربیات بی‌نظیری برای بازیکنان خلق کنند.

آنچه که قبلاً به آن برنامه‌نویسی سیستم‌ها گفته می‌شد، اکنون در سیستم‌های جاسازی شده به‌وفور دیده می‌شود. بنابراین، تعجبی نیست که استفاده گسترده‌ای از C++ در پروژه‌های پیچیده سیستم‌های جاسازی شده وجود دارد، از جمله در نرم‌افزارهای توموگرافی کامپیوتری (CAT)، نرم‌افزارهای کنترل پرواز (مانند نرم‌افزار Lockheed-Martin)، کنترل موشک، موتورهای کشتی (برای مثال، کنترل بزرگ‌ترین موتورهای دیزل دریایی جهان از شرکت MAN)، نرم‌افزار خودرو (مانند BMW)، و کنترل توربین‌های بادی (مانند Vesta).

در C++ به‌طور خاص برای محاسبات عددی طراحی نشده است. با این حال، محاسبات عددی، علمی و مهندسی زیادی با استفاده از C++ انجام می‌شود. یکی از دلایل اصلی این موضوع این است که کارهای عددی سنتی اغلب باید با گرافیک و محاسباتی که به ساختارهای داده‌ای بستگی دارند که در قالب سنتی Fortran جا نمی‌گیرند، ترکیب شوند. من به‌ویژه خوشحالم که C++ در پروژه‌های علمی بزرگ، مانند پروژه ژنوم انسانی، Rover‌های مریخ ناسا، جستجوی CERN برای اصول بنیادین جهان و بسیاری دیگر مورد استفاده قرار می‌گیرد.

قابلیت C++ برای استفاده مؤثر در برنامه‌هایی که به کار در زمینه‌های مختلف نیاز دارند، یک نقطه قوت مهم است. برنامه‌هایی که شامل شبکه‌سازی محلی و گسترده، محاسبات عددی، گرافیک، تعامل با کاربر و دسترسی به پایگاه‌داده هستند، متداول هستند. به‌طور سنتی، این زمینه‌های برنامه‌نویسی به‌عنوان حوزه‌های متمایز در نظر گرفته می‌شدند و توسط جوامع فنی مختلف با استفاده از زبان‌های برنامه‌نویسی متنوع پشتیبانی می‌شدند. با این حال، C++ به‌طور گسترده‌ای در تمام این حوزه‌ها و بیشتر از آن استفاده می‌شود. این زبان به‌گونه‌ای طراحی شده است که کد C++ می‌تواند در کنار کدی که به زبان‌های دیگر نوشته شده است، وجود داشته باشد. در اینجا نیز، ثبات C++ در طول دهه‌ها اهمیت دارد. علاوه بر این، هیچ سیستم بزرگ واقعاً به‌طور کامل به یک زبان نوشته نشده است. بنابراین، هدف طراحی اولیه C++ از نظر تعامل‌پذیری، اهمیت پیدا می‌کند.

برنامه‌های بزرگ فقط به زبان خام نوشته نمی‌شوند. C++ از مجموعه‌ای از کتابخانه‌ها (فراتر از کتابخانه استاندارد ISO C++) و ابزارها پشتیبانی می‌کند، مانند Boost (کتابخانه‌های پایه قابل حمل)، POCO (توسعه وب)، QT (توسعه برنامه‌های چندسکویی)، wxWidgets (کتابخانه GUI چندسکویی)، WebKit (کتابخانه موتور طراحی برای مرورگرهای وب)، CGAL (هندسه محاسباتی)، QuickFix (تبادلات اطلاعات مالی)، OpenCV (پردازش تصویر در زمان واقعی) و Root (فیزیک انرژی بالا). هزاران کتابخانه C++ وجود دارد، بنابراین پیگیری همه آنها غیرممکن است.





## Advice
[1] ایده‌ها (مفاهیم) را به‌طور مستقیم در کد نمایندگی کنید، برای مثال، به‌عنوان یک تابع، یک کلاس یا یک شمارش؛ §1.2.

[2] هدف شما باید این باشد که کد شما هم زیبا و هم کارآمد باشد؛ §1.2.

[3] از بیش از حد انتزاعی کردن بپرهیزید؛ §1.2.

[4] تمرکز طراحی بر روی ارائه انتزاعات زیبا و کارآمد باشد، که ممکن است به‌صورت کتابخانه‌ها ارائه شوند؛ §1.2.

[5] روابط بین ایده‌ها را به‌طور مستقیم در کد نمایندگی کنید، برای مثال، از طریق پارامترسازی یا سلسله‌مراتب کلاس‌ها؛ §1.2.1.

[6] ایده‌های مستقل را به‌طور جداگانه در کد نمایندگی کنید، برای مثال، از ایجاد وابستگی‌های متقابل بین کلاس‌ها پرهیز کنید؛ §1.2.1.

[7] زبان C++ تنها شیءگرا نیست؛ §1.2.1.

[8] زبان C++ تنها برای برنامه‌نویسی عمومی نیست؛ §1.2.1.

[9] راه‌حل‌هایی را ترجیح دهید که بتوانند به‌طور استاتیک بررسی شوند؛ §1.2.1.

[10] منابع را به‌طور صریح بیان کنید (آنها را به‌عنوان اشیای کلاس نمایندگی کنید)؛ §1.2.1، §1.4.2.1.

[11] ایده‌های ساده را به‌سادگی بیان کنید؛ §1.2.1.

[12] از کتابخانه‌ها، به‌ویژه کتابخانه استاندارد، استفاده کنید، به‌جای اینکه سعی کنید همه چیز را از ابتدا بسازید؛ §1.2.1.

[13] از سبک برنامه‌نویسی غنی از نوع استفاده کنید؛ §1.2.2.

[14] کدهای سطح پایین لزوماً کارآمد نیستند؛ از کلاس‌ها، الگوها و اجزای کتابخانه استاندارد به‌دلیل ترس از مشکلات عملکردی پرهیز نکنید؛ §1.2.4، §1.3.3.

[15] اگر داده‌ها یک invariant دارند، آن را کپسوله کنید؛ §1.3.2.

[16] زبان C++ فقط C با چند افزودنی نیست؛ §1.3.3.