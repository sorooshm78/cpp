# The Design of C++
هدف یک زبان برنامه‌نویسی کمک به بیان ایده‌ها در قالب کد است. در این راستا، یک زبان برنامه‌نویسی دو وظیفه مرتبط را انجام می‌دهد: وسیله‌ای فراهم می‌کند تا برنامه‌نویس بتواند اقداماتی را که باید توسط ماشین اجرا شود، مشخص کند، و مجموعه‌ای از مفاهیم را برای برنامه‌نویس فراهم می‌کند تا از آن‌ها هنگام تفکر درباره کاری که می‌تواند انجام شود، استفاده کند. هدف اول به‌طور ایده‌آل نیاز به زبانی دارد که "نزدیک به ماشین" باشد، به‌گونه‌ای که همه جنبه‌های مهم ماشین به‌صورت ساده و کارآمد و به شکلی که برای برنامه‌نویس به‌طور معقولی واضح باشد، مدیریت شوند. زبان C عمدتاً با این هدف طراحی شده است. هدف دوم به‌طور ایده‌آل نیاز به زبانی دارد که "نزدیک به مسئله‌ای که باید حل شود" باشد، به‌گونه‌ای که مفاهیم یک راه‌حل را بتوان به‌طور مستقیم و مختصر بیان کرد. امکاناتی که به C افزوده شدند تا C++ ایجاد شود، مانند بررسی آرگومان‌های تابع، کلمه کلیدی const، کلاس‌ها، سازنده‌ها و مخرب‌ها، استثناها و قالب‌ها (templates)، عمدتاً با این هدف طراحی شده‌اند. بنابراین، C++ بر اساس این ایده استوار است که هم

- نگاشت‌های مستقیم عملیات و انواع داخلی به سخت‌افزار را برای استفاده کارآمد از حافظه و عملیات سطح پایین کارآمد فراهم کند، و
- مکانیزم‌های انتزاعی مقرون‌به‌صرفه و انعطاف‌پذیری را برای ایجاد انواع تعریف‌شده توسط کاربر با همان پشتیبانی از نشانه‌گذاری، دامنه کاربرد و عملکرد مانند انواع داخلی ارائه دهد.

اهمیت عبارت «تمایل به برنامه‌نویسی سیستم‌ها» در تعریف طولانی‌مدت من از C++ این است که C++ با حذف قابلیت‌هایی که برای استفاده در سطح تخصصی از سخت‌افزار و منابع سیستم طراحی شده‌اند، ساده‌سازی (یا مصالحه) نشده است، با این امید که آن را برای حوزه‌های کاربردی دیگر مناسب‌تر کند.

دو اصل زیر باید مورد توجه قرار گیرد:

• هیچ جایی برای زبان سطح پایین‌تری زیر C++ باقی نگذارید (به جز در موارد نادر که از کد اسمبلی استفاده می‌شود). اگر بتوان کدی با کارایی بالاتر در یک زبان سطح پایین‌تر نوشت، آن زبان احتمالاً به زبان انتخابی برای برنامه‌نویسی سیستم‌ها تبدیل خواهد شد.

• چیزی که استفاده نمی‌کنید، هزینه‌ای برای شما ندارد. اگر برنامه‌نویسان بتوانند به‌طور دستی کدی معقول برای شبیه‌سازی یک ویژگی زبانی یا انتزاع بنیادی بنویسند و حتی عملکردی کمی بهتر ارائه دهند، قطعاً کسی این کار را خواهد کرد و بسیاری از دیگران از آن تقلید خواهند کرد. بنابراین، یک ویژگی زبان و یک انتزاع بنیادی باید به گونه‌ای طراحی شود که نسبت به جایگزین‌های معادل، حتی یک بایت یا یک سیکل پردازنده را هدر ندهد. این به‌عنوان اصل «عدم سربار اضافی» شناخته می‌شود.

اصل «چیزی که استفاده نمی‌کنید، هزینه‌ای برای شما ندارد» (که به عنوان **اصل عدم سربار اضافی** یا **zero-overhead principle** شناخته می‌شود) یکی از اصول کلیدی طراحی زبان C++ است. این اصل بیان می‌کند که اگر شما از ویژگی یا قابلیت خاصی در زبان استفاده نکنید، نباید هیچ هزینه اضافی از لحاظ کارایی (مثل مصرف حافظه یا زمان پردازش) برای برنامه شما تحمیل شود.

### جزئیات بیشتر:
1. **عملکرد بهینه**: 
   این اصل بر این مبنا است که زبان باید به برنامه‌نویسان اجازه دهد تا بدون پرداخت هزینه اضافی برای ویژگی‌هایی که استفاده نمی‌کنند، به همان میزان کارایی و بهینگی که با زبان‌های سطح پایین (مثل اسمبلی یا C) می‌توان به دست آورد، دسترسی داشته باشند. به بیان دیگر، اگر شما یک قابلیت خاص مثل شی‌گرایی، استثناها یا قالب‌ها (templates) را در برنامه خود به کار نمی‌برید، نباید حتی یک بایت اضافی حافظه یا یک سیکل پردازنده بیشتر از آنچه در زبان‌های سطح پایین انتظار می‌رود مصرف شود.

2. **اجتناب از سربار ناخواسته**: 
   یکی از دلایل کلیدی که برنامه‌نویسان ممکن است یک زبان سطح پایین‌تر مثل اسمبلی را برای نوشتن کد انتخاب کنند، جلوگیری از سربار اضافی ناشی از ویژگی‌های زبان سطح بالاتر است. در C++ تلاش شده است تا این سربار حذف شود یا به حداقل برسد. به این معنا که وقتی یک ویژگی مثل کلاس‌ها یا الگوها (templates) را استفاده می‌کنید، فقط به میزانی که دقیقاً نیاز دارید هزینه می‌پردازید، و اگر از آنها استفاده نمی‌کنید، هیچ هزینه اضافی به برنامه شما تحمیل نمی‌شود.

3. **مقایسه با جایگزین‌های معادل**: 
   اگر یک برنامه‌نویس بتواند یک ویژگی زبانی یا انتزاع بنیادی (مثل توابع مجازی یا مدیریت خودکار حافظه) را به‌طور دستی و با کارایی بهتر پیاده‌سازی کند، دیگران نیز از او پیروی خواهند کرد و آن زبان را کنار خواهند گذاشت. بنابراین، ویژگی‌های C++ باید به گونه‌ای طراحی شوند که استفاده از آنها همان کارایی را داشته باشد که خود برنامه‌نویس با نوشتن کد دستی به آن می‌رسد. به عبارت دیگر، هیچ بایت حافظه یا سیکل پردازنده‌ای نباید در مقایسه با جایگزین‌های دستی هدر رود.

### مثال‌ها:
1. **الگوها (Templates)**: 
   یکی از مهم‌ترین مثال‌های این اصل، الگوها در C++ است. الگوها به گونه‌ای طراحی شده‌اند که وقتی از آن‌ها استفاده می‌کنید، کد بهینه‌ای تولید می‌شود که دقیقاً معادل کدی است که ممکن است برنامه‌نویس به صورت دستی برای انواع مختلف بنویسد. به این ترتیب، شما از قابلیت استفاده مجدد و انتزاع در کد بهره‌مند می‌شوید بدون اینکه کارایی خود را قربانی کنید.

2. **توابع درون‌خطی (Inline Functions)**: 
   توابع درون‌خطی نمونه دیگری هستند. اگر شما تابعی را به صورت inline تعریف کنید، کامپایلر تلاش می‌کند تا این تابع را مستقیماً به جای فراخوانی، در کد جایگذاری کند، به این ترتیب سربار فراخوانی تابع از بین می‌رود.

به‌طور خلاصه، اصل عدم سربار اضافی تضمین می‌کند که اگر برنامه‌نویس از یک ویژگی یا انتزاع در C++ استفاده نکند، نباید هیچ هزینه اضافی بابت آن بپردازد و اگر از آن استفاده کند، کارایی آن با کدی که دستی نوشته شده قابل مقایسه باشد.
