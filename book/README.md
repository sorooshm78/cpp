# The Design of C++
هدف یک زبان برنامه‌نویسی کمک به بیان ایده‌ها در قالب کد است. در این راستا، یک زبان برنامه‌نویسی دو وظیفه مرتبط را انجام می‌دهد: وسیله‌ای فراهم می‌کند تا برنامه‌نویس بتواند اقداماتی را که باید توسط ماشین اجرا شود، مشخص کند، و مجموعه‌ای از مفاهیم را برای برنامه‌نویس فراهم می‌کند تا از آن‌ها هنگام تفکر درباره کاری که می‌تواند انجام شود، استفاده کند. هدف اول به‌طور ایده‌آل نیاز به زبانی دارد که "نزدیک به ماشین" باشد، به‌گونه‌ای که همه جنبه‌های مهم ماشین به‌صورت ساده و کارآمد و به شکلی که برای برنامه‌نویس به‌طور معقولی واضح باشد، مدیریت شوند. زبان C عمدتاً با این هدف طراحی شده است. هدف دوم به‌طور ایده‌آل نیاز به زبانی دارد که "نزدیک به مسئله‌ای که باید حل شود" باشد، به‌گونه‌ای که مفاهیم یک راه‌حل را بتوان به‌طور مستقیم و مختصر بیان کرد. امکاناتی که به C افزوده شدند تا C++ ایجاد شود، مانند بررسی آرگومان‌های تابع، کلمه کلیدی const، کلاس‌ها، سازنده‌ها و مخرب‌ها، استثناها و قالب‌ها (templates)، عمدتاً با این هدف طراحی شده‌اند. بنابراین، C++ بر اساس این ایده استوار است که هم

- نگاشت‌های مستقیم عملیات و انواع داخلی به سخت‌افزار را برای استفاده کارآمد از حافظه و عملیات سطح پایین کارآمد فراهم کند، و
- مکانیزم‌های انتزاعی مقرون‌به‌صرفه و انعطاف‌پذیری را برای ایجاد انواع تعریف‌شده توسط کاربر با همان پشتیبانی از نشانه‌گذاری، دامنه کاربرد و عملکرد مانند انواع داخلی ارائه دهد.

اهمیت عبارت «تمایل به برنامه‌نویسی سیستم‌ها» در تعریف طولانی‌مدت من از C++ این است که C++ با حذف قابلیت‌هایی که برای استفاده در سطح تخصصی از سخت‌افزار و منابع سیستم طراحی شده‌اند، ساده‌سازی (یا مصالحه) نشده است، با این امید که آن را برای حوزه‌های کاربردی دیگر مناسب‌تر کند.

دو اصل زیر باید مورد توجه قرار گیرد:

• هیچ جایی برای زبان سطح پایین‌تری زیر C++ باقی نگذارید (به جز در موارد نادر که از کد اسمبلی استفاده می‌شود). اگر بتوان کدی با کارایی بالاتر در یک زبان سطح پایین‌تر نوشت، آن زبان احتمالاً به زبان انتخابی برای برنامه‌نویسی سیستم‌ها تبدیل خواهد شد.

• چیزی که استفاده نمی‌کنید، هزینه‌ای برای شما ندارد. اگر برنامه‌نویسان بتوانند به‌طور دستی کدی معقول برای شبیه‌سازی یک ویژگی زبانی یا انتزاع بنیادی بنویسند و حتی عملکردی کمی بهتر ارائه دهند، قطعاً کسی این کار را خواهد کرد و بسیاری از دیگران از آن تقلید خواهند کرد. بنابراین، یک ویژگی زبان و یک انتزاع بنیادی باید به گونه‌ای طراحی شود که نسبت به جایگزین‌های معادل، حتی یک بایت یا یک سیکل پردازنده را هدر ندهد. این به‌عنوان اصل «عدم سربار اضافی» شناخته می‌شود.

اصل «چیزی که استفاده نمی‌کنید، هزینه‌ای برای شما ندارد» (که به عنوان **اصل عدم سربار اضافی** یا **zero-overhead principle** شناخته می‌شود) یکی از اصول کلیدی طراحی زبان C++ است. این اصل بیان می‌کند که اگر شما از ویژگی یا قابلیت خاصی در زبان استفاده نکنید، نباید هیچ هزینه اضافی از لحاظ کارایی (مثل مصرف حافظه یا زمان پردازش) برای برنامه شما تحمیل شود.

### جزئیات بیشتر:
1. **عملکرد بهینه**: 
   این اصل بر این مبنا است که زبان باید به برنامه‌نویسان اجازه دهد تا بدون پرداخت هزینه اضافی برای ویژگی‌هایی که استفاده نمی‌کنند، به همان میزان کارایی و بهینگی که با زبان‌های سطح پایین (مثل اسمبلی یا C) می‌توان به دست آورد، دسترسی داشته باشند. به بیان دیگر، اگر شما یک قابلیت خاص مثل شی‌گرایی، استثناها یا قالب‌ها (templates) را در برنامه خود به کار نمی‌برید، نباید حتی یک بایت اضافی حافظه یا یک سیکل پردازنده بیشتر از آنچه در زبان‌های سطح پایین انتظار می‌رود مصرف شود.

2. **اجتناب از سربار ناخواسته**: 
   یکی از دلایل کلیدی که برنامه‌نویسان ممکن است یک زبان سطح پایین‌تر مثل اسمبلی را برای نوشتن کد انتخاب کنند، جلوگیری از سربار اضافی ناشی از ویژگی‌های زبان سطح بالاتر است. در C++ تلاش شده است تا این سربار حذف شود یا به حداقل برسد. به این معنا که وقتی یک ویژگی مثل کلاس‌ها یا الگوها (templates) را استفاده می‌کنید، فقط به میزانی که دقیقاً نیاز دارید هزینه می‌پردازید، و اگر از آنها استفاده نمی‌کنید، هیچ هزینه اضافی به برنامه شما تحمیل نمی‌شود.

3. **مقایسه با جایگزین‌های معادل**: 
   اگر یک برنامه‌نویس بتواند یک ویژگی زبانی یا انتزاع بنیادی (مثل توابع مجازی یا مدیریت خودکار حافظه) را به‌طور دستی و با کارایی بهتر پیاده‌سازی کند، دیگران نیز از او پیروی خواهند کرد و آن زبان را کنار خواهند گذاشت. بنابراین، ویژگی‌های C++ باید به گونه‌ای طراحی شوند که استفاده از آنها همان کارایی را داشته باشد که خود برنامه‌نویس با نوشتن کد دستی به آن می‌رسد. به عبارت دیگر، هیچ بایت حافظه یا سیکل پردازنده‌ای نباید در مقایسه با جایگزین‌های دستی هدر رود.

### مثال‌ها:
1. **الگوها (Templates)**: 
   یکی از مهم‌ترین مثال‌های این اصل، الگوها در C++ است. الگوها به گونه‌ای طراحی شده‌اند که وقتی از آن‌ها استفاده می‌کنید، کد بهینه‌ای تولید می‌شود که دقیقاً معادل کدی است که ممکن است برنامه‌نویس به صورت دستی برای انواع مختلف بنویسد. به این ترتیب، شما از قابلیت استفاده مجدد و انتزاع در کد بهره‌مند می‌شوید بدون اینکه کارایی خود را قربانی کنید.

2. **توابع درون‌خطی (Inline Functions)**: 
   توابع درون‌خطی نمونه دیگری هستند. اگر شما تابعی را به صورت inline تعریف کنید، کامپایلر تلاش می‌کند تا این تابع را مستقیماً به جای فراخوانی، در کد جایگذاری کند، به این ترتیب سربار فراخوانی تابع از بین می‌رود.

به‌طور خلاصه، اصل عدم سربار اضافی تضمین می‌کند که اگر برنامه‌نویس از یک ویژگی یا انتزاع در C++ استفاده نکند، نباید هیچ هزینه اضافی بابت آن بپردازد و اگر از آن استفاده کند، کارایی آن با کدی که دستی نوشته شده قابل مقایسه باشد.

## Programming Style
مفهوم ویژگی‌های زبان‌های برنامه‌نویسی به این معناست که آن‌ها به پشتیبانی از سبک‌های مختلف برنامه‌نویسی کمک می‌کنند. نباید به هر ویژگی زبان به عنوان یک راه‌حل مستقل نگاه کرد، بلکه باید آن را به عنوان یکی از اجزای سازنده‌ای در نظر گرفت که می‌توانند با هم ترکیب شوند تا راه‌حل‌ها را بیان کنند.

ایده‌های کلی برای طراحی و برنامه‌نویسی به سادگی قابل بیان هستند:

- ایده‌ها را به طور مستقیم در کد بیان کنید.
- ایده‌های مستقل را به طور مستقل در کد بیان کنید.
- روابط میان ایده‌ها را به طور مستقیم در کد نمایان کنید.
- ایده‌های بیان شده در کد را به طور آزاد ترکیب کنید، فقط در جایی که ترکیب‌ها منطقی است.
- ایده‌های ساده را به سادگی بیان کنید.

احساس ناخوشایندی دارم وقتی کسی C++ را به طور انحصاری از طریق یکی از این سبک‌ها توصیف می‌کند (مثلاً "C++ یک زبان شیءگرا است") یا از اصطلاحی مانند "ترکیبی" یا "چندپارادایمی" استفاده می‌کند تا به این نکته اشاره کند که یک زبان محدودتر ممکن است بهتر باشد. دیدگاه اول این واقعیت را نادیده می‌گیرد که همه این سبک‌ها به چیزی مهم در ترکیب‌بندی C++ کمک کرده‌اند؛ و دیدگاه دوم اعتبار این ترکیب را زیر سؤال می‌برد. این سبک‌ها گزینه‌های جایگزین متمایزی نیستند؛ هرکدام تکنیک‌هایی به سبک برنامه‌نویسی اضافه می‌کنند که بیانگر و کارآمدتر هستند، و C++ به‌طور مستقیم پشتیبانی زبانی برای استفاده ترکیبی از آن‌ها فراهم می‌کند.

- کلاس‌ها از تمامی سبک‌های ذکر شده پشتیبانی می‌کنند؛ همه آن‌ها به این امر متکی هستند که کاربر ایده‌ها را به صورت نوع‌های تعریف‌شده توسط کاربر یا اشیاء مربوط به نوع‌های تعریف‌شده توسط کاربر نمایش دهد.

- کنترل دسترسی عمومی/خصوصی از انتزاع داده و برنامه‌نویسی شی‌گرا پشتیبانی می‌کند، با ایجاد تمایز واضح بین واسط (interface) و پیاده‌سازی (implementation).
- توابع عضو، سازنده‌ها، مخرب‌ها و انتساب تعریف‌شده توسط کاربر یک رابط کاربردی تمیز برای اشیاء فراهم می‌کنند که در انتزاع داده و برنامه‌نویسی شی‌گرا نیاز است. آن‌ها همچنین یک نشانه‌گذاری یکنواخت برای برنامه‌نویسی جنریک فراهم می‌کنند. بارگذاری بیش از حد (overloading) عمومی‌تر باید تا سال 1984 و مقداردهی یکنواخت تا سال 2010 صبر می‌کرد.
- اعلان‌های تابع (function declarations) واسط‌های خاصی با بررسی استاتیک برای توابع عضو و همچنین توابع مستقل ارائه می‌دهند، بنابراین از همه سبک‌های ذکر شده پشتیبانی می‌کنند. این اعلان‌ها برای بارگذاری بیش از حد ضروری هستند. در آن زمان، C از "نمونه‌های تابع" (function prototypes) برخوردار نبود، اما Simula هم اعلان‌های تابع و هم توابع عضو داشت.
- توابع جنریک و نوع‌های پارامتری (که از توابع و کلاس‌ها با استفاده از ماکروها تولید می‌شدند) از برنامه‌نویسی جنریک پشتیبانی می‌کنند. تمپلیت‌ها تا سال 1988 امکان‌پذیر نبودند.
- کلاس‌های پایه و مشتق‌شده بنیان برنامه‌نویسی شی‌گرا و برخی از اشکال انتزاع داده را فراهم می‌کنند. توابع مجازی (virtual functions) باید تا سال 1983 منتظر می‌ماندند.
- استفاده از قابلیت‌های درون‌خطی (inlining) این امکانات را در برنامه‌نویسی سیستمی و برای ساخت کتابخانه‌های بهینه از نظر زمان اجرا و فضای حافظه، مقرون به صرفه کرد.

این ویژگی‌های اولیه، مکانیسم‌های انتزاع کلی هستند، نه پشتیبانی از سبک‌های برنامه‌نویسی مجزا. C++ امروزی پشتیبانی بسیار بهتری برای طراحی و برنامه‌نویسی مبتنی بر انتزاع سبک ارائه می‌دهد، اما هدف از همان ابتدا کدنویسی زیبا و کارآمد بود. توسعه‌های از سال 1981 به بعد، پشتیبانی بهتری از ترکیب سبک‌های برنامه‌نویسی (یا «پارادایم‌ها») که در ابتدا مورد توجه بودند، فراهم کردند و به طور قابل توجهی به بهبود یکپارچگی آن‌ها کمک کردند.

در C++، یک شیء بنیادی دارای هویت است؛ به این معنی که در مکان مشخصی در حافظه قرار دارد و می‌توان آن را با مقایسه آدرس‌ها از دیگر اشیاء (که ممکن است ارزش یکسانی داشته باشند) تمایز داد. عبارات نمایانگر این اشیاء را lvalue می‌نامند. با این حال، حتی از اولین روزهای زبان‌های اجدادی C++ [Barron, 1963]، اشیایی نیز وجود داشته‌اند که بدون هویت هستند (اشیائی که آدرس آن‌ها نمی‌تواند به‌طور ایمن برای استفاده‌های بعدی ذخیره شود). در C++11، این مفهوم rvalue به یک مفهوم توسعه یافته تبدیل شد که به ما امکان می‌دهد مقدار را با هزینه کم جابه‌جا کنیم. چنین اشیائی پایه تکنیک‌هایی هستند که شبیه به برنامه‌نویسی تابعی هستند (جایی که مفهوم اشیاء با هویت به شدت مورد انتقاد قرار می‌گیرد). این موضوع به خوبی تکنیک‌ها و ویژگی‌های زبانی (مانند عبارات لامبدا) که عمدتاً برای برنامه‌نویسی جنریک توسعه یافته‌اند، تکمیل می‌کند. همچنین، مشکلات کلاسیکی مرتبط با «نوع‌های داده انتزاعی ساده» را حل می‌کند، مانند اینکه چگونه به شکلی زیبا و کارآمد یک ماتریس بزرگ را از یک عملیات (مثلاً ماتریس +) بازگردانیم.


از همان ابتدا، برنامه‌های C++ و طراحی خود C++ بر مدیریت منابع متمرکز بوده‌اند. هدف این بوده (و همچنان هست) که مدیریت منابع به این صورت باشد:

- ساده (برای پیاده‌سازان و به ویژه برای کاربران)،
- عمومی (هر منبعی که باید از جایی کسب شود و بعداً آزاد شود)،
- کارآمد (مطابق با اصل «بدون هزینه اضافی»؛ §1.2)،
- کامل (هیچ نشتی قابل قبول نیست)، و
- ایمن از نظر نوع ایستا.

بسیاری از کلاس‌های مهم C++، مانند کلاس‌های استاندارد کتابخانه‌ای از جمله vector، string، thread، mutex، unique_ptr، fstream و regex، به‌عنوان دستگیره‌های منابع عمل می‌کنند. کتابخانه‌های پایه و کاربردی فراتر از کتابخانه استاندارد نیز مثال‌های بسیاری ارائه کرده‌اند، مانند Matrix و Widget. اولین گام در پشتیبانی از مفهوم دستگیره‌های منابع با ارائه سازنده‌ها (constructors) و مخرب‌ها (destructors) در اولین پیش‌نویس «C with Classes» برداشته شد. به‌زودی این ویژگی با امکان کنترل کپی از طریق تعریف انتساب و سازنده‌های کپی پشتیبانی شد. معرفی سازنده‌های جابجایی (move constructors) و انتساب‌های جابجایی (move assignments) در C++11 این خط فکری را کامل کرد و امکان جابجایی ارزان اشیاء بزرگ از یک محدوده به محدوده دیگر و کنترل ساده عمر اشیاء چندشکلی (polymorphic) یا اشتراکی (shared) را فراهم کرد.

قابلیت‌هایی که از مدیریت منابع پشتیبانی می‌کنند، همچنین برای انتزاعاتی که دستگیره منابع نیستند نیز مفید هستند. هر کلاسی که یک ویژگی ثابت (invariant) را برقرار کرده و حفظ می‌کند، به مجموعه‌ای از این ویژگی‌ها وابسته است.

## Type Checking
ارتباط بین زبانی که در آن فکر یا برنامه‌نویسی می‌کنیم و مشکلات و راه‌حل‌هایی که می‌توانیم تصور کنیم بسیار نزدیک است. به همین دلیل، محدود کردن ویژگی‌های زبان با هدف از بین بردن خطاهای برنامه‌نویس، در بهترین حالت می‌تواند خطرناک باشد. یک زبان به برنامه‌نویس مجموعه‌ای از ابزارهای مفهومی ارائه می‌دهد؛ اگر این ابزارها برای یک کار ناکافی باشند، نادیده گرفته خواهند شد. طراحی خوب و نبود خطاها نمی‌تواند صرفاً با حضور یا عدم حضور ویژگی‌های خاص زبان تضمین شود. با این حال، ویژگی‌های زبان و سیستم نوع‌بندی (type system) برای برنامه‌نویس فراهم شده‌اند تا بتواند یک طراحی را به‌طور دقیق و مختصر در کد بیان کند.

مفهوم انواع استاتیک (static types) و بررسی نوع در زمان کامپایل نقش محوری در استفاده مؤثر از C++ دارد. استفاده از انواع استاتیک برای بیان‌پذیری، نگهداری‌پذیری، و عملکرد بسیار کلیدی است. پس از Simula، طراحی انواع تعریف‌شده توسط کاربر با واسط‌هایی که در زمان کامپایل بررسی می‌شوند، اساس بیان‌پذیری C++ را تشکیل می‌دهد. سیستم نوع‌بندی C++ به روش‌های غیر بدیهی قابل گسترش است و هدف آن پشتیبانی برابر از انواع داخلی و انواع تعریف‌شده توسط کاربر است.

ویژگی‌های بررسی نوع و پنهان‌سازی داده در C++ بر تحلیل زمان کامپایل برنامه‌ها تکیه دارند تا از فساد تصادفی داده جلوگیری کنند. این ویژگی‌ها برای حفاظت در برابر فردی که عمداً قوانین را زیر پا می‌گذارد، ارائه نشده‌اند: C++ از خطاهای تصادفی محافظت می‌کند، نه از تقلب. با این حال، می‌توان این ویژگی‌ها را بدون ایجاد هزینه‌های زمانی یا فضایی در زمان اجرا به‌طور آزاد استفاده کرد. ایده اصلی این است که یک ویژگی زبانی باید نه تنها زیبا باشد، بلکه در زمینه یک برنامه واقعی نیز مقرون‌به‌صرفه باشد.

سیستم نوع‌بندی استاتیک C++ انعطاف‌پذیر است و استفاده از انواع ساده تعریف‌شده توسط کاربر تقریباً هیچ هزینه‌ای ندارد. هدف این است که سبکی از برنامه‌نویسی را پشتیبانی کنیم که ایده‌های مجزا را به عنوان انواع مجزا نشان دهد، به‌جای اینکه به‌طور عمومی از انواع کلی مانند عدد صحیح، عدد اعشاری، رشته، «حافظه خام» یا «شیء» استفاده کنیم. سبک برنامه‌نویسی غنی از نوع (type-rich) باعث می‌شود که کد خواناتر، نگهداری‌پذیرتر و قابل تحلیل‌تر باشد. سیستم نوع‌بندی پیش‌پاافتاده فقط تحلیل‌های ساده‌ای را ممکن می‌کند، در حالی که سبک غنی از نوع فرصت‌هایی را برای کشف خطاهای پیچیده و بهینه‌سازی‌ها فراهم می‌کند. کامپایلرها و ابزارهای توسعه C++ از چنین تحلیلی مبتنی بر نوع پشتیبانی می‌کنند.

حفظ بیشتر زبان C به عنوان یک زیرمجموعه و حفظ نگاشت مستقیم به سخت‌افزار که برای وظایف برنامه‌نویسی سیستم‌های سطح پایین ضروری است، به معنی امکان نقض سیستم نوع استاتیک است. با این حال، ایده‌آل من (و همیشه هم بوده) امنیت کامل نوع است. در این مورد، من با دنیس ریچی موافقم که گفت: «C یک زبان با تایپ قوی و بررسی ضعیف است.» Simula هم ایمن از نظر نوع بود و هم انعطاف‌پذیر. در واقع، ایده‌آل من وقتی که C++ را شروع کردم، «Algol68 با کلاس‌ها» بود، نه «C با کلاس‌ها». با این حال، دلایل قوی و طولانی در برابر استفاده از Algol68 به عنوان پایه کار من وجود داشت. بنابراین، امنیت کامل نوع یک ایده‌آل است که C++ به عنوان یک زبان فقط می‌تواند به آن نزدیک شود. اما این ایده‌آلی است که برنامه‌نویسان C++ (به ویژه سازندگان کتابخانه‌ها) می‌توانند برای آن تلاش کنند.

در طول سال‌ها، مجموعه ویژگی‌های زبانی، اجزای کتابخانه استاندارد، و تکنیک‌های پشتیبانی‌کننده از این ایده‌آل گسترش یافته‌اند. به جز در بخش‌های سطح پایین کد (که امیدواریم با واسط‌های ایمن از نظر نوع جدا شده باشند)، کدهایی که با کدهایی که از قراردادهای زبانی متفاوتی پیروی می‌کنند (مانند واسط تماس سیستم‌عامل) تعامل دارند، و پیاده‌سازی انتزاعات بنیادی (مانند رشته و بردار)، اکنون نیاز کمی به کدهای ناامن از نظر نوع وجود دارد.

------------ 

عبارت **«C یک زبان با تایپ قوی و بررسی ضعیف است»** که توسط **دنیس ریچی**، خالق زبان C، بیان شده است، به یکی از جنبه‌های مهم طراحی زبان C اشاره دارد. این عبارت به این معنا است که اگرچه C دارای سیستم نوع‌بندی (typing system) قوی است و انواع داده‌ها به وضوح تعریف می‌شوند، اما بررسی تطابق نوع‌ها به طور کامل و دقیق توسط کامپایلر انجام نمی‌شود.

در اینجا، این دو مفهوم را بیشتر توضیح می‌دهم:

### 1. **تایپ قوی (Strong Typing)**:
این اصطلاح به این معنا است که هر داده در C باید به یک نوع مشخص تعلق داشته باشد و این نوع در طول اجرای برنامه باید رعایت شود. مثلاً، شما نمی‌توانید یک عدد صحیح (integer) را مستقیماً به عنوان یک اشاره‌گر (pointer) استفاده کنید یا بدون تبدیل مشخص نوع‌ها، بین انواع مختلف مثل عدد صحیح و عدد اعشاری (float) جابه‌جا شوید. این رفتار، نشانه‌ای از «تایپ قوی» است که مانع از انجام عملیات ناسازگار یا غیرمجاز بین انواع مختلف داده‌ها می‌شود.

### 2. **بررسی ضعیف (Weakly Checked)**:
این به معنای این است که سیستم بررسی نوع‌ها در C به اندازه کافی دقیق نیست تا همه تطابق‌های نادرست نوعی را در زمان کامپایل یا اجرا تشخیص دهد. زبان C به برنامه‌نویس اجازه می‌دهد تا برخی از قواعد نوع‌بندی را نقض کند یا به اصطلاح **نوع‌ها را به صورت صریح (explicit) تبدیل کند**. به عنوان مثال:
   - شما می‌توانید از عملگرهای تبدیل نوع (type casting) استفاده کنید تا یک نوع داده را به نوع دیگری تبدیل کنید. این می‌تواند در بعضی مواقع به اشتباهات جدی منجر شود، زیرا کامپایلر نمی‌تواند همیشه بررسی کند که آیا این تبدیل‌ها امن هستند یا خیر.
   - مثلاً، می‌توانید اشاره‌گری به عدد صحیح را به یک اشاره‌گر به یک نوع داده دیگر تبدیل کنید و کامپایلر C این را بدون اخطار یا بررسی دقیق قبول می‌کند، حتی اگر این کار منجر به خطاهای اجرایی شود.

### مثال‌هایی از بررسی ضعیف:
- شما می‌توانید یک اشاره‌گر به `int` را به یک اشاره‌گر به `float` تبدیل کنید. C چنین تبدیل‌هایی را به عنوان عملیات قانونی قبول می‌کند، هرچند ممکن است در زمان اجرا منجر به رفتار نادرست یا حتی خرابی برنامه شود.
- در زبان C، تابع‌ها نیازی ندارند که نوع ورودی و خروجی‌شان به‌طور دقیق بررسی شود (در نسخه‌های اولیه). مثلاً اگر تابعی انتظار یک `int` بگیرد اما شما `float` ارسال کنید، کامپایلر ممکن است اخطاری ندهد یا نوع را خودکار تبدیل کند.

### مقایسه با زبان‌های با تایپ و بررسی قوی‌تر:
در مقابل، زبان‌هایی با **تایپ و بررسی قوی‌تر** (مثل Python یا Java) در زمان کامپایل یا اجرا به دقت نوع‌ها را بررسی می‌کنند و از تبدیل‌های نادرست یا ناسازگار جلوگیری می‌کنند. در این زبان‌ها، تطابق نوع‌ها دقیق‌تر بررسی می‌شود و اغلب خطاهای نوعی که در C ممکن است در زمان اجرا اتفاق بیفتد، در این زبان‌ها در زمان کامپایل یا قبل از اجرا شناسایی می‌شود.

### نتیجه‌گیری:
بنابراین، جمله ریچی به این موضوع اشاره دارد که C یک زبان با سیستم نوع‌بندی مشخص و قدرتمند است، اما به برنامه‌نویس اجازه می‌دهد که در برخی مواقع این قوانین را دور بزند و از ابزارهایی استفاده کند که کامپایلر نمی‌تواند یا نمی‌خواهد به طور کامل و دقیق صحت آن‌ها را بررسی کند. این ویژگی باعث انعطاف‌پذیری بیشتر C برای برنامه‌نویسی در سطوح پایین (مانند کار با حافظه و سخت‌افزار) می‌شود، اما در عین حال می‌تواند باعث ایجاد مشکلات پیچیده و خطاهای پنهانی در برنامه شود.

--------------

**Simula** یک زبان برنامه‌نویسی است که در دهه 1960 توسط **اول-یوهان دال** و **کریستین نیگارد** در نروژ توسعه یافت. این زبان به عنوان اولین زبان برنامه‌نویسی شی‌گرا شناخته می‌شود و تأثیر قابل‌توجهی بر طراحی و توسعه زبان‌های برنامه‌نویسی مدرن مانند C++، Java و Python داشته است.

### ویژگی‌های کلیدی Simula:
1. **شی‌گرایی (Object-Oriented Programming)**:
   Simula اولین زبان بود که مفاهیم شی‌گرایی را معرفی کرد. در این زبان، **اشیاء (objects)** و **کلاس‌ها (classes)** برای مدل‌سازی اشیاء و موجودیت‌های واقعی به کار می‌رفتند. این مفهوم پایه‌ای برای برنامه‌نویسی شی‌گرا در زبان‌های مدرن است.

2. **کلاس‌ها و وراثت (Classes and Inheritance)**:
   Simula مفاهیمی مانند کلاس‌ها را معرفی کرد که به توسعه‌دهندگان اجازه می‌دادند **اشیاء** را با خصوصیات و رفتارهای مشخصی تعریف کنند. همچنین، مفهوم **وراثت (inheritance)** به توسعه‌دهندگان اجازه می‌داد تا کلاس‌های جدیدی بر اساس کلاس‌های موجود ایجاد کنند و رفتار آن‌ها را تغییر دهند یا توسعه دهند.

3. **مدل‌سازی و شبیه‌سازی (Simulation)**:
   هدف اولیه از توسعه Simula ساخت زبانی برای **شبیه‌سازی سیستم‌های پیچیده** بود، به خصوص سیستم‌های فیزیکی و اقتصادی. نام Simula نیز از «شبیه‌سازی» گرفته شده است. این زبان به کاربران اجازه می‌داد سیستم‌هایی را با استفاده از کلاس‌ها و اشیاء مدل‌سازی کنند که با دنیای واقعی تطابق دارند.

4. **وراثت و چندریختی (Inheritance and Polymorphism)**:
   Simula مفهوم وراثت را به همراه **چندریختی (polymorphism)** معرفی کرد، که به توسعه‌دهندگان اجازه می‌دهد تا متدهایی را به طور عمومی برای کلاس‌های مختلف پیاده‌سازی کنند.

### تأثیر Simula:
در Simula تأثیر بسیار عمیقی بر زبان‌های برنامه‌نویسی مدرن داشت. به طور خاص، **C++** که توسط **بیارن استراس‌تروپ** توسعه داده شد، بسیاری از مفاهیم اصلی Simula را مانند شی‌گرایی، کلاس‌ها و وراثت به ارث برده است. Simula همچنین الهام‌بخش زبان‌هایی مانند Java و Python شد، که هر دو بر پایه مفاهیم شی‌گرایی کار می‌کنند.

### Simula و کاربردهای اصلی آن:
در ابتدا Simula برای شبیه‌سازی سیستم‌های فیزیکی، اقتصادی و سازمانی طراحی شده بود. کاربران می‌توانستند رفتار سیستم‌ها را در محیطی مجازی شبیه‌سازی کنند و نتایج مختلف را مورد بررسی قرار دهند.

### نتیجه‌گیری:
در Simula یک زبان بسیار پیشگام و نوآور بود که پایه‌های شی‌گرایی را در دنیای برنامه‌نویسی بنیان نهاد. اگرچه امروز به ندرت از آن استفاده می‌شود، اما مفاهیم و اصولی که معرفی کرد، به‌طور گسترده در اکثر زبان‌های برنامه‌نویسی مدرن به کار گرفته می‌شود.

----------------

```
???
lvalue, rvalue
```