# Abstraction Mechanism

## Introduction
این فصل تلاش می‌کند تا ایده‌ای از پشتیبانی C++ در زمینه‌ی انتزاع و مدیریت منابع ارائه دهد، بدون اینکه وارد جزئیات زیادی شود. این فصل به‌صورت غیررسمی روش‌هایی برای تعریف و استفاده از انواع جدید (انواع تعریف‌شده توسط کاربر) ارائه می‌دهد. به‌طور خاص، خصوصیات پایه‌ای، تکنیک‌های پیاده‌سازی، و امکانات زبان برای کلاس‌های مشخص، کلاس‌های انتزاعی، و سلسله‌مراتب کلاس‌ها را معرفی می‌کند. قالب‌ها (templates) به عنوان یک مکانیزم برای پارامتردهی انواع و الگوریتم‌ها با انواع و الگوریتم‌های دیگر معرفی می‌شوند. محاسبات بر روی انواع تعریف‌شده توسط کاربر و انواع داخلی به‌عنوان توابع نشان داده می‌شوند که گاهی به قالب‌های تابع و اشیای تابع تعمیم داده می‌شوند. این امکانات زبانی از سبک‌های برنامه‌نویسی پشتیبانی می‌کنند که به برنامه‌نویسی شی‌گرا و برنامه‌نویسی عمومی (generic programming) معروف هستند. دو فصل بعدی با ارائه‌ی مثال‌هایی از امکانات کتابخانه‌ی استاندارد و نحوه‌ی استفاده از آن‌ها ادامه می‌یابند.

فرض این است که شما قبلاً برنامه‌نویسی کرده‌اید. اگر این‌گونه نیست، لطفاً قبل از ادامه‌ی اینجا، کتابی مانند «Programming: Principles and Practice Using C++ [Stroustrup, 2009]» را مطالعه کنید. حتی اگر قبلاً برنامه‌نویسی کرده‌اید، ممکن است زبانی که استفاده کرده‌اید یا برنامه‌هایی که نوشته‌اید، بسیار متفاوت از سبک C++ ارائه‌شده در اینجا باشد. اگر این «تور سریع» گیج‌کننده است، به ارائه‌ی سیستماتیک‌تر از فصل ۶ بپردازید. همانند فصل ۲، این تور C++ را به‌عنوان یک کل یکپارچه ارائه می‌دهد، نه به‌عنوان یک مجموعه‌ی لایه‌ای. بنابراین، ویژگی‌های زبان را به‌عنوان موجود در C، بخشی از C++98، یا جدید در C++11 مشخص نمی‌کند. چنین اطلاعات تاریخی را می‌توانید در بخش ۱.۴ و فصل ۴۴ بیابید.

## Classes
ویژگی اصلی زبان C++، کلاس است. کلاس یک نوع تعریف‌شده توسط کاربر است که برای نمایش یک مفهوم در کد برنامه ارائه می‌شود. هر زمان که در طراحی یک برنامه، یک مفهوم، ایده، موجودیت و غیره وجود داشته باشد که مفید باشد، سعی می‌کنیم آن را به‌صورت یک کلاس در برنامه نمایان کنیم تا ایده در کد وجود داشته باشد، نه فقط در ذهن ما، در یک سند طراحی، یا در برخی توضیحات. برنامه‌ای که از مجموعه‌ای خوب از کلاس‌ها ساخته شده باشد، بسیار راحت‌تر قابل درک و درست کردن است نسبت به برنامه‌ای که همه چیز را به‌صورت مستقیم با استفاده از انواع پایه‌ای پیاده‌سازی می‌کند. به‌طور خاص، کتابخانه‌ها اغلب کلاس‌ها را ارائه می‌دهند.

اساساً تمام امکانات زبان فراتر از انواع پایه‌ای، عملگرها و دستورات وجود دارد تا به تعریف کلاس‌های بهتر یا استفاده راحت‌تر از آنها کمک کند. منظور از «بهتر» یعنی درست‌تر، آسان‌تر برای نگهداری، کارآمدتر، شیک‌تر، راحت‌تر برای استفاده، خواناتر، و آسان‌تر برای تحلیل. اکثر تکنیک‌های برنامه‌نویسی به طراحی و پیاده‌سازی انواع خاصی از کلاس‌ها تکیه دارند. نیازها و سلیقه‌های برنامه‌نویسان بسیار متفاوت است. بنابراین، پشتیبانی از کلاس‌ها گسترده است. در اینجا، فقط به پشتیبانی پایه برای سه نوع مهم از کلاس‌ها می‌پردازیم:

- کلاس‌های مشخص (Concrete classes) (§3.2.1)
- کلاس‌های انتزاعی (Abstract classes) (§3.2.2)
- کلاس‌ها در سلسله‌مراتب کلاس‌ها (Classes in class hierarchies) (§3.2.4)

تعداد شگفت‌آوری از کلاس‌های مفید از این سه نوع هستند. حتی تعداد بیشتری از کلاس‌ها را می‌توان به‌عنوان تغییرات ساده‌ای از این انواع در نظر گرفت یا با استفاده از ترکیبی از تکنیک‌هایی که برای این‌ها استفاده می‌شوند، پیاده‌سازی کرد.

## Concrete Types
ایده‌ی اصلی کلاس‌های مشخص (Concrete classes) این است که آن‌ها «دقیقاً مانند انواع پایه‌ای» رفتار می‌کنند. برای مثال، نوع عدد مختلط و عدد صحیح با دقت نامحدود، بسیار شبیه به نوع `int` پایه‌ای هستند، به‌جز اینکه طبیعتاً معنای خود و مجموعه‌ای از عملیات خاص خود را دارند. به‌طور مشابه، `vector` و `string` مانند آرایه‌های پایه‌ای هستند، به‌جز اینکه رفتار بهتری دارند.

ویژگی تعریف‌کننده‌ی یک نوع مشخص این است که نمایش آن (representation) بخشی از تعریف آن است. در بسیاری از موارد مهم، مانند `vector`، این نمایش فقط یک یا چند اشاره‌گر به داده‌های ذخیره‌شده در جای دیگری است، اما در هر شیء از کلاس مشخص حضور دارد. این به پیاده‌سازی اجازه می‌دهد تا از نظر زمانی و مکانی بهینه باشد. به‌طور خاص، این ویژگی به ما اجازه می‌دهد:

- اشیاء از انواع مشخص را روی پشته (stack)، در حافظه‌ای که به‌صورت ایستا تخصیص یافته، و در سایر اشیاء قرار دهیم.
- به اشیاء به‌طور مستقیم (و نه فقط از طریق اشاره‌گرها یا ارجاعات) دسترسی داشته باشیم.
- اشیاء را بلافاصله و به‌طور کامل مقداردهی اولیه کنیم (برای مثال، با استفاده از سازنده‌ها).
- اشیاء را کپی کنیم.

نمایش می‌تواند خصوصی (private) باشد (مانند `Vector`) و تنها از طریق توابع عضو قابل دسترسی باشد، اما حضور دارد. بنابراین، اگر نمایش به‌طور قابل توجهی تغییر کند، کاربر باید برنامه را دوباره کامپایل کند. این بهایی است که برای داشتن انواع مشخص که دقیقاً مانند انواع پایه‌ای رفتار می‌کنند، باید پرداخت. برای انواعی که اغلب تغییر نمی‌کنند و جایی که متغیرهای محلی وضوح و کارایی مورد نیاز را فراهم می‌کنند، این قابل قبول و اغلب ایده‌آل است. برای افزایش انعطاف‌پذیری، یک نوع مشخص می‌تواند بخش‌های اصلی نمایش خود را در حافظه آزاد (حافظه پویا، heap) نگه دارد و از طریق بخش ذخیره‌شده در شیء کلاس به آن‌ها دسترسی یابد. این روشی است که `vector` و `string` پیاده‌سازی شده‌اند؛ می‌توان آن‌ها را به عنوان کنترل‌کننده‌های منابع با رابط‌های دقیق و طراحی‌شده در نظر گرفت.

---

این جمله در واقع به ویژگی اصلی *Concrete Types* اشاره دارد: یعنی این نوع‌ها دارای نمایشی (representation) هستند که بخشی از تعریف آن‌ها است. به این معنا که ساختار داخلی یا نحوه‌ی ذخیره‌سازی داده‌ها در این نوع‌ها به‌طور مشخص و ثابت در تعریف آن‌ها گنجانده شده است.

در بسیاری از موارد مهم، مانند کلاس `vector`، این نمایش فقط یک یا چند اشاره‌گر (pointer) است که به داده‌هایی در جای دیگری از حافظه (مثل حافظه‌ی پویا یا heap) اشاره می‌کند. با این حال، این اشاره‌گرها به عنوان بخشی از هر شیء از این کلاس مشخص، در حافظه‌ی آن شیء ذخیره می‌شوند. 

به عبارت دیگر:

- هر *Concrete Type*، یک نمای داخلی دارد که در تعریف آن کاملاً مشخص شده است.
- این نمایش می‌تواند شامل یک یا چند اشاره‌گر به داده‌هایی باشد که خارج از شیء ذخیره شده‌اند.
- در هر شیء از نوع *Concrete Type*، این نمایش (مانند آن اشاره‌گرها) حضور دارد.

به عنوان مثال، در `std::vector`، داده‌های واقعی (عناصر آرایه) ممکن است در حافظه‌ی پویا ذخیره شوند، اما `vector` حاوی یک اشاره‌گر به این داده‌ها است و این اشاره‌گر بخشی از هر نمونه از `vector` است.

---


---

در برنامه‌نویسی، *Concrete Types* یا *Concrete Classes* به نوع‌هایی گفته می‌شود که به‌صورت کامل پیاده‌سازی شده و رفتار مشخصی دارند. این کلاس‌ها برخلاف کلاس‌های انتزاعی، تمام جزئیات مربوط به عملکردشان را دارند و می‌توانند مستقیماً در کد استفاده شوند. Concrete Types به گونه‌ای طراحی شده‌اند که رفتارشان مشابه انواع پایه‌ای (مثل `int` یا `double`) باشد، اما ویژگی‌ها و امکانات بیشتری را ارائه می‌دهند.

### Concrete Types (انواع مشخص)
انواع مشخص، نمایشی (representation) دارند که بخشی از تعریف آن‌ها است؛ یعنی نحوه‌ی ذخیره‌سازی داده‌ها در این نوع‌ها مشخص و ثابت است. به همین دلیل، Concrete Types در حافظه و پردازش بهینه هستند و می‌توانند به‌صورت زیر استفاده شوند:

- **استفاده به‌صورت متغیر محلی**: می‌توان این نوع‌ها را مستقیماً روی پشته (stack) یا در حافظه‌ای که به‌صورت ایستا تخصیص یافته، ذخیره کرد.
- **مقداردهی اولیه و کپی‌برداری**: به دلیل داشتن سازنده‌ها و امکان کپی‌برداری، این نوع‌ها را می‌توان بلافاصله و به‌طور کامل مقداردهی اولیه کرد.
- **دسترسی مستقیم**: می‌توان به داده‌های این نوع‌ها مستقیماً و بدون نیاز به اشاره‌گرها یا ارجاعات دسترسی داشت.

### مثال‌هایی از Concrete Classes
کلاس‌های مانند `std::vector` و `std::string` نمونه‌هایی از Concrete Classes در C++ هستند. آن‌ها نمایشی مشخص دارند و داده‌های خود را در حافظه‌ی پویا (heap) ذخیره می‌کنند، در حالی که به واسطه‌ی این نما و توابع عضو، رفتار مشخصی دارند و می‌توانند مانند انواع پایه‌ای استفاده شوند. 

### تفاوت با کلاس‌های انتزاعی (Abstract Classes)
برخلاف Concrete Classes، *کلاس‌های انتزاعی* حاوی یک یا چند متد مجازی خالص (pure virtual) هستند که باید در کلاس‌های مشتق‌شده پیاده‌سازی شوند. این کلاس‌ها به خودی خود نمی‌توانند نمونه‌سازی شوند و صرفاً برای تعریف رابط‌ها و رفتارهای مشترک در سلسله‌مراتب کلاس‌ها استفاده می‌شوند.

به‌طور خلاصه، Concrete Types به نوع‌هایی اشاره دارند که همه‌ی ویژگی‌های لازم برای استفاده را به‌طور کامل و واضح دارند و مستقیماً قابل استفاده در کد هستند، در حالی که Abstract Classes بیشتر برای تعریف قراردادها و واسط‌ها در سلسله‌مراتب شی‌گرایی کاربرد دارند.

---

---

این بخش توضیح می‌دهد که در *Concrete Types*، ساختار داده یا نمایش (representation) آن‌ها می‌تواند به‌صورت *خصوصی (private)* تعریف شود؛ یعنی به اعضای داخلی کلاس محدود شده و فقط از طریق توابع عضو کلاس قابل دسترسی باشد. با این حال، این نمایش همچنان در هر شیء از آن نوع وجود دارد.

به عبارت دیگر، هرچند که این نمایش به کاربران کلاس نمایش داده نمی‌شود، ولی درون هر شیء از نوع مشخص ذخیره شده است. اگر این نمایش در تعریف کلاس به شکلی اساسی تغییر کند، برنامه‌ای که از این کلاس استفاده می‌کند باید دوباره کامپایل شود. این *هزینه‌ای* است که باید برای داشتن انواع مشخصی که دقیقاً مانند انواع پایه‌ای رفتار می‌کنند، پرداخت شود.

این خصوصیت زمانی که نوع تغییرات زیادی نداشته باشد و متغیرهای محلی برای وضوح و کارایی مهم باشند، مطلوب و قابل قبول است. 

### افزایش انعطاف‌پذیری با حافظه پویا
برای اینکه این نوع‌ها انعطاف‌پذیری بیشتری داشته باشند، می‌توانند بخش‌های اصلی نمایش خود را در *حافظه پویا* (heap یا free store) ذخیره کنند و از طریق اشاره‌گرهایی که در خود شیء کلاس قرار دارد، به آن‌ها دسترسی پیدا کنند. 

مثال‌های `vector` و `string` دقیقاً به این صورت پیاده‌سازی شده‌اند:

- در `std::vector`، داده‌های واقعی (مثل عناصر آرایه) در حافظه پویا ذخیره می‌شوند، ولی اشاره‌گرهایی که به این داده‌ها اشاره می‌کنند، درون شیء `vector` ذخیره می‌شوند.
- این نوع پیاده‌سازی باعث می‌شود که `vector` و `string` مانند یک *کنترل‌کننده‌ی منابع* (resource handle) عمل کنند که واسط‌های دقیق و کاملی برای کار با داده‌ها دارند.

به‌طور خلاصه، این ساختار به کلاس‌هایی مانند `vector` و `string` امکان می‌دهد تا از حافظه پویا استفاده کنند و همزمان مزایای انعطاف‌پذیری و کارایی را ارائه دهند، بدون اینکه پیچیدگی نمای داخلی آن‌ها برای کاربران آشکار شود.

---

## An Arithmetic Type
"نوع حسابی تعریف‌شده توسط کاربر کلاسیک" در اینجا نوع `complex` است:

```cpp
class complex {
    double re, im; // نمایش: دو عدد double
public:
    complex(double r, double i) :re{r}, im{i} {} // ساختن عدد مختلط از دو عدد حقیقی
    complex(double r) :re{r}, im{0} {} // ساختن عدد مختلط از یک عدد حقیقی
    complex() :re{0}, im{0} {} // مقدار پیش‌فرض: {0,0}
    
    double real() const { return re; }
    void real(double d) { re=d; }
    double imag() const { return im; }
    void imag(double d) { im=d; }
    
    complex& operator+=(complex z) { re+=z.re , im+=z.im; return *this; } // جمع با re و im و بازگرداندن نتیجه
    complex& operator-=(complex z) { re-=z.re, im-=z.im; return *this; }
    complex& operator*=(complex); // تعریف در خارج از کلاس
    complex& operator/=(complex); // تعریف در خارج از کلاس
};
```

این نسخه‌ای کمی ساده‌شده از `complex` موجود در کتابخانه‌ی استاندارد است. خود تعریف کلاس فقط شامل عملیات‌هایی است که نیاز به دسترسی مستقیم به نمایش داخلی (re و im) دارند. نمایش داخلی این نوع ساده و متداول است. از نظر کاربردی، لازم است با پیاده‌سازی فرترن از ۵۰ سال پیش سازگار باشد و باید مجموعه‌ای از عملگرهای متداول داشته باشد. علاوه بر نیازهای منطقی، نوع `complex` باید کارآمد باشد، وگرنه مورد استفاده قرار نمی‌گیرد. این به این معناست که عملیات‌های ساده باید *درون‌خطی* (inline) باشند. 

یعنی، عملیات‌های ساده (مثل سازنده‌ها، `+=`، و `imag()`) باید بدون فراخوانی تابع در کد ماشین پیاده‌سازی شوند. توابع تعریف‌شده در کلاس به‌طور پیش‌فرض درون‌خطی هستند. یک نوع `complex` صنعتی (مانند نمونه‌ی موجود در کتابخانه‌ی استاندارد) با دقت پیاده‌سازی شده تا درون‌خطی‌سازی مناسبی انجام دهد.

سازنده‌ای که بدون آرگومان قابل فراخوانی باشد، *سازنده پیش‌فرض* نامیده می‌شود. بنابراین، `complex()` سازنده پیش‌فرض برای نوع `complex` است. با تعریف یک سازنده پیش‌فرض، احتمال داشتن متغیرهای مقداردهی‌نشده از این نوع را از بین می‌برید.

*const* در توابع بازگرداننده‌ی قسمت‌های حقیقی و موهومی نشان می‌دهد که این توابع شیء را تغییر نمی‌دهند.

بسیاری از عملیات‌های مفید نیازی به دسترسی مستقیم به نمایش `complex` ندارند، بنابراین می‌توان آن‌ها را جدا از تعریف کلاس تعریف کرد:

```cpp
complex operator+(complex a, complex b) { return a += b; }
complex operator-(complex a, complex b) { return a -= b; }
complex operator-(complex a) { return {-a.real(), -a.imag()}; } // منفی‌سازی یکانی
complex operator*(complex a, complex b) { return a *= b; }
complex operator/(complex a, complex b) { return a /= b; }
```

در اینجا از این نکته استفاده کرده‌ایم که یک آرگومان که با مقدار پاس داده می‌شود کپی می‌شود، بنابراین می‌توانیم آن را تغییر دهیم بدون اینکه نسخه‌ی فراخواننده تحت تأثیر قرار گیرد، و نتیجه را به عنوان مقدار بازگشتی استفاده کنیم.

تعاریف `==` و `!=` ساده هستند:

```cpp
bool operator==(complex a, complex b) // برابر
{
    return a.real() == b.real() && a.imag() == b.imag();
}
bool operator!=(complex a, complex b) // نابرابر
{
    return !(a == b);
}
```

در اینجا `complex` می‌تواند به این شکل استفاده شود:

```cpp
void f(complex z)
{
    complex a {2.3}; // ساختن {2.3,0.0} از 2.3
    complex b {1 / a};
    complex c {a + z * complex{1,2.3}};
    // ...
    if (c != b)
        c = -(b / a) + 2 * b;
}
```

کامپایلر، عملگرهای مربوط به اعداد مختلط را به فراخوانی تابع مناسب تبدیل می‌کند. برای مثال، `c != b` به معنی `operator!=(c, b)` و `1 / a` به معنی `operator/(complex{1}, a)` است.

عملگرهای تعریف‌شده توسط کاربر (عملگرهای "اضافه‌بارگذاری‌شده") باید با دقت و به‌صورت متعارف استفاده شوند. نحو (syntax) عملگرها توسط زبان ثابت شده است، بنابراین نمی‌توانید یک `/` یکانی تعریف کنید. همچنین امکان تغییر معنای یک عملگر برای انواع پایه‌ای وجود ندارد، بنابراین نمی‌توانید `+` را برای `int`ها طوری تعریف کنید که کم کردن انجام دهد.

