# Abstraction Mechanism

## Introduction
این فصل تلاش می‌کند تا ایده‌ای از پشتیبانی C++ در زمینه‌ی انتزاع و مدیریت منابع ارائه دهد، بدون اینکه وارد جزئیات زیادی شود. این فصل به‌صورت غیررسمی روش‌هایی برای تعریف و استفاده از انواع جدید (انواع تعریف‌شده توسط کاربر) ارائه می‌دهد. به‌طور خاص، خصوصیات پایه‌ای، تکنیک‌های پیاده‌سازی، و امکانات زبان برای کلاس‌های مشخص، کلاس‌های انتزاعی، و سلسله‌مراتب کلاس‌ها را معرفی می‌کند. قالب‌ها (templates) به عنوان یک مکانیزم برای پارامتردهی انواع و الگوریتم‌ها با انواع و الگوریتم‌های دیگر معرفی می‌شوند. محاسبات بر روی انواع تعریف‌شده توسط کاربر و انواع داخلی به‌عنوان توابع نشان داده می‌شوند که گاهی به قالب‌های تابع و اشیای تابع تعمیم داده می‌شوند. این امکانات زبانی از سبک‌های برنامه‌نویسی پشتیبانی می‌کنند که به برنامه‌نویسی شی‌گرا و برنامه‌نویسی عمومی (generic programming) معروف هستند. دو فصل بعدی با ارائه‌ی مثال‌هایی از امکانات کتابخانه‌ی استاندارد و نحوه‌ی استفاده از آن‌ها ادامه می‌یابند.

فرض این است که شما قبلاً برنامه‌نویسی کرده‌اید. اگر این‌گونه نیست، لطفاً قبل از ادامه‌ی اینجا، کتابی مانند «Programming: Principles and Practice Using C++ [Stroustrup, 2009]» را مطالعه کنید. حتی اگر قبلاً برنامه‌نویسی کرده‌اید، ممکن است زبانی که استفاده کرده‌اید یا برنامه‌هایی که نوشته‌اید، بسیار متفاوت از سبک C++ ارائه‌شده در اینجا باشد. اگر این «تور سریع» گیج‌کننده است، به ارائه‌ی سیستماتیک‌تر از فصل ۶ بپردازید. همانند فصل ۲، این تور C++ را به‌عنوان یک کل یکپارچه ارائه می‌دهد، نه به‌عنوان یک مجموعه‌ی لایه‌ای. بنابراین، ویژگی‌های زبان را به‌عنوان موجود در C، بخشی از C++98، یا جدید در C++11 مشخص نمی‌کند. چنین اطلاعات تاریخی را می‌توانید در بخش ۱.۴ و فصل ۴۴ بیابید.

## Classes
ویژگی اصلی زبان C++، کلاس است. کلاس یک نوع تعریف‌شده توسط کاربر است که برای نمایش یک مفهوم در کد برنامه ارائه می‌شود. هر زمان که در طراحی یک برنامه، یک مفهوم، ایده، موجودیت و غیره وجود داشته باشد که مفید باشد، سعی می‌کنیم آن را به‌صورت یک کلاس در برنامه نمایان کنیم تا ایده در کد وجود داشته باشد، نه فقط در ذهن ما، در یک سند طراحی، یا در برخی توضیحات. برنامه‌ای که از مجموعه‌ای خوب از کلاس‌ها ساخته شده باشد، بسیار راحت‌تر قابل درک و درست کردن است نسبت به برنامه‌ای که همه چیز را به‌صورت مستقیم با استفاده از انواع پایه‌ای پیاده‌سازی می‌کند. به‌طور خاص، کتابخانه‌ها اغلب کلاس‌ها را ارائه می‌دهند.

اساساً تمام امکانات زبان فراتر از انواع پایه‌ای، عملگرها و دستورات وجود دارد تا به تعریف کلاس‌های بهتر یا استفاده راحت‌تر از آنها کمک کند. منظور از «بهتر» یعنی درست‌تر، آسان‌تر برای نگهداری، کارآمدتر، شیک‌تر، راحت‌تر برای استفاده، خواناتر، و آسان‌تر برای تحلیل. اکثر تکنیک‌های برنامه‌نویسی به طراحی و پیاده‌سازی انواع خاصی از کلاس‌ها تکیه دارند. نیازها و سلیقه‌های برنامه‌نویسان بسیار متفاوت است. بنابراین، پشتیبانی از کلاس‌ها گسترده است. در اینجا، فقط به پشتیبانی پایه برای سه نوع مهم از کلاس‌ها می‌پردازیم:

- کلاس‌های مشخص (Concrete classes) (§3.2.1)
- کلاس‌های انتزاعی (Abstract classes) (§3.2.2)
- کلاس‌ها در سلسله‌مراتب کلاس‌ها (Classes in class hierarchies) (§3.2.4)

تعداد شگفت‌آوری از کلاس‌های مفید از این سه نوع هستند. حتی تعداد بیشتری از کلاس‌ها را می‌توان به‌عنوان تغییرات ساده‌ای از این انواع در نظر گرفت یا با استفاده از ترکیبی از تکنیک‌هایی که برای این‌ها استفاده می‌شوند، پیاده‌سازی کرد.

## Concrete Types
ایده‌ی اصلی کلاس‌های مشخص (Concrete classes) این است که آن‌ها «دقیقاً مانند انواع پایه‌ای» رفتار می‌کنند. برای مثال، نوع عدد مختلط و عدد صحیح با دقت نامحدود، بسیار شبیه به نوع `int` پایه‌ای هستند، به‌جز اینکه طبیعتاً معنای خود و مجموعه‌ای از عملیات خاص خود را دارند. به‌طور مشابه، `vector` و `string` مانند آرایه‌های پایه‌ای هستند، به‌جز اینکه رفتار بهتری دارند.

ویژگی تعریف‌کننده‌ی یک نوع مشخص این است که نمایش آن (representation) بخشی از تعریف آن است. در بسیاری از موارد مهم، مانند `vector`، این نمایش فقط یک یا چند اشاره‌گر به داده‌های ذخیره‌شده در جای دیگری است، اما در هر شیء از کلاس مشخص حضور دارد. این به پیاده‌سازی اجازه می‌دهد تا از نظر زمانی و مکانی بهینه باشد. به‌طور خاص، این ویژگی به ما اجازه می‌دهد:

- اشیاء از انواع مشخص را روی پشته (stack)، در حافظه‌ای که به‌صورت ایستا تخصیص یافته، و در سایر اشیاء قرار دهیم.
- به اشیاء به‌طور مستقیم (و نه فقط از طریق اشاره‌گرها یا ارجاعات) دسترسی داشته باشیم.
- اشیاء را بلافاصله و به‌طور کامل مقداردهی اولیه کنیم (برای مثال، با استفاده از سازنده‌ها).
- اشیاء را کپی کنیم.

نمایش می‌تواند خصوصی (private) باشد (مانند `Vector`) و تنها از طریق توابع عضو قابل دسترسی باشد، اما حضور دارد. بنابراین، اگر نمایش به‌طور قابل توجهی تغییر کند، کاربر باید برنامه را دوباره کامپایل کند. این بهایی است که برای داشتن انواع مشخص که دقیقاً مانند انواع پایه‌ای رفتار می‌کنند، باید پرداخت. برای انواعی که اغلب تغییر نمی‌کنند و جایی که متغیرهای محلی وضوح و کارایی مورد نیاز را فراهم می‌کنند، این قابل قبول و اغلب ایده‌آل است. برای افزایش انعطاف‌پذیری، یک نوع مشخص می‌تواند بخش‌های اصلی نمایش خود را در حافظه آزاد (حافظه پویا، heap) نگه دارد و از طریق بخش ذخیره‌شده در شیء کلاس به آن‌ها دسترسی یابد. این روشی است که `vector` و `string` پیاده‌سازی شده‌اند؛ می‌توان آن‌ها را به عنوان کنترل‌کننده‌های منابع با رابط‌های دقیق و طراحی‌شده در نظر گرفت.

---

این جمله در واقع به ویژگی اصلی *Concrete Types* اشاره دارد: یعنی این نوع‌ها دارای نمایشی (representation) هستند که بخشی از تعریف آن‌ها است. به این معنا که ساختار داخلی یا نحوه‌ی ذخیره‌سازی داده‌ها در این نوع‌ها به‌طور مشخص و ثابت در تعریف آن‌ها گنجانده شده است.

در بسیاری از موارد مهم، مانند کلاس `vector`، این نمایش فقط یک یا چند اشاره‌گر (pointer) است که به داده‌هایی در جای دیگری از حافظه (مثل حافظه‌ی پویا یا heap) اشاره می‌کند. با این حال، این اشاره‌گرها به عنوان بخشی از هر شیء از این کلاس مشخص، در حافظه‌ی آن شیء ذخیره می‌شوند. 

به عبارت دیگر:

- هر *Concrete Type*، یک نمای داخلی دارد که در تعریف آن کاملاً مشخص شده است.
- این نمایش می‌تواند شامل یک یا چند اشاره‌گر به داده‌هایی باشد که خارج از شیء ذخیره شده‌اند.
- در هر شیء از نوع *Concrete Type*، این نمایش (مانند آن اشاره‌گرها) حضور دارد.

به عنوان مثال، در `std::vector`، داده‌های واقعی (عناصر آرایه) ممکن است در حافظه‌ی پویا ذخیره شوند، اما `vector` حاوی یک اشاره‌گر به این داده‌ها است و این اشاره‌گر بخشی از هر نمونه از `vector` است.

---


---

در برنامه‌نویسی، *Concrete Types* یا *Concrete Classes* به نوع‌هایی گفته می‌شود که به‌صورت کامل پیاده‌سازی شده و رفتار مشخصی دارند. این کلاس‌ها برخلاف کلاس‌های انتزاعی، تمام جزئیات مربوط به عملکردشان را دارند و می‌توانند مستقیماً در کد استفاده شوند. Concrete Types به گونه‌ای طراحی شده‌اند که رفتارشان مشابه انواع پایه‌ای (مثل `int` یا `double`) باشد، اما ویژگی‌ها و امکانات بیشتری را ارائه می‌دهند.

### Concrete Types (انواع مشخص)
انواع مشخص، نمایشی (representation) دارند که بخشی از تعریف آن‌ها است؛ یعنی نحوه‌ی ذخیره‌سازی داده‌ها در این نوع‌ها مشخص و ثابت است. به همین دلیل، Concrete Types در حافظه و پردازش بهینه هستند و می‌توانند به‌صورت زیر استفاده شوند:

- **استفاده به‌صورت متغیر محلی**: می‌توان این نوع‌ها را مستقیماً روی پشته (stack) یا در حافظه‌ای که به‌صورت ایستا تخصیص یافته، ذخیره کرد.
- **مقداردهی اولیه و کپی‌برداری**: به دلیل داشتن سازنده‌ها و امکان کپی‌برداری، این نوع‌ها را می‌توان بلافاصله و به‌طور کامل مقداردهی اولیه کرد.
- **دسترسی مستقیم**: می‌توان به داده‌های این نوع‌ها مستقیماً و بدون نیاز به اشاره‌گرها یا ارجاعات دسترسی داشت.

### مثال‌هایی از Concrete Classes
کلاس‌های مانند `std::vector` و `std::string` نمونه‌هایی از Concrete Classes در C++ هستند. آن‌ها نمایشی مشخص دارند و داده‌های خود را در حافظه‌ی پویا (heap) ذخیره می‌کنند، در حالی که به واسطه‌ی این نما و توابع عضو، رفتار مشخصی دارند و می‌توانند مانند انواع پایه‌ای استفاده شوند. 

### تفاوت با کلاس‌های انتزاعی (Abstract Classes)
برخلاف Concrete Classes، *کلاس‌های انتزاعی* حاوی یک یا چند متد مجازی خالص (pure virtual) هستند که باید در کلاس‌های مشتق‌شده پیاده‌سازی شوند. این کلاس‌ها به خودی خود نمی‌توانند نمونه‌سازی شوند و صرفاً برای تعریف رابط‌ها و رفتارهای مشترک در سلسله‌مراتب کلاس‌ها استفاده می‌شوند.

به‌طور خلاصه، Concrete Types به نوع‌هایی اشاره دارند که همه‌ی ویژگی‌های لازم برای استفاده را به‌طور کامل و واضح دارند و مستقیماً قابل استفاده در کد هستند، در حالی که Abstract Classes بیشتر برای تعریف قراردادها و واسط‌ها در سلسله‌مراتب شی‌گرایی کاربرد دارند.

---

---

این بخش توضیح می‌دهد که در *Concrete Types*، ساختار داده یا نمایش (representation) آن‌ها می‌تواند به‌صورت *خصوصی (private)* تعریف شود؛ یعنی به اعضای داخلی کلاس محدود شده و فقط از طریق توابع عضو کلاس قابل دسترسی باشد. با این حال، این نمایش همچنان در هر شیء از آن نوع وجود دارد.

به عبارت دیگر، هرچند که این نمایش به کاربران کلاس نمایش داده نمی‌شود، ولی درون هر شیء از نوع مشخص ذخیره شده است. اگر این نمایش در تعریف کلاس به شکلی اساسی تغییر کند، برنامه‌ای که از این کلاس استفاده می‌کند باید دوباره کامپایل شود. این *هزینه‌ای* است که باید برای داشتن انواع مشخصی که دقیقاً مانند انواع پایه‌ای رفتار می‌کنند، پرداخت شود.

این خصوصیت زمانی که نوع تغییرات زیادی نداشته باشد و متغیرهای محلی برای وضوح و کارایی مهم باشند، مطلوب و قابل قبول است. 

### افزایش انعطاف‌پذیری با حافظه پویا
برای اینکه این نوع‌ها انعطاف‌پذیری بیشتری داشته باشند، می‌توانند بخش‌های اصلی نمایش خود را در *حافظه پویا* (heap یا free store) ذخیره کنند و از طریق اشاره‌گرهایی که در خود شیء کلاس قرار دارد، به آن‌ها دسترسی پیدا کنند. 

مثال‌های `vector` و `string` دقیقاً به این صورت پیاده‌سازی شده‌اند:

- در `std::vector`، داده‌های واقعی (مثل عناصر آرایه) در حافظه پویا ذخیره می‌شوند، ولی اشاره‌گرهایی که به این داده‌ها اشاره می‌کنند، درون شیء `vector` ذخیره می‌شوند.
- این نوع پیاده‌سازی باعث می‌شود که `vector` و `string` مانند یک *کنترل‌کننده‌ی منابع* (resource handle) عمل کنند که واسط‌های دقیق و کاملی برای کار با داده‌ها دارند.

به‌طور خلاصه، این ساختار به کلاس‌هایی مانند `vector` و `string` امکان می‌دهد تا از حافظه پویا استفاده کنند و همزمان مزایای انعطاف‌پذیری و کارایی را ارائه دهند، بدون اینکه پیچیدگی نمای داخلی آن‌ها برای کاربران آشکار شود.

---

## An Arithmetic Type
"نوع حسابی تعریف‌شده توسط کاربر کلاسیک" در اینجا نوع `complex` است:

```cpp
class complex {
    double re, im; // نمایش: دو عدد double
public:
    complex(double r, double i) :re{r}, im{i} {} // ساختن عدد مختلط از دو عدد حقیقی
    complex(double r) :re{r}, im{0} {} // ساختن عدد مختلط از یک عدد حقیقی
    complex() :re{0}, im{0} {} // مقدار پیش‌فرض: {0,0}
    
    double real() const { return re; }
    void real(double d) { re=d; }
    double imag() const { return im; }
    void imag(double d) { im=d; }
    
    complex& operator+=(complex z) { re+=z.re , im+=z.im; return *this; } // جمع با re و im و بازگرداندن نتیجه
    complex& operator-=(complex z) { re-=z.re, im-=z.im; return *this; }
    complex& operator*=(complex); // تعریف در خارج از کلاس
    complex& operator/=(complex); // تعریف در خارج از کلاس
};
```

این نسخه‌ای کمی ساده‌شده از `complex` موجود در کتابخانه‌ی استاندارد است. خود تعریف کلاس فقط شامل عملیات‌هایی است که نیاز به دسترسی مستقیم به نمایش داخلی (re و im) دارند. نمایش داخلی این نوع ساده و متداول است. از نظر کاربردی، لازم است با پیاده‌سازی فرترن از ۵۰ سال پیش سازگار باشد و باید مجموعه‌ای از عملگرهای متداول داشته باشد. علاوه بر نیازهای منطقی، نوع `complex` باید کارآمد باشد، وگرنه مورد استفاده قرار نمی‌گیرد. این به این معناست که عملیات‌های ساده باید *درون‌خطی* (inline) باشند. 

یعنی، عملیات‌های ساده (مثل سازنده‌ها، `+=`، و `imag()`) باید بدون فراخوانی تابع در کد ماشین پیاده‌سازی شوند. توابع تعریف‌شده در کلاس به‌طور پیش‌فرض درون‌خطی هستند. یک نوع `complex` صنعتی (مانند نمونه‌ی موجود در کتابخانه‌ی استاندارد) با دقت پیاده‌سازی شده تا درون‌خطی‌سازی مناسبی انجام دهد.

سازنده‌ای که بدون آرگومان قابل فراخوانی باشد، *سازنده پیش‌فرض* نامیده می‌شود. بنابراین، `complex()` سازنده پیش‌فرض برای نوع `complex` است. با تعریف یک سازنده پیش‌فرض، احتمال داشتن متغیرهای مقداردهی‌نشده از این نوع را از بین می‌برید.

*const* در توابع بازگرداننده‌ی قسمت‌های حقیقی و موهومی نشان می‌دهد که این توابع شیء را تغییر نمی‌دهند.

بسیاری از عملیات‌های مفید نیازی به دسترسی مستقیم به نمایش `complex` ندارند، بنابراین می‌توان آن‌ها را جدا از تعریف کلاس تعریف کرد:

```cpp
complex operator+(complex a, complex b) { return a += b; }
complex operator-(complex a, complex b) { return a -= b; }
complex operator-(complex a) { return {-a.real(), -a.imag()}; } // منفی‌سازی یکانی
complex operator*(complex a, complex b) { return a *= b; }
complex operator/(complex a, complex b) { return a /= b; }
```

در اینجا از این نکته استفاده کرده‌ایم که یک آرگومان که با مقدار پاس داده می‌شود کپی می‌شود، بنابراین می‌توانیم آن را تغییر دهیم بدون اینکه نسخه‌ی فراخواننده تحت تأثیر قرار گیرد، و نتیجه را به عنوان مقدار بازگشتی استفاده کنیم.

تعاریف `==` و `!=` ساده هستند:

```cpp
bool operator==(complex a, complex b) // برابر
{
    return a.real() == b.real() && a.imag() == b.imag();
}
bool operator!=(complex a, complex b) // نابرابر
{
    return !(a == b);
}
```

در اینجا `complex` می‌تواند به این شکل استفاده شود:

```cpp
void f(complex z)
{
    complex a {2.3}; // ساختن {2.3,0.0} از 2.3
    complex b {1 / a};
    complex c {a + z * complex{1,2.3}};
    // ...
    if (c != b)
        c = -(b / a) + 2 * b;
}
```

کامپایلر، عملگرهای مربوط به اعداد مختلط را به فراخوانی تابع مناسب تبدیل می‌کند. برای مثال، `c != b` به معنی `operator!=(c, b)` و `1 / a` به معنی `operator/(complex{1}, a)` است.

عملگرهای تعریف‌شده توسط کاربر (عملگرهای "اضافه‌بارگذاری‌شده") باید با دقت و به‌صورت متعارف استفاده شوند. نحو (syntax) عملگرها توسط زبان ثابت شده است، بنابراین نمی‌توانید یک `/` یکانی تعریف کنید. همچنین امکان تغییر معنای یک عملگر برای انواع پایه‌ای وجود ندارد، بنابراین نمی‌توانید `+` را برای `int`ها طوری تعریف کنید که کم کردن انجام دهد.

## A Container
یک *container* (مخزن) شی‌ای است که مجموعه‌ای از عناصر را نگه می‌دارد، بنابراین به `Vector` یک *container* می‌گوییم چون نوعی از اشیاء است که مخزن هستند. همان‌طور که در بخش ۲.۳.۲ تعریف شده است، `Vector` برای ذخیره‌ی اعداد `double` چندان نامعقول نیست: این کلاس به‌سادگی قابل فهم است، یک خاصیت ثابت و مفید ایجاد می‌کند (بخش ۲.۴.۳.۲)، دسترسی بررسی‌شده در بازه ارائه می‌دهد (بخش ۲.۴.۳.۱)، و تابع `size()` را برای پیمایش عناصر فراهم می‌کند. با این حال، یک ایراد اساسی دارد: عناصر را با `new` تخصیص می‌دهد، اما هرگز آن‌ها را آزاد نمی‌کند. این روش مناسب نیست، زیرا اگرچه C++ یک رابط برای جمع‌آوری زباله (garbage collector) تعریف می‌کند (بخش ۳۴.۵)، اما تضمینی نیست که در دسترس باشد تا حافظه‌ی استفاده‌نشده را برای اشیاء جدید آزاد کند. در برخی محیط‌ها نمی‌توانید از جمع‌آوری زباله استفاده کنید، و گاهی به دلایل منطقی یا کارایی، کنترل دقیق‌تری بر تخریب اشیاء ترجیح می‌دهید (بخش ۱۳.۶.۴). ما به مکانیزمی نیاز داریم که اطمینان حاصل کند حافظه‌ای که توسط سازنده تخصیص داده شده، آزاد شود؛ این مکانیزم یک *destructor* است:

```cpp
class Vector {
private:
    double* elem; // elem به آرایه‌ای از sz عدد double اشاره می‌کند
    int sz;
public:
    Vector(int s) :elem{new double[s]}, sz{s} // سازنده: تخصیص منابع
    {
        for (int i = 0; i != s; ++i) elem[i] = 0; // مقداردهی اولیه به عناصر
    }
    ~Vector() { delete[] elem; } // مخرب: آزادسازی منابع
    double& operator[](int i);
    int size() const;
};
```

در اینجا:

- سازنده `Vector(int s)` حافظه‌ای برای `s` عدد `double` تخصیص می‌دهد و مقدار اولیه‌ی هر عنصر را `0` قرار می‌دهد.
- مخرب `~Vector()` با `delete[] elem` حافظه‌ی تخصیص‌یافته را آزاد می‌کند تا از نشت حافظه (memory leak) جلوگیری شود.

نام یک مخرب (*destructor*) شامل عملگر مکمل (`~`) است که به دنبال آن نام کلاس می‌آید؛ به‌عنوان مکملی برای سازنده (*constructor*) عمل می‌کند. سازنده‌ی `Vector` مقداری حافظه را در حافظه‌ی آزاد (که به آن heap یا dynamic store هم می‌گویند) با استفاده از عملگر `new` تخصیص می‌دهد. مخرب، با استفاده از عملگر `delete` این حافظه را آزاد کرده و پاک‌سازی را انجام می‌دهد. این همه به‌صورت خودکار و بدون نیاز به مداخله‌ی کاربران `Vector` انجام می‌شود. کاربران تنها `Vector`‌ها را ایجاد کرده و مانند متغیرهای انواع پایه‌ای از آن‌ها استفاده می‌کنند. برای مثال:

```cpp
void fct(int n)
{
    Vector v(n);
    // ... استفاده از v ...
    {
        Vector v2(2 * n);
        // ... استفاده از v و v2 ...
    } // v2 در اینجا از بین می‌رود
    // ... استفاده از v ...
} // v در اینجا از بین می‌رود
```

در اینجا:

- وقتی `v` و `v2` به‌طور محلی تعریف می‌شوند، سازنده‌ی آن‌ها به‌طور خودکار فراخوانی می‌شود و حافظه موردنیاز آن‌ها را تخصیص می‌دهد.
- وقتی بلوک‌های آن‌ها به پایان می‌رسد (در پایان بلوک‌های مربوطه)، مخرب‌ها به‌طور خودکار فراخوانی می‌شوند و حافظه‌ی تخصیص‌یافته را آزاد می‌کنند.

در `Vector` قوانین نام‌گذاری، حوزه، تخصیص، طول عمر و غیره دقیقاً مانند یک نوع پایه‌ای، مثل `int` و `char` رعایت می‌شود. برای جزئیات در مورد چگونگی کنترل طول عمر یک شیء، به بخش ۶.۴ مراجعه کنید. این نسخه از `Vector` ساده‌سازی شده و شامل مدیریت خطا نمی‌شود؛ برای مدیریت خطا به بخش ۲.۴.۳ مراجعه کنید.

ترکیب سازنده و مخرب پایه‌ی بسیاری از تکنیک‌های زیبا و کارآمد است. به‌طور خاص، این ترکیب مبنای بیشتر تکنیک‌های عمومی مدیریت منابع در C++ است (بخش ۵.۲ و ۱۳.۳). در نظر بگیرید که سازنده‌ی `Vector` عناصر را تخصیص می‌دهد و اعضای `Vector` را به‌طور مناسب مقداردهی اولیه می‌کند. مخرب نیز عناصر را آزاد می‌کند. این مدل *دستگیره به داده‌ها* (handle-to-data model) به طور گسترده برای مدیریت داده‌هایی استفاده می‌شود که اندازه‌ی آن‌ها در طول عمر شیء تغییر می‌کند. تکنیک به‌دست‌آوردن منابع در سازنده و آزادسازی آن‌ها در مخرب که به عنوان *RAII (Resource Acquisition Is Initialization)* شناخته می‌شود، به ما اجازه می‌دهد تا از «عملیات new خالص» خودداری کنیم؛ یعنی تخصیص حافظه را از کد عمومی حذف کنیم و آن‌ها را درون پیاده‌سازی‌های انتزاعی خوب پنهان کنیم. به‌همین ترتیب، باید از «عملیات delete خالص» نیز اجتناب کرد. اجتناب از `new` و `delete` خالص، کد را بسیار کم‌خطاتر می‌کند و احتمال نشت منابع را کاهش می‌دهد (بخش ۵.۲).

---

این بخش به مفهومی کلیدی در C++ به نام *RAII* (Resource Acquisition Is Initialization) می‌پردازد که برای مدیریت کارآمد منابع به کار می‌رود. 

### ۱. رفتار مشابه انواع پایه‌ای
در C++، کلاس `Vector` مانند انواع پایه‌ای (مثل `int` و `char`) از قوانین نام‌گذاری، محدوده (scope)، تخصیص و طول عمر پیروی می‌کند. این به این معنی است که می‌توان از `Vector` درست مثل یک نوع پایه‌ای استفاده کرد و انتظار داشت که به طور خودکار از بین برود وقتی که محدوده‌ی آن به پایان می‌رسد. برای کنترل طول عمر یک شیء، می‌توان به جزئیات موجود در بخش ۶.۴ مراجعه کرد.

### ۲. ترکیب سازنده و مخرب
سازنده و مخرب در C++ تکنیک‌های کارآمد و ظریفی را ایجاد می‌کنند. به طور خاص، این ترکیب اساس مدیریت منابع در C++ است. برای مثال، در کلاس `Vector`:

- **سازنده**: مسئول تخصیص حافظه‌ی موردنیاز برای عناصر `Vector` و مقداردهی اولیه به آن‌ها است.
- **مخرب**: مسئول آزاد کردن حافظه‌ی تخصیص‌یافته به هنگام از بین رفتن `Vector` است.

این مدل *«اشاره‌گر به داده‌ها»* (handle-to-data model) به‌صورت گسترده برای مدیریت داده‌هایی که اندازه‌ی آن‌ها در طول عمر شیء تغییر می‌کند، به کار می‌رود.

### ۳. تکنیک RAII
این *RAII*، یا *Resource Acquisition Is Initialization*، به معنای «دریافت منابع در زمان مقداردهی اولیه» است و ایده‌ای بسیار مهم در C++ برای مدیریت منابع است. 

- در RAII، منابع (مانند حافظه، فایل‌ها، یا قفل‌های سیستم) در سازنده‌ها تخصیص می‌یابند و در مخرب‌ها آزاد می‌شوند.
- این روش به ما کمک می‌کند تا از تخصیص مستقیم حافظه با استفاده از `new` در کد عمومی جلوگیری کنیم و این تخصیص‌ها را در داخل پیاده‌سازی کلاس‌ها نگه داریم.
- همچنین RAII از عملیات `delete` مستقیم نیز جلوگیری می‌کند. 

### مزایای استفاده از RAII
با جلوگیری از تخصیص و آزادسازی مستقیم منابع (`naked new` و `naked delete`)، این تکنیک کد را بسیار امن‌تر و کمتر مستعد خطا می‌کند. با استفاده از RAII:

1. **نشت منابع** به حداقل می‌رسد، زیرا هر شیء که از بین برود، مخرب آن به طور خودکار منابع تخصیص‌یافته را آزاد می‌کند.
2. **مدیریت خودکار منابع** ایجاد می‌شود، زیرا سازنده و مخرب به طور خودکار اجرا می‌شوند و نیازی به مدیریت دستی منابع نداریم.

به عنوان مثال، با استفاده از `Vector`، کد به این صورت خواهد بود:

```cpp
void exampleFunction(int n) {
    Vector v(n); // سازنده، حافظه را تخصیص می‌دهد
    // ... استفاده از v ...
} // در اینجا، v از بین می‌رود و مخرب حافظه را آزاد می‌کند
```

در این کد، نیازی به `new` و `delete` نیست و تمام تخصیص و آزادسازی حافظه به صورت خودکار انجام می‌شود.

---

RAII یا *Resource Acquisition Is Initialization* به معنای «دریافت منابع در زمان مقداردهی اولیه» است و یکی از مهم‌ترین اصول مدیریت منابع در C++ به شمار می‌رود. ایده‌ی اصلی RAII این است که منابعی مانند حافظه، فایل، یا قفل‌های سیستم، هم‌زمان با ایجاد یک شیء در سازنده‌ی آن تخصیص داده شوند و به محض از بین رفتن شیء، توسط مخرب آن آزاد شوند.

### مثال ساده RAII

فرض کنید که می‌خواهیم یک فایل را باز کنیم و داده‌هایی در آن بنویسیم. در حالت معمول، باید فایل را باز کنیم، عملیات مورد نظر را انجام دهیم و سپس فایل را ببندیم. اگر بستن فایل را فراموش کنیم یا یک خطا پیش بیاید، ممکن است فایل باز بماند و منابع سیستم اشغال شوند.

با RAII، این کار به این صورت انجام می‌شود که باز کردن و بستن فایل را در یک کلاس قرار می‌دهیم و فایل هم‌زمان با ساختن شیء باز می‌شود و هنگام از بین رفتن شیء، بسته می‌شود.

### پیاده‌سازی با استفاده از RAII

در این مثال، کلاسی به نام `FileHandler` ایجاد می‌کنیم که به محض ساخت شیء، فایل را باز می‌کند و هنگام از بین رفتن شیء، فایل را می‌بندد:

```cpp
#include <iostream>
#include <fstream>
#include <string>

class FileHandler {
private:
    std::ofstream file;
public:
    // سازنده: باز کردن فایل
    FileHandler(const std::string& filename) {
        file.open(filename);
        if (!file.is_open()) {
            std::cerr << "Failed to open file!" << std::endl;
        }
    }

    // تابعی برای نوشتن در فایل
    void write(const std::string& text) {
        if (file.is_open()) {
            file << text << std::endl;
        }
    }

    // مخرب: بستن فایل
    ~FileHandler() {
        if (file.is_open()) {
            file.close();
            std::cout << "File closed." << std::endl;
        }
    }
};
```

### استفاده از کلاس `FileHandler`

حالا می‌توانیم از `FileHandler` استفاده کنیم و مطمئن باشیم که فایل به‌طور خودکار بسته می‌شود، حتی اگر خطایی رخ دهد:

```cpp
void exampleFunction() {
    FileHandler fh("example.txt"); // فایل باز می‌شود
    fh.write("Hello, RAII!"); // نوشتن در فایل
} // در اینجا fh از بین می‌رود و فایل بسته می‌شود
```

در این کد:

1. با ایجاد شیء `fh` از نوع `FileHandler`، فایل `"example.txt"` به طور خودکار باز می‌شود.
2. عملیات نوشتن روی فایل انجام می‌شود.
3. هنگامی که `fh` از محدوده خارج می‌شود، مخرب آن به طور خودکار اجرا شده و فایل بسته می‌شود.

### مزایای RAII

- **کاهش خطا**: نیازی به یادآوری بستن فایل نداریم؛ RAII این کار را به‌طور خودکار انجام می‌دهد.
- **جلوگیری از نشت منابع**: اگر خطایی پیش بیاید، فایل باز نمی‌ماند و از بین می‌رود.
- **کد تمیزتر و خواناتر**: کد اصلی تنها نیاز به ساخت شیء و استفاده از آن دارد، بدون نیاز به مدیریت دستی منابع.

RAII به همین روش می‌تواند برای مدیریت حافظه، قفل‌ها و سایر منابعی که نیاز به آزادسازی دارند، به کار برود و کد را ساده‌تر و ایمن‌تر کند.

---

در برنامه‌نویسی C++، *naked new operations* به تخصیص حافظه با استفاده از عملگر `new` به صورت مستقیم اشاره دارد، به طوری که این تخصیص خارج از یک ساختار مدیریت منابع انجام می‌شود و به همین دلیل *naked* یا «برهنه» نامیده می‌شود. 

### چرا `naked new` یک مشکل محسوب می‌شود؟

وقتی از `new` به صورت مستقیم استفاده می‌کنیم، حافظه در *heap* یا حافظه‌ی پویا تخصیص داده می‌شود و برای آزادسازی آن باید حتماً از `delete` استفاده کنیم. اگر `delete` را فراموش کنیم یا در هنگام بروز خطا به آن دسترسی پیدا نکنیم، ممکن است نشت حافظه (*memory leak*) رخ دهد. این نشت باعث می‌شود که حافظه‌ای که تخصیص داده شده، به سیستم بازگردانده نشود و در نتیجه منابع سیستم هدر برود.

### مثال یک `naked new`

در مثال زیر، از `new` برای ایجاد یک شیء به صورت مستقیم استفاده شده است:

```cpp
int main() {
    int* ptr = new int(10); // تخصیص مستقیم حافظه با new
    // برخی عملیات روی ptr
    // فراموشی delete باعث نشت حافظه می‌شود
}
```

در این کد:

- حافظه‌ای برای یک `int` تخصیص داده شده است و `ptr` به آن اشاره می‌کند.
- اگر `delete ptr` را فراموش کنیم، حافظه آزاد نمی‌شود و به یک نشت حافظه منجر می‌شود.

### راه‌حل: استفاده از RAII و اجتناب از `naked new`

برای جلوگیری از این مشکل، می‌توان از تکنیک *RAII* استفاده کرد. در RAII، تخصیص حافظه و آزادسازی آن در سازنده و مخرب یک کلاس مدیریت می‌شود. به این ترتیب، هرگاه یک شیء از این کلاس ساخته شود، حافظه به طور خودکار تخصیص داده می‌شود و زمانی که از بین می‌رود، حافظه نیز آزاد می‌شود.

### مثال با استفاده از RAII

در این مثال از کلاس `std::unique_ptr` استفاده می‌کنیم که به عنوان یک کلاس مدیریت حافظه هوشمند در C++ استاندارد تعریف شده است:

```cpp
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // تخصیص خودکار حافظه
    // برخی عملیات روی ptr
} // ptr به طور خودکار از بین می‌رود و حافظه آزاد می‌شود
```

در اینجا:

- با استفاده از `std::unique_ptr`، تخصیص حافظه و آزادسازی آن به صورت خودکار انجام می‌شود.
- نیازی به `delete` نداریم؛ وقتی `ptr` از بین می‌رود، حافظه‌ی مربوطه نیز به طور خودکار آزاد می‌شود.

### مزایای اجتناب از `naked new`

1. **کاهش خطا**: نیازی به `delete` دستی نیست، و این باعث کاهش احتمال نشت حافظه می‌شود.
2. **کد خواناتر و تمیزتر**: مدیریت حافظه درون یک ساختار مشخص انجام می‌شود، که کد را قابل فهم‌تر می‌کند.
3. **افزایش ایمنی**: در صورت بروز خطا یا خروج زودهنگام از بلوک کد، حافظه به طور خودکار آزاد می‌شود.

به طور خلاصه، اجتناب از `naked new` باعث می‌شود که کد ایمن‌تر و کمتر مستعد نشت حافظه باشد. RAII و استفاده از پوینترهای هوشمند مانند `std::unique_ptr` و `std::shared_ptr` راه‌حل‌های مناسبی برای مدیریت خودکار منابع و جلوگیری از مشکلات `naked new` هستند.

## Initializing Containers
یک *container* (مخزن) برای نگهداری عناصر ایجاد شده است، بنابراین بدیهی است که به روش‌های ساده‌ای برای قرار دادن عناصر در یک container نیاز داریم. می‌توانیم این کار را با ایجاد یک `Vector` با تعداد مناسب عناصر و سپس انتساب به آن‌ها انجام دهیم، اما معمولاً روش‌های دیگری هستند که زیباتر به نظر می‌رسند. در اینجا دو روش محبوب را معرفی می‌کنیم:

- **سازنده‌ی initializer-list**: مقداردهی اولیه با یک لیست از عناصر.
- **`push_back()`**: افزودن یک عنصر جدید در انتهای توالی (دنباله).

این‌ها را می‌توان به صورت زیر اعلام کرد:

```cpp
class Vector {
public:
    Vector(std::initializer_list<double>); // مقداردهی اولیه با یک لیست
    // ...
    void push_back(double); // افزودن عنصر در انتها و افزایش اندازه به میزان یک
    // ...
};
```

تابع `push_back()` برای ورودی گرفتن تعداد دلخواهی از عناصر مفید است. برای مثال:

```cpp
Vector read(istream& is)
{
    Vector v;
    for (double d; is >> d;) // خواندن مقادیر اعشاری در d
        v.push_back(d); // افزودن d به v
    return v;
}
```

این حلقه‌ی ورودی با رسیدن به انتهای فایل یا یک خطای قالب‌بندی متوقف می‌شود. تا زمانی که این اتفاق نیفتاده، هر عددی که خوانده می‌شود به `Vector` اضافه می‌شود، بنابراین در پایان، اندازه‌ی `v` برابر با تعداد عناصر خوانده شده است. من از یک عبارت `for` به جای عبارت `while` متداول‌تر استفاده کردم تا محدوده‌ی `d` را به خود حلقه محدود کنم. پیاده‌سازی `push_back()` در بخش ۱۳.۶.۴.۳ بحث شده است. روش ارائه‌ی یک سازنده‌ی move برای `Vector`، تا بازگرداندن حجم زیادی از داده‌ها از `read()` ارزان باشد، در بخش ۳.۳.۲ توضیح داده شده است.

نوع `std::initializer_list` که برای تعریف سازنده‌ی initializer-list استفاده می‌شود، یک نوع از کتابخانه استاندارد است که برای کامپایلر شناخته شده است: وقتی از یک لیست `{}` مانند `{1,2,3,4}` استفاده می‌کنیم، کامپایلر یک شیء از نوع `initializer_list` ایجاد می‌کند تا به برنامه بدهد. بنابراین، می‌توانیم به این شکل بنویسیم:

```cpp
Vector v1 = {1,2,3,4,5}; // v1 دارای 5 عنصر است
Vector v2 = {1.23, 3.45, 6.7, 8}; // v2 دارای 4 عنصر است
```

سازنده‌ی initializer-list برای `Vector` ممکن است به این صورت تعریف شود:

```cpp
Vector::Vector(std::initializer_list<double> lst) // مقداردهی اولیه با یک لیست
    :elem{new double[lst.size()]}, sz{lst.size()}
{
    copy(lst.begin(), lst.end(), elem); // کپی کردن از lst به elem
}
```

---

این بخش توضیح می‌دهد که حلقه‌ی ورودی در تابع `read` چگونه کار می‌کند و چرا از یک عبارت `for` استفاده شده است به جای `while`. همچنین، به بهینه‌سازی‌هایی برای بازگرداندن داده‌ها اشاره می‌کند.

### ۱. پایان یافتن حلقه ورودی
در تابع `read`، یک حلقه‌ی ورودی وجود دارد که اعداد اعشاری را از ورودی (مثل فایل یا ورودی کاربر) می‌خواند. این حلقه تا زمانی ادامه پیدا می‌کند که به یکی از موارد زیر برسد:

- **پایان فایل (end-of-file)**: یعنی تمام محتویات فایل یا ورودی کاربر خوانده شده باشد.
- **خطای قالب‌بندی (formatting error)**: یعنی مقدار ورودی از نوع مورد انتظار نباشد (مثلاً، وارد کردن کاراکتر غیرعددی).

تا زمانی که این اتفاق نیفتاده، هر عددی که خوانده می‌شود به `Vector` اضافه می‌شود. در پایان، اندازه‌ی `Vector` برابر خواهد بود با تعداد عناصری که از ورودی خوانده شده‌اند.

### ۲. استفاده از `for` به جای `while`
در اینجا از یک عبارت `for` استفاده شده است تا محدوده‌ی متغیر `d` به داخل حلقه محدود شود. به این معنی که `d` تنها در محدوده‌ی حلقه قابل دسترسی است و پس از پایان حلقه، دیگر در دسترس نیست. این تکنیک باعث خوانایی بیشتر و جلوگیری از دسترسی ناخواسته به `d` خارج از حلقه می‌شود.

### ۳. سازنده‌ی move برای بهینه‌سازی بازگشت داده‌های حجیم
برای بازگرداندن داده‌های حجیم از تابع `read`، نیاز به **سازنده‌ی move** داریم. این سازنده به `Vector` اجازه می‌دهد تا داده‌های خود را بدون کپی‌کردن کامل بازگرداند، که این کار باعث بهبود کارایی می‌شود، به خصوص اگر تعداد زیادی داده در `Vector` باشد.

### جمع‌بندی
در این کد:
- حلقه‌ی `for` به سادگی تا زمان رسیدن به پایان فایل یا خطای ورودی ادامه می‌یابد و از `push_back` برای افزودن داده‌ها به `Vector` استفاده می‌کند.
- سازنده‌ی move در `Vector` از کپی غیرضروری داده‌های حجیم جلوگیری کرده و بازگشت داده‌ها را سریع‌تر و ارزان‌تر می‌کند.

---


---

در `std::initializer_list` در C++ نوعی است که به ما امکان می‌دهد مجموعه‌ای از مقادیر را به صورت یک لیست `{}` به سازنده یا تابعی پاس دهیم. این نوع در مواردی مفید است که بخواهیم تعداد متغیری از مقادیر را به یک سازنده یا تابع بفرستیم و به کد این اجازه را می‌دهد که این مقادیر را به صورت یک لیست ثابت بخواند. این نوع در استاندارد C++11 معرفی شده است.

### ساختار `std::initializer_list`

وقتی یک لیست مقادیر `{}` را به یک سازنده یا تابعی که یک پارامتر `std::initializer_list` دارد ارسال می‌کنیم، کامپایلر به طور خودکار شیء `initializer_list` را می‌سازد. این شیء شامل مقادیر داخل لیست و اندازه‌ی آن‌ها است.

### مثال ساده: استفاده از `std::initializer_list` در یک کلاس

بیایید کلاسی به نام `MyVector` تعریف کنیم که می‌تواند با لیستی از اعداد مقداردهی اولیه شود:

```cpp
#include <iostream>
#include <initializer_list>

class MyVector {
private:
    int* data;
    size_t size;

public:
    // سازنده با استفاده از std::initializer_list
    MyVector(std::initializer_list<int> init_list) 
        : size(init_list.size())
    {
        data = new int[size];
        size_t index = 0;
        for (int value : init_list) {
            data[index++] = value;
        }
    }

    // نمایش عناصر
    void print() const {
        for (size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }

    // مخرب برای آزاد کردن حافظه
    ~MyVector() {
        delete[] data;
    }
};

int main() {
    MyVector vec = {1, 2, 3, 4, 5}; // مقداردهی اولیه با لیست
    vec.print(); // خروجی: 1 2 3 4 5
    return 0;
}
```

### توضیح کد

در اینجا:

1. **سازنده‌ی `MyVector`**: سازنده‌ی `MyVector` یک پارامتر `std::initializer_list<int>` می‌گیرد که به آن `init_list` می‌گوییم. این پارامتر لیستی از مقادیر `{1, 2, 3, 4, 5}` را دریافت می‌کند.
2. **کپی کردن مقادیر**: با استفاده از یک حلقه `for`، مقادیر در `init_list` را به آرایه‌ی `data` کپی می‌کنیم.
3. **استفاده در `main`**: در تابع `main`، با استفاده از `{}`، `MyVector` را مقداردهی اولیه می‌کنیم و سپس عناصر آن را چاپ می‌کنیم.

### مزایای `std::initializer_list`

- **ساده و خوانا**: به ما اجازه می‌دهد به شکل ساده و خوانایی کلاس‌ها یا توابع را با لیست مقادیر مقداردهی اولیه کنیم.
- **ایمنی بیشتر**: `initializer_list` به عنوان یک لیست ثابت است، بنابراین نمی‌توان مقادیر آن را تغییر داد.

### مثال دیگر: تابعی با `initializer_list`

می‌توانیم توابعی تعریف کنیم که پارامتر `initializer_list` دریافت می‌کنند. برای مثال، تابعی که تعدادی عدد را دریافت کرده و مجموع آن‌ها را محاسبه می‌کند:

```cpp
#include <iostream>
#include <initializer_list>

int sum(std::initializer_list<int> numbers) {
    int total = 0;
    for (int value : numbers) {
        total += value;
    }
    return total;
}

int main() {
    int result = sum({10, 20, 30, 40});
    std::cout << "Sum is: " << result << std::endl; // خروجی: Sum is: 100
    return 0;
}
```

در این کد:

- تابع `sum` یک `std::initializer_list<int>` به نام `numbers` می‌گیرد و مجموع مقادیر آن را محاسبه می‌کند.
- سپس در `main`، `{10, 20, 30, 40}` به عنوان لیست مقادیر پاس داده می‌شود.

### جمع‌بندی

`std::initializer_list` یک روش راحت و امن برای پاس دادن لیست ثابت مقادیر به توابع یا سازنده‌ها است. این نوع در C++ کدی تمیزتر و خواناتر تولید می‌کند و نیاز به نوشتن چندین سازنده یا تابع مختلف برای مقادیر متفاوت را کاهش می‌دهد.

---


---

این بخش توضیح می‌دهد که حلقه‌ی ورودی در تابع `read` چگونه کار می‌کند و چرا از یک عبارت `for` استفاده شده است به جای `while`. همچنین، به بهینه‌سازی‌هایی برای بازگرداندن داده‌ها اشاره می‌کند.

### ۱. پایان یافتن حلقه ورودی
در تابع `read`، یک حلقه‌ی ورودی وجود دارد که اعداد اعشاری را از ورودی (مثل فایل یا ورودی کاربر) می‌خواند. این حلقه تا زمانی ادامه پیدا می‌کند که به یکی از موارد زیر برسد:

- **پایان فایل (end-of-file)**: یعنی تمام محتویات فایل یا ورودی کاربر خوانده شده باشد.
- **خطای قالب‌بندی (formatting error)**: یعنی مقدار ورودی از نوع مورد انتظار نباشد (مثلاً، وارد کردن کاراکتر غیرعددی).

تا زمانی که این اتفاق نیفتاده، هر عددی که خوانده می‌شود به `Vector` اضافه می‌شود. در پایان، اندازه‌ی `Vector` برابر خواهد بود با تعداد عناصری که از ورودی خوانده شده‌اند.

### ۲. استفاده از `for` به جای `while`
در اینجا از یک عبارت `for` استفاده شده است تا محدوده‌ی متغیر `d` به داخل حلقه محدود شود. به این معنی که `d` تنها در محدوده‌ی حلقه قابل دسترسی است و پس از پایان حلقه، دیگر در دسترس نیست. این تکنیک باعث خوانایی بیشتر و جلوگیری از دسترسی ناخواسته به `d` خارج از حلقه می‌شود.

### ۳. سازنده‌ی move برای بهینه‌سازی بازگشت داده‌های حجیم
برای بازگرداندن داده‌های حجیم از تابع `read`، نیاز به **سازنده‌ی move** داریم. این سازنده به `Vector` اجازه می‌دهد تا داده‌های خود را بدون کپی‌کردن کامل بازگرداند، که این کار باعث بهبود کارایی می‌شود، به خصوص اگر تعداد زیادی داده در `Vector` باشد.

### جمع‌بندی
در این کد:
- حلقه‌ی `for` به سادگی تا زمان رسیدن به پایان فایل یا خطای ورودی ادامه می‌یابد و از `push_back` برای افزودن داده‌ها به `Vector` استفاده می‌کند.
- سازنده‌ی move در `Vector` از کپی غیرضروری داده‌های حجیم جلوگیری کرده و بازگشت داده‌ها را سریع‌تر و ارزان‌تر می‌کند.

---

عبارت `for (double d; is >> d;)` یک حلقه `for` است که به شکلی غیرمعمول نوشته شده تا یک عدد اعشاری را از ورودی بخواند و آن را در `d` ذخیره کند. این بخش را می‌توانیم به صورت دقیق‌تری بشکافیم:

### ساختار کلی
حلقه `for` به شکل کلی زیر است:

```cpp
for (initialization; condition; increment) {
    // loop body
}
```

اما در اینجا ساختار `for` به این صورت است:

```cpp
for (double d; is >> d;) {
    // loop body
}
```

* `initialization` (مقداردهی اولیه): `double d;` - اینجا یک متغیر `d` از نوع `double` تعریف شده است.
* `condition` (شرط): `is >> d;` - عملگر `>>` سعی می‌کند یک عدد اعشاری از `is` (جریان ورودی) بخواند و در `d` قرار دهد. اگر خواندن موفق باشد، مقدار شرط `true` می‌شود و حلقه ادامه پیدا می‌کند. اگر خواندن به مشکل بخورد (مثلاً به انتهای فایل برسد یا ورودی نادرستی داشته باشیم)، مقدار شرط `false` می‌شود و حلقه متوقف می‌شود.
* `increment` (افزایش): این قسمت در این حلقه خالی است چون نیازی به عمل اضافه‌ای در پایان هر تکرار نداریم.

### مثال‌های کاربردی

فرض کنید یک جریان ورودی (مثلاً از یک فایل یا کاربر) داریم که شامل اعداد اعشاری است.

#### مثال 1: خواندن اعداد از ورودی کاربر

```cpp
#include <iostream>
#include <vector>

std::vector<double> read(std::istream& is) {
    std::vector<double> v;
    for (double d; is >> d;) {
        v.push_back(d);
    }
    return v;
}

int main() {
    std::cout << "Enter numbers (non-number to stop): ";
    std::vector<double> numbers = read(std::cin);
    std::cout << "You entered: ";
    for (double num : numbers) {
        std::cout << num << " ";
    }
}
```

**نحوه‌ی کار این کد:**
1. کاربر می‌تواند اعداد اعشاری را وارد کند، مانند: `3.14 2.71 1.41`.
2. هر بار که کاربر یک عدد وارد می‌کند و `Enter` را می‌زند، آن عدد خوانده می‌شود و در `d` ذخیره می‌شود.
3. سپس `d` به وکتور `v` اضافه می‌شود.
4. اگر کاربر عددی غیر از `double` وارد کند، مثلاً یک حرف، حلقه متوقف می‌شود.

**مثال اجرا:**

```
Enter numbers (non-number to stop): 3.14 2.71 1.41 hello
You entered: 3.14 2.71 1.41
```

در اینجا وقتی کاربر `hello` را وارد کرده، حلقه به دلیل خطای قالب‌بندی متوقف شده است.

#### مثال 2: خواندن اعداد از یک فایل

فرض کنید فایلی به نام `numbers.txt` داریم که شامل داده‌های زیر است:

```
1.23
4.56
7.89
```

کد:

```cpp
#include <iostream>
#include <fstream>
#include <vector>

std::vector<double> read(std::istream& is) {
    std::vector<double> v;
    for (double d; is >> d;) {
        v.push_back(d);
    }
    return v;
}

int main() {
    std::ifstream file("numbers.txt");
    std::vector<double> numbers = read(file);
    std::cout << "Numbers from file: ";
    for (double num : numbers) {
        std::cout << num << " ";
    }
}
```

**نحوه‌ی کار این کد:**
1. فایل `numbers.txt` باز می‌شود.
2. حلقه `for` هر خط از فایل را می‌خواند و به عنوان یک عدد اعشاری (`double`) در `d` ذخیره می‌کند.
3. مقادیر خوانده شده به وکتور `v` اضافه می‌شود.

**نتیجه:**

```
Numbers from file: 1.23 4.56 7.89
```

#### مثال 3: حلقه‌ای که به دلیل پایان فایل متوقف می‌شود

فایلی داریم به نام `numbers.txt` با محتوای زیر:

```
1.23
4.56
7.89
```

و کد زیر را اجرا می‌کنیم:

```cpp
#include <iostream>
#include <fstream>
#include <vector>

std::vector<double> read(std::istream& is) {
    std::vector<double> v;
    for (double d; is >> d;) {
        v.push_back(d);
    }
    return v;
}

int main() {
    std::ifstream file("numbers.txt");
    std::vector<double> numbers = read(file);
    std::cout << "Numbers from file: ";
    for (double num : numbers) {
        std::cout << num << " ";
    }
}
```

وقتی به انتهای فایل برسیم، عملگر `is >> d` مقدار `false` برمی‌گرداند و حلقه متوقف می‌شود.

**خروجی:**

```
Numbers from file: 1.23 4.56 7.89
```

#### خلاصه

عبارت `for (double d; is >> d;)` به این شکل عمل می‌کند:
- یک متغیر `double` به نام `d` تعریف می‌کند.
- در هر تکرار، یک عدد اعشاری را از ورودی می‌خواند و در `d` ذخیره می‌کند.
- اگر خواندن موفق باشد، حلقه ادامه پیدا می‌کند؛ در غیر این صورت، متوقف می‌شود.